package bridge

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
	"text/template"

	"github.com/lyraproj/pcore/pcore"

	"github.com/lyraproj/pcore/types"

	"github.com/lyraproj/pcore/px"

	"github.com/hashicorp/terraform/helper/validation"

	"github.com/hashicorp/terraform/helper/schema"
)

type generator struct {
	ctx           px.Context
	generated     map[string]*structData
	Namespace     string
	Package       string
	ResourceTypes []*structData
	IncludeTime   bool
	IncludeRegexp bool
	skipPrefix    string
	salt          int
}

type structData struct {
	StructType          string
	NativeType          string
	ExternalIdAttr      string
	ExternalIdField     string
	ProvidedAttributes  []string
	ImmutableAttributes []string
	StructFields        []*structField
}

type structField struct {
	FieldName string
	FieldType string
	schema    *schema.Schema
}

const ignoreTag = `tf-gen.ignore`

const codeTemplate = `// Code generated by Lyra DO NOT EDIT.

// This code is generated on a per-Provider basis using "tf-gen"
// Long term our hope is to remove this generation step and adopt dynamic approach

package {{.Package}}

import (
{{- if .IncludeRegexp}} "regexp"{{end}}
{{- if .IncludeTime}} "time"{{end}}
	"github.com/hashicorp/terraform/helper/schema"
	"github.com/lyraproj/pcore/px"
	"github.com/lyraproj/servicesdk/service"
	"github.com/lyraproj/terraform-bridge/pkg/bridge"
)

type (
{{- range .ResourceTypes}}
	{{.StructType}} struct {
		{{.ExternalIdField}} *string ` + "`lyra:\"" + ignoreTag + "\"`" + `
  {{- range .StructFields}}
    {{.FieldName}} {{.FieldType}}{{end}}
	}
{{end}}
)

func Initialize(sb *service.Builder, p *schema.Provider) {
  // Generic handler API
  sb.RegisterAPI("{{$.Namespace}}::GenericHandler", bridge.NewTFHandler(nil, nil, "", ""))

  // Registration of resource types with handler
	var rt px.Type
{{- range .ResourceTypes}}
	rt = sb.RegisterTypes("{{$.Namespace}}",
	{{- if or .ProvidedAttributes .ImmutableAttributes}} sb.BuildResource(&{{.StructType}}{}, func (b service.ResourceTypeBuilder) {
	{{- if .ProvidedAttributes}}
		b.ProvidedAttributes({{range $i, $e := .ProvidedAttributes}}{{if $i}}, {{end}}"{{$e}}"{{end}})
	{{- end}}
	{{- if .ImmutableAttributes}}
		b.ImmutableAttributes({{range $i, $e := .ImmutableAttributes}}{{if $i}}, {{end}}"{{$e}}"{{end}})
	{{- end}}
	})
	{{- else}} &{{.StructType}}{}
	{{- end}})[0]
	sb.RegisterHandler("{{$.Namespace}}::{{.StructType}}Handler", bridge.NewTFHandler(p, rt, "{{.ExternalIdAttr}}", "{{.NativeType}}"), rt)
{{end}}
}
`

func mkdirs(filename string) {
	if err := os.MkdirAll(filepath.Dir(filename), os.ModePerm); err != nil {
		panic(err)
	}
}

func isValidateFunc(actual, expected schema.SchemaValidateFunc) bool {
	return reflect.ValueOf(actual).Pointer() == reflect.ValueOf(expected).Pointer()
}

func (g *generator) writeRequiredType(name string, s *schema.Schema, b, ab *bytes.Buffer) bool {
	//   TypeBool - bool
	//   TypeInt - int64
	//   TypeFloat - float64
	//   TypeString - string, time.Time, or regexp.Regexp
	//   TypeList - []<type of Elem>
	//   TypeMap - map[string]<type of Elem>
	//   TypeSet - []<type of Elem>
	annotations := false
	switch s.Type {
	case schema.TypeList, schema.TypeSet:
		/* Possible modification to get rid of redunant Array constructs. Speaking against it is that Terraform
		   doesn't seem to be using MaxItems consistently for this purpose (makes it hard for the user to know
		   when to use and not to use an Array) and it screws up marshal/unmarshal in a bad way, so left out for
		   the time being.
		if r, ok := s.Elem.(*schema.Resource); ok && s.MaxItems == 1 {
			// Terraform wraps nested resources in a TypeSet or TypeList because they don't have any
			// ValueType to represent the Object type. A s.MinItems here means that the entry is optional.
			rq := (s.Computed || s.Optional) && s.MinItems == 0
			if rq {
				b.WriteByte('*')
				ab.WriteString("Optional[")
			}
			g.writeAnonymousStruct(r, b, ab)
			if rq {
				ab.WriteByte(']')
			}
			return true
		}
		*/
		b.WriteString("[]")
		ab.WriteString("Array[")
		annotations = g.writeElementType(name, s, b, ab)
		ab.WriteByte(']')
	case schema.TypeMap:
		b.WriteString("map[string]")
		ab.WriteString("Hash[String,")
		annotations = g.writeElementType(name, s, b, ab)
		ab.WriteByte(']')
	default:
		g.writePrimitive(s, s.Type, b, ab)
	}
	return annotations
}

func (g *generator) writePrimitive(s *schema.Schema, t schema.ValueType, b, ab *bytes.Buffer) {
	switch t {
	case schema.TypeBool:
		b.WriteString("bool")
		ab.WriteString("Boolean")
	case schema.TypeInt:
		b.WriteString("int64")
		ab.WriteString("Integer")
	case schema.TypeFloat:
		b.WriteString("float64")
		ab.WriteString("Float")
	case schema.TypeString:
		if s != nil && s.ValidateFunc != nil {
			if isValidateFunc(s.ValidateFunc, validation.ValidateRFC3339TimeString) {
				g.IncludeTime = true
				b.WriteString("time.Time")
				ab.WriteString("Timestamp")
				break
			} else if isValidateFunc(s.ValidateFunc, validation.ValidateRegexp) {
				g.IncludeRegexp = true
				b.WriteString("regexp.Regexp")
				ab.WriteString("Regexp")
				break
			}
		}
		b.WriteString("string")
		ab.WriteString("String")
	default:
		panic(fmt.Errorf("not a primitive type: %s", t.String()))
	}
}

func (g *generator) writeElementType(name string, s *schema.Schema, b, ab *bytes.Buffer) bool {
	annotations := false
	switch el := s.Elem.(type) {
	case nil:
		// Default to using a string
		b.WriteString("string")
		ab.WriteString("String")
	case *schema.Resource:
		g.writeAnonymousStruct(el, b, ab)
		annotations = true
	case *schema.Schema:
		g.writeType(name, el, b, ab)
	case schema.ValueType:
		switch el {
		case schema.TypeList, schema.TypeSet:
			// No nested element type available. Default to string
			b.WriteString("[]string")
			ab.WriteString("Array[String]")
		case schema.TypeMap:
			// No nested element type available. Default to string
			b.WriteString("map[string]string")
			ab.WriteString("Hash[String, String]")
		default:
			g.writePrimitive(nil, el, b, ab)
		}
	default:
		panic(fmt.Sprintf("Unsupported TypeMap: %v", el))
	}
	return annotations
}

func (g *generator) writeType(name string, s *schema.Schema, b, ab *bytes.Buffer) bool {
	// An attribute with a specified Default doesn't have to be optional since it's value will always be
	// set to the default (by pcore as well as by terraform).
	//
	// An attribute with a DefaultFunc must be considered optional since the function may return different
	// values at different times (environment settings etc. may affect what it returns).
	opt := s.Default == nil && (s.Computed || s.Optional || s.DefaultFunc != nil)
	if opt {
		b.WriteByte('*')
		ab.WriteString("Optional[")
	}
	na := g.writeRequiredType(name, s, b, ab)
	if opt {
		ab.WriteByte(']')
	}
	return na
}

func (g *generator) generateCode() []byte {
	tmpl := template.Must(template.New("codeTemplate").Parse(codeTemplate))
	b := bytes.NewBuffer(make([]byte, 0, 0x10000)) // Start with a reasonably large buffer to avoid lots of reallocation
	err := tmpl.Execute(b, g)
	if err != nil {
		panic(err)
	}
	return b.Bytes()
}

func (g *generator) writeCommonType(r *schema.Resource, b, ab *bytes.Buffer) {
	t := schema.TypeInvalid
	var cs *schema.Schema
	for _, a := range r.Schema {
		at := a.Type
		if t == schema.TypeInvalid {
			t = at
			cs = a
			continue
		}
		if t != at {
			t = schema.TypeInvalid
			break
		}
		if cs != nil {
			// Only keep common schema if validate function matches
			if cs.ValidateFunc == nil {
				if a.ValidateFunc != nil {
					cs = nil
				}
			} else {
				if a.ValidateFunc != nil && !isValidateFunc(cs.ValidateFunc, a.ValidateFunc) {
					cs = nil
				}
			}
		}
	}
	switch t {
	case schema.TypeInvalid:
		b.WriteString("interface{}")
	case schema.TypeList, schema.TypeSet:
		b.WriteString("[]interface{}")
	case schema.TypeMap:
		b.WriteString("map[string]interface{}")
	default:
		g.writePrimitive(cs, t, b, ab)
	}
}

func (g *generator) writeAnonymousStruct(r *schema.Resource, b, ab *bytes.Buffer) {
	// Sort field names to give predictable code generation
	b.WriteString(`map[string]`)
	toss := bytes.NewBufferString(``)
	g.writeCommonType(r, b, toss)
	toss.Reset()

	ab.WriteString(`Struct[`)
	names := make([]string, 0, len(r.Schema))
	for name := range r.Schema {
		ab := r.Schema[name]
		if ab.Removed == `` && ab.Deprecated == `` {
			names = append(names, name)
		}
	}
	sort.Strings(names)
	for i, name := range names {
		if i > 0 {
			ab.WriteByte(',')
		}
		as := r.Schema[name]
		tn := name
		switch tn {
		case `true`, `false`, `undef`, `default`:
			tn = `'` + tn + `'`
		}
		if as.Computed || as.Optional {
			ab.WriteString("Optional[")
			ab.WriteString(tn)
			ab.WriteByte(']')
		} else {
			ab.WriteString(tn)
		}
		ab.WriteString("=>")
		g.writeRequiredType(name, as, toss, ab)
	}
	ab.WriteByte(']')
}
func (g *generator) generateResourceType(nativeType string, r *schema.Resource, path []string) string {
	lcStructType := g.skipPackage(nativeType)
	structType := strings.Title(lcStructType)

	// Attempt to use an external id that consists of the type name with an appended '_id'. If this
	// collides with an existing attribute, then use '_lyra_id' instead to ensure uniqueness.
	extIdSuffix := `_id`
	extIdAttr := lcStructType + extIdSuffix
	if _, exists := r.Schema[extIdAttr]; exists {
		extIdSuffix = `_lyra_id`
		extIdAttr = lcStructType + extIdSuffix
	}
	extIdField := structType + extIdSuffix

	if _, ok := g.generated[nativeType]; ok {
		return structType
	}

	// Sort field names to give predictable code generation
	names := make([]string, 0, len(r.Schema))
	for name := range r.Schema {
		names = append(names, name)
	}
	sort.Strings(names)

	// Check for provided and immutable attributes
	var providedAttributes []string
	var immutableAttributes []string

	providedAttributes = append(providedAttributes, extIdAttr)
	for _, name := range names {
		s := r.Schema[name]
		if s.ForceNew {
			immutableAttributes = append(immutableAttributes, name)
		}
		if s.Computed {
			providedAttributes = append(providedAttributes, name)
		}
	}

	b := bytes.NewBufferString(``)
	ab := bytes.NewBufferString(``)

	// Determine field names and types
	structFields := make([]*structField, len(names))
	for i, name := range names {
		b.Reset()
		ab.Reset()
		rs := r.Schema[name]
		pa := g.writeType(name, rs, b, ab)
		pt := g.ctx.ParseType(ab.String())

		if pa {
			b.WriteString(" `puppet:\"type => ")
			b.Write(ab.Bytes())
			if rs.Default != nil {
				b.WriteByte(',')
				g.writeDefaultValue(structType+"."+name+".default", rs.Default, pt, b)
			}
			b.WriteString("\"`")
		} else if rs.Default != nil {
			b.WriteString(" `puppet:\"")
			g.writeDefaultValue(structType+"."+name+".default", rs.Default, pt, b)
			b.WriteString("\"`")
		}
		structFields[i] = &structField{
			FieldName: strings.Title(name),
			FieldType: b.String(),
		}
	}

	// Build template data
	sd := &structData{
		StructType:          structType,
		NativeType:          nativeType,
		ExternalIdAttr:      extIdAttr,
		ExternalIdField:     extIdField,
		StructFields:        structFields,
		ProvidedAttributes:  providedAttributes,
		ImmutableAttributes: immutableAttributes}
	g.generated[nativeType] = sd
	g.ResourceTypes = append(g.ResourceTypes, sd)
	return structType
}

func (g *generator) writeDefaultValue(label string, dv interface{}, t px.Type, b *bytes.Buffer) {
	v := types.CoerceTo(g.ctx, label, false, t, px.Wrap(g.ctx, dv))
	b.WriteString(`value=>`)
	v.ToString(b, types.Program, nil)
}

// formatCode reformats the code as `go fmt` would
func (g *generator) formatCode(code []byte) []byte {
	src, err := format.Source(code)
	if err != nil {
		panic(fmt.Errorf("unexpected error running format.Source: %s", err.Error()))
	}
	return src
}

func writeSourceFile(filename string, source ...[]byte) {
	mkdirs(filename)
	f, err := os.Create(filename)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	for _, s := range source {
		_, err = f.Write(s)
		if err != nil {
			panic(err)
		}
	}
}

// Generate the Lyra boilerplate needed to bridge to a Terraform provider
func Generate(p *schema.Provider, ns, pkg, filename string) {
	// Sort native types to give predictable output
	nativeTypes := make([]string, 0, len(p.ResourcesMap))
	for nativeType := range p.ResourcesMap {
		nativeTypes = append(nativeTypes, nativeType)
	}
	sort.Strings(nativeTypes)

	pcore.Do(func(c px.Context) {
		g := &generator{
			ctx:           c,
			Namespace:     ns,
			Package:       pkg,
			ResourceTypes: make([]*structData, 0, len(nativeTypes)),
			generated:     make(map[string]*structData, 53),
			skipPrefix:    pkg + `_`,
		}

		// Generate code
		for _, nativeType := range nativeTypes {
			g.generateResourceType(nativeType, p.ResourcesMap[nativeType], []string{})
		}

		code := g.generateCode()

		// Write source
		writeSourceFile(filename, g.formatCode(code))
	})
}

func (g *generator) skipPackage(name string) string {
	if strings.HasPrefix(name, g.skipPrefix) {
		name = name[len(g.skipPrefix):]
	}
	return name
}
