// Code generated by Lyra DO NOT EDIT.

// This code is generated on a per-Provider basis using "tf-gen"
// Long term our hope is to remove this generation step and adopt dynamic approach

package aws

import (
	"github.com/hashicorp/terraform/helper/schema"
	"github.com/lyraproj/pcore/px"
	"github.com/lyraproj/servicesdk/service"
	"github.com/lyraproj/terraform-bridge/pkg/bridge"
	"time"
)

type (
	Acm_certificate struct {
		Acm_certificate_id        *string `lyra:"tf-gen.ignore"`
		Arn                       *string
		Certificate_body          *string
		Certificate_chain         *string
		Domain_name               *string
		Domain_validation_options *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[domain_name]=>String,Optional[resource_record_name]=>String,Optional[resource_record_type]=>String,Optional[resource_record_value]=>String]]]"`
		Private_key               *string
		Subject_alternative_names *[]string
		Tags                      *map[string]string
		Validation_emails         *[]string
		Validation_method         *string
	}

	Acm_certificate_validation struct {
		Acm_certificate_validation_id *string `lyra:"tf-gen.ignore"`
		Certificate_arn               string
		Validation_record_fqdns       *[]string
	}

	Acmpca_certificate_authority struct {
		Acmpca_certificate_authority_id     *string `lyra:"tf-gen.ignore"`
		Arn                                 *string
		Certificate                         *string
		Certificate_authority_configuration *map[string]interface{} `puppet:"type => Optional[Struct[key_algorithm=>String,signing_algorithm=>String,subject=>Struct[Optional[common_name]=>String,Optional[country]=>String,Optional[distinguished_name_qualifier]=>String,Optional[generation_qualifier]=>String,Optional[given_name]=>String,Optional[initials]=>String,Optional[locality]=>String,Optional[organization]=>String,Optional[organizational_unit]=>String,Optional[pseudonym]=>String,Optional[state]=>String,Optional[surname]=>String,Optional[title]=>String]]]"`
		Certificate_chain                   *string
		Certificate_signing_request         *string
		Enabled                             bool `puppet:"value=>true"`
		Not_after                           *string
		Not_before                          *string
		Revocation_configuration            *map[string][]interface{} `puppet:"type => Optional[Struct[Optional[crl_configuration]=>Struct[Optional[custom_cname]=>String,Optional[enabled]=>Boolean,expiration_in_days=>Integer,Optional[s3_bucket_name]=>String]]]"`
		Serial                              *string
		Status                              *string
		Tags                                *map[string]string
		Type                                string `puppet:"value=>'SUBORDINATE'"`
	}

	Alb struct {
		Alb_id                           *string                 `lyra:"tf-gen.ignore"`
		Access_logs                      *map[string]interface{} `puppet:"type => Optional[Struct[bucket=>String,Optional[enabled]=>Boolean,Optional[prefix]=>String]]"`
		Arn                              *string
		Arn_suffix                       *string
		Dns_name                         *string
		Enable_cross_zone_load_balancing bool  `puppet:"value=>false"`
		Enable_deletion_protection       bool  `puppet:"value=>false"`
		Enable_http2                     bool  `puppet:"value=>true"`
		Idle_timeout                     int64 `puppet:"value=>60"`
		Internal                         *bool
		Ip_address_type                  *string
		Load_balancer_type               string `puppet:"value=>'application'"`
		Name                             *string
		Name_prefix                      *string
		Security_groups                  *[]string
		Subnet_mapping                   *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[allocation_id]=>String,subnet_id=>String]]]"`
		Subnets                          *[]string
		Tags                             *map[string]string
		Vpc_id                           *string
		Zone_id                          *string
	}

	Alb_listener struct {
		Alb_listener_id   *string `lyra:"tf-gen.ignore"`
		Arn               *string
		Certificate_arn   *string
		Default_action    []map[string]interface{} `puppet:"type => Array[Struct[Optional[authenticate_cognito]=>Struct[Optional[authentication_request_extra_params]=>Hash[String,String],Optional[on_unauthenticated_request]=>String,Optional[scope]=>String,Optional[session_cookie_name]=>String,Optional[session_timeout]=>Integer,user_pool_arn=>String,user_pool_client_id=>String,user_pool_domain=>String],Optional[authenticate_oidc]=>Struct[Optional[authentication_request_extra_params]=>Hash[String,String],authorization_endpoint=>String,client_id=>String,client_secret=>String,issuer=>String,Optional[on_unauthenticated_request]=>String,Optional[scope]=>String,Optional[session_cookie_name]=>String,Optional[session_timeout]=>Integer,token_endpoint=>String,user_info_endpoint=>String],Optional[fixed_response]=>Struct[content_type=>String,Optional[message_body]=>String,Optional[status_code]=>String],Optional[order]=>Integer,Optional[redirect]=>Struct[Optional[host]=>String,Optional[path]=>String,Optional[port]=>String,Optional[protocol]=>String,Optional[query]=>String,status_code=>String],Optional[target_group_arn]=>String,type=>String]]"`
		Load_balancer_arn string
		Port              int64
		Protocol          string `puppet:"value=>'HTTP'"`
		Ssl_policy        *string
	}

	Alb_listener_certificate struct {
		Alb_listener_certificate_id *string `lyra:"tf-gen.ignore"`
		Certificate_arn             string
		Listener_arn                string
	}

	Alb_listener_rule struct {
		Alb_listener_rule_id *string                  `lyra:"tf-gen.ignore"`
		Action               []map[string]interface{} `puppet:"type => Array[Struct[Optional[authenticate_cognito]=>Struct[Optional[authentication_request_extra_params]=>Hash[String,String],Optional[on_unauthenticated_request]=>String,Optional[scope]=>String,Optional[session_cookie_name]=>String,Optional[session_timeout]=>Integer,user_pool_arn=>String,user_pool_client_id=>String,user_pool_domain=>String],Optional[authenticate_oidc]=>Struct[Optional[authentication_request_extra_params]=>Hash[String,String],authorization_endpoint=>String,client_id=>String,client_secret=>String,issuer=>String,Optional[on_unauthenticated_request]=>String,Optional[scope]=>String,Optional[session_cookie_name]=>String,Optional[session_timeout]=>Integer,token_endpoint=>String,user_info_endpoint=>String],Optional[fixed_response]=>Struct[content_type=>String,Optional[message_body]=>String,Optional[status_code]=>String],Optional[order]=>Integer,Optional[redirect]=>Struct[Optional[host]=>String,Optional[path]=>String,Optional[port]=>String,Optional[protocol]=>String,Optional[query]=>String,status_code=>String],Optional[target_group_arn]=>String,type=>String]]"`
		Arn                  *string
		Condition            []map[string]interface{} `puppet:"type => Array[Struct[Optional[field]=>String,Optional[values]=>Array[String,0,1]]]"`
		Listener_arn         string
		Priority             *int64
	}

	Alb_target_group struct {
		Alb_target_group_id  *string `lyra:"tf-gen.ignore"`
		Arn                  *string
		Arn_suffix           *string
		Deregistration_delay int64                   `puppet:"value=>300"`
		Health_check         *map[string]interface{} `puppet:"type => Optional[Struct[Optional[healthy_threshold]=>Integer,Optional[interval]=>Integer,Optional[matcher]=>String,Optional[path]=>String,Optional[port]=>String,Optional[protocol]=>String,Optional[timeout]=>Integer,Optional[unhealthy_threshold]=>Integer]]"`
		Name                 *string
		Name_prefix          *string
		Port                 *int64
		Protocol             *string
		Proxy_protocol_v2    bool                    `puppet:"value=>false"`
		Slow_start           int64                   `puppet:"value=>0"`
		Stickiness           *map[string]interface{} `puppet:"type => Optional[Struct[Optional[cookie_duration]=>Integer,Optional[enabled]=>Boolean,type=>String]]"`
		Tags                 *map[string]string
		Target_type          string `puppet:"value=>'instance'"`
		Vpc_id               *string
	}

	Alb_target_group_attachment struct {
		Alb_target_group_attachment_id *string `lyra:"tf-gen.ignore"`
		Availability_zone              *string
		Port                           *int64
		Target_group_arn               string
		Target_id                      string
	}

	Ami struct {
		Ami_id                 *string `lyra:"tf-gen.ignore"`
		Architecture           string  `puppet:"value=>'x86_64'"`
		Description            *string
		Ebs_block_device       *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[delete_on_termination]=>Boolean,device_name=>String,Optional[encrypted]=>Boolean,Optional[iops]=>Integer,Optional[snapshot_id]=>String,Optional[volume_size]=>Integer,Optional[volume_type]=>String]]]"`
		Ena_support            *bool
		Ephemeral_block_device *[]map[string]string `puppet:"type => Optional[Array[Struct[device_name=>String,virtual_name=>String]]]"`
		Image_location         *string
		Kernel_id              *string
		Manage_ebs_snapshots   *bool
		Name                   string
		Ramdisk_id             *string
		Root_device_name       *string
		Root_snapshot_id       *string
		Sriov_net_support      string `puppet:"value=>'simple'"`
		Tags                   *map[string]string
		Virtualization_type    string `puppet:"value=>'paravirtual'"`
	}

	Ami_copy struct {
		Ami_copy_id            *string `lyra:"tf-gen.ignore"`
		Architecture           *string
		Description            *string
		Ebs_block_device       *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[delete_on_termination]=>Boolean,Optional[device_name]=>String,Optional[encrypted]=>Boolean,Optional[iops]=>Integer,Optional[snapshot_id]=>String,Optional[volume_size]=>Integer,Optional[volume_type]=>String]]]"`
		Ena_support            *bool
		Encrypted              bool                 `puppet:"value=>false"`
		Ephemeral_block_device *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[device_name]=>String,Optional[virtual_name]=>String]]]"`
		Image_location         *string
		Kernel_id              *string
		Kms_key_id             *string
		Manage_ebs_snapshots   *bool
		Name                   string
		Ramdisk_id             *string
		Root_device_name       *string
		Root_snapshot_id       *string
		Source_ami_id          string
		Source_ami_region      string
		Sriov_net_support      *string
		Tags                   *map[string]string
		Virtualization_type    *string
	}

	Ami_from_instance struct {
		Ami_from_instance_id    *string `lyra:"tf-gen.ignore"`
		Architecture            *string
		Description             *string
		Ebs_block_device        *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[delete_on_termination]=>Boolean,Optional[device_name]=>String,Optional[encrypted]=>Boolean,Optional[iops]=>Integer,Optional[snapshot_id]=>String,Optional[volume_size]=>Integer,Optional[volume_type]=>String]]]"`
		Ena_support             *bool
		Ephemeral_block_device  *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[device_name]=>String,Optional[virtual_name]=>String]]]"`
		Image_location          *string
		Kernel_id               *string
		Manage_ebs_snapshots    *bool
		Name                    string
		Ramdisk_id              *string
		Root_device_name        *string
		Root_snapshot_id        *string
		Snapshot_without_reboot *bool
		Source_instance_id      string
		Sriov_net_support       *string
		Tags                    *map[string]string
		Virtualization_type     *string
	}

	Ami_launch_permission struct {
		Ami_launch_permission_id *string `lyra:"tf-gen.ignore"`
		Account_id               string
		Image_id                 string
	}

	Api_gateway_account struct {
		Api_gateway_account_id *string `lyra:"tf-gen.ignore"`
		Cloudwatch_role_arn    *string
		Throttle_settings      *map[string]interface{} `puppet:"type => Optional[Struct[Optional[burst_limit]=>Integer,Optional[rate_limit]=>Float]]"`
	}

	Api_gateway_api_key struct {
		Api_gateway_api_key_id *string `lyra:"tf-gen.ignore"`
		Created_date           *string
		Description            string `puppet:"value=>'Managed by Terraform'"`
		Enabled                bool   `puppet:"value=>true"`
		Last_updated_date      *string
		Name                   string
		Stage_key              *[]map[string]string `puppet:"type => Optional[Array[Struct[rest_api_id=>String,stage_name=>String]]]"`
		Value                  *string
	}

	Api_gateway_authorizer struct {
		Api_gateway_authorizer_id        *string `lyra:"tf-gen.ignore"`
		Authorizer_credentials           *string
		Authorizer_result_ttl_in_seconds *int64
		Authorizer_uri                   *string
		Identity_source                  string `puppet:"value=>'method.request.header.Authorization'"`
		Identity_validation_expression   *string
		Name                             string
		Provider_arns                    *[]string
		Rest_api_id                      string
		Type                             string `puppet:"value=>'TOKEN'"`
	}

	Api_gateway_base_path_mapping struct {
		Api_gateway_base_path_mapping_id *string `lyra:"tf-gen.ignore"`
		Api_id                           string
		Base_path                        *string
		Domain_name                      string
		Stage_name                       *string
	}

	Api_gateway_client_certificate struct {
		Api_gateway_client_certificate_id *string `lyra:"tf-gen.ignore"`
		Created_date                      *string
		Description                       *string
		Expiration_date                   *string
		Pem_encoded_certificate           *string
	}

	Api_gateway_deployment struct {
		Api_gateway_deployment_id *string `lyra:"tf-gen.ignore"`
		Created_date              *string
		Description               *string
		Execution_arn             *string
		Invoke_url                *string
		Rest_api_id               string
		Stage_description         *string
		Stage_name                string
		Variables                 *map[string]string
	}

	Api_gateway_documentation_part struct {
		Api_gateway_documentation_part_id *string            `lyra:"tf-gen.ignore"`
		Location                          *map[string]string `puppet:"type => Optional[Struct[Optional[method]=>String,Optional[name]=>String,Optional[path]=>String,Optional[status_code]=>String,type=>String]]"`
		Properties                        string
		Rest_api_id                       string
	}

	Api_gateway_documentation_version struct {
		Api_gateway_documentation_version_id *string `lyra:"tf-gen.ignore"`
		Description                          *string
		Rest_api_id                          string
		Version                              string
	}

	Api_gateway_domain_name struct {
		Api_gateway_domain_name_id *string `lyra:"tf-gen.ignore"`
		Certificate_arn            *string
		Certificate_body           *string
		Certificate_chain          *string
		Certificate_name           *string
		Certificate_private_key    *string
		Certificate_upload_date    *string
		Cloudfront_domain_name     *string
		Cloudfront_zone_id         *string
		Domain_name                string
		Endpoint_configuration     *map[string][]interface{} `puppet:"type => Optional[Struct[types=>Array[String,1,1]]]"`
		Regional_certificate_arn   *string
		Regional_certificate_name  *string
		Regional_domain_name       *string
		Regional_zone_id           *string
	}

	Api_gateway_gateway_response struct {
		Api_gateway_gateway_response_id *string `lyra:"tf-gen.ignore"`
		Response_parameters             *map[string]string
		Response_templates              *map[string]string
		Response_type                   string
		Rest_api_id                     string
		Status_code                     *string
	}

	Api_gateway_integration struct {
		Api_gateway_integration_id *string `lyra:"tf-gen.ignore"`
		Cache_key_parameters       *[]string
		Cache_namespace            *string
		Connection_id              *string
		Connection_type            string `puppet:"value=>'INTERNET'"`
		Content_handling           *string
		Credentials                *string
		Http_method                string
		Integration_http_method    *string
		Passthrough_behavior       *string
		Request_parameters         *map[string]string
		Request_parameters_in_json *string
		Request_templates          *map[string]string
		Resource_id                string
		Rest_api_id                string
		Timeout_milliseconds       int64 `puppet:"value=>29000"`
		Type                       string
		Uri                        *string
	}

	Api_gateway_integration_response struct {
		Api_gateway_integration_response_id *string `lyra:"tf-gen.ignore"`
		Content_handling                    *string
		Http_method                         string
		Resource_id                         string
		Response_parameters                 *map[string]string
		Response_parameters_in_json         *string
		Response_templates                  *map[string]string
		Rest_api_id                         string
		Selection_pattern                   *string
		Status_code                         string
	}

	Api_gateway_method struct {
		Api_gateway_method_id      *string `lyra:"tf-gen.ignore"`
		Api_key_required           bool    `puppet:"value=>false"`
		Authorization              string
		Authorization_scopes       *[]string
		Authorizer_id              *string
		Http_method                string
		Request_models             *map[string]string
		Request_parameters         *map[string]bool
		Request_parameters_in_json *string
		Request_validator_id       *string
		Resource_id                string
		Rest_api_id                string
	}

	Api_gateway_method_response struct {
		Api_gateway_method_response_id *string `lyra:"tf-gen.ignore"`
		Http_method                    string
		Resource_id                    string
		Response_models                *map[string]string
		Response_parameters            *map[string]bool
		Response_parameters_in_json    *string
		Rest_api_id                    string
		Status_code                    string
	}

	Api_gateway_method_settings struct {
		Api_gateway_method_settings_id *string `lyra:"tf-gen.ignore"`
		Method_path                    string
		Rest_api_id                    string
		Settings                       *map[string]interface{} `puppet:"type => Optional[Struct[Optional[cache_data_encrypted]=>Boolean,Optional[cache_ttl_in_seconds]=>Integer,Optional[caching_enabled]=>Boolean,Optional[data_trace_enabled]=>Boolean,Optional[logging_level]=>String,Optional[metrics_enabled]=>Boolean,Optional[require_authorization_for_cache_control]=>Boolean,Optional[throttling_burst_limit]=>Integer,Optional[throttling_rate_limit]=>Float,Optional[unauthorized_cache_control_header_strategy]=>String]]"`
		Stage_name                     string
	}

	Api_gateway_model struct {
		Api_gateway_model_id *string `lyra:"tf-gen.ignore"`
		Content_type         string
		Description          *string
		Name                 string
		Rest_api_id          string
		Schema               *string
	}

	Api_gateway_request_validator struct {
		Api_gateway_request_validator_id *string `lyra:"tf-gen.ignore"`
		Name                             string
		Rest_api_id                      string
		Validate_request_body            bool `puppet:"value=>false"`
		Validate_request_parameters      bool `puppet:"value=>false"`
	}

	Api_gateway_resource struct {
		Api_gateway_resource_id *string `lyra:"tf-gen.ignore"`
		Parent_id               string
		Path                    *string
		Path_part               string
		Rest_api_id             string
	}

	Api_gateway_rest_api struct {
		Api_gateway_rest_api_id  *string `lyra:"tf-gen.ignore"`
		Api_key_source           string  `puppet:"value=>'HEADER'"`
		Binary_media_types       *[]string
		Body                     *string
		Created_date             *string
		Description              *string
		Endpoint_configuration   *map[string][]interface{} `puppet:"type => Optional[Struct[types=>Array[String,1,1]]]"`
		Execution_arn            *string
		Minimum_compression_size int64 `puppet:"value=>-1"`
		Name                     string
		Policy                   *string
		Root_resource_id         *string
	}

	Api_gateway_stage struct {
		Api_gateway_stage_id  *string            `lyra:"tf-gen.ignore"`
		Access_log_settings   *map[string]string `puppet:"type => Optional[Struct[destination_arn=>String,format=>String]]"`
		Cache_cluster_enabled *bool
		Cache_cluster_size    *string
		Client_certificate_id *string
		Deployment_id         string
		Description           *string
		Documentation_version *string
		Execution_arn         *string
		Invoke_url            *string
		Rest_api_id           string
		Stage_name            string
		Tags                  *map[string]string
		Variables             *map[string]string
		Xray_tracing_enabled  *bool
	}

	Api_gateway_usage_plan struct {
		Api_gateway_usage_plan_id *string              `lyra:"tf-gen.ignore"`
		Api_stages                *[]map[string]string `puppet:"type => Optional[Array[Struct[api_id=>String,stage=>String]]]"`
		Description               *string
		Name                      string
		Product_code              *string
		Quota_settings            *map[string]interface{} `puppet:"type => Optional[Struct[limit=>Integer,Optional[offset]=>Integer,period=>String]]"`
		Throttle_settings         *map[string]interface{} `puppet:"type => Optional[Struct[Optional[burst_limit]=>Integer,Optional[rate_limit]=>Float]]"`
	}

	Api_gateway_usage_plan_key struct {
		Api_gateway_usage_plan_key_id *string `lyra:"tf-gen.ignore"`
		Key_id                        string
		Key_type                      string
		Name                          *string
		Usage_plan_id                 string
		Value                         *string
	}

	Api_gateway_vpc_link struct {
		Api_gateway_vpc_link_id *string `lyra:"tf-gen.ignore"`
		Description             *string
		Name                    string
		Target_arns             []string
	}

	App_cookie_stickiness_policy struct {
		App_cookie_stickiness_policy_id *string `lyra:"tf-gen.ignore"`
		Cookie_name                     string
		Lb_port                         int64
		Load_balancer                   string
		Name                            string
	}

	Appautoscaling_policy struct {
		Appautoscaling_policy_id                     *string `lyra:"tf-gen.ignore"`
		Adjustment_type                              *string
		Alarms                                       *[]string
		Arn                                          *string
		Cooldown                                     *int64
		Metric_aggregation_type                      *string
		Min_adjustment_magnitude                     *int64
		Name                                         string
		Policy_type                                  string `puppet:"value=>'StepScaling'"`
		Resource_id                                  string
		Scalable_dimension                           string
		Service_namespace                            string
		Step_adjustment                              *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[metric_interval_lower_bound]=>String,Optional[metric_interval_upper_bound]=>String,scaling_adjustment=>Integer]]]"`
		Step_scaling_policy_configuration            *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[adjustment_type]=>String,Optional[cooldown]=>Integer,Optional[metric_aggregation_type]=>String,Optional[min_adjustment_magnitude]=>Integer,Optional[step_adjustment]=>Array[Struct[Optional[metric_interval_lower_bound]=>String,Optional[metric_interval_upper_bound]=>String,scaling_adjustment=>Integer]]]]]"`
		Target_tracking_scaling_policy_configuration *map[string]interface{}   `puppet:"type => Optional[Struct[Optional[customized_metric_specification]=>Struct[Optional[dimensions]=>Array[Struct[name=>String,value=>String]],metric_name=>String,namespace=>String,statistic=>String,Optional[unit]=>String],Optional[disable_scale_in]=>Boolean,Optional[predefined_metric_specification]=>Struct[predefined_metric_type=>String,Optional[resource_label]=>String],Optional[scale_in_cooldown]=>Integer,Optional[scale_out_cooldown]=>Integer,target_value=>Float]]"`
	}

	Appautoscaling_scheduled_action struct {
		Appautoscaling_scheduled_action_id *string `lyra:"tf-gen.ignore"`
		Arn                                *string
		End_time                           *string
		Name                               string
		Resource_id                        string
		Scalable_dimension                 *string
		Scalable_target_action             *map[string]int64 `puppet:"type => Optional[Struct[Optional[max_capacity]=>Integer,Optional[min_capacity]=>Integer]]"`
		Schedule                           *string
		Service_namespace                  string
		Start_time                         *string
	}

	Appautoscaling_target struct {
		Appautoscaling_target_id *string `lyra:"tf-gen.ignore"`
		Max_capacity             int64
		Min_capacity             int64
		Resource_id              string
		Role_arn                 *string
		Scalable_dimension       string
		Service_namespace        string
	}

	Appmesh_mesh struct {
		Appmesh_mesh_id   *string `lyra:"tf-gen.ignore"`
		Arn               *string
		Created_date      *string
		Last_updated_date *string
		Name              string
	}

	Appmesh_route struct {
		Appmesh_route_id    *string `lyra:"tf-gen.ignore"`
		Arn                 *string
		Created_date        *string
		Last_updated_date   *string
		Mesh_name           string
		Name                string
		Spec                map[string][]interface{} `puppet:"type => Struct[Optional[http_route]=>Struct[action=>Struct[weighted_target=>Array[Struct[virtual_node=>String,weight=>Integer],1]],match=>Struct[prefix=>String]]]"`
		Virtual_router_name string
	}

	Appmesh_virtual_node struct {
		Appmesh_virtual_node_id *string `lyra:"tf-gen.ignore"`
		Arn                     *string
		Created_date            *string
		Last_updated_date       *string
		Mesh_name               string
		Name                    string
		Spec                    map[string]interface{} `puppet:"type => Struct[Optional[backends]=>Array[String],Optional[listener]=>Struct[port_mapping=>Struct[port=>Integer,protocol=>String]],Optional[service_discovery]=>Struct[dns=>Struct[service_name=>String]]]"`
	}

	Appmesh_virtual_router struct {
		Appmesh_virtual_router_id *string `lyra:"tf-gen.ignore"`
		Arn                       *string
		Created_date              *string
		Last_updated_date         *string
		Mesh_name                 string
		Name                      string
		Spec                      map[string][]interface{} `puppet:"type => Struct[service_names=>Array[String,1,10]]"`
	}

	Appsync_api_key struct {
		Appsync_api_key_id *string `lyra:"tf-gen.ignore"`
		Api_id             string
		Description        string `puppet:"value=>'Managed by Terraform'"`
		Expires            *time.Time
		Key                *string
	}

	Appsync_datasource struct {
		Appsync_datasource_id *string `lyra:"tf-gen.ignore"`
		Api_id                string
		Arn                   *string
		Description           *string
		Dynamodb_config       *map[string]interface{} `puppet:"type => Optional[Struct[Optional[region]=>String,table_name=>String,Optional[use_caller_credentials]=>Boolean]]"`
		Elasticsearch_config  *map[string]string      `puppet:"type => Optional[Struct[endpoint=>String,Optional[region]=>String]]"`
		Http_config           *map[string]string      `puppet:"type => Optional[Struct[endpoint=>String]]"`
		Lambda_config         *map[string]string      `puppet:"type => Optional[Struct[function_arn=>String]]"`
		Name                  string
		Service_role_arn      *string
		Type                  string
	}

	Appsync_graphql_api struct {
		Appsync_graphql_api_id *string `lyra:"tf-gen.ignore"`
		Arn                    *string
		Authentication_type    string
		Log_config             *map[string]string `puppet:"type => Optional[Struct[cloudwatch_logs_role_arn=>String,field_log_level=>String]]"`
		Name                   string
		Openid_connect_config  *map[string]interface{} `puppet:"type => Optional[Struct[Optional[auth_ttl]=>Integer,Optional[client_id]=>String,Optional[iat_ttl]=>Integer,issuer=>String]]"`
		Uris                   *map[string]string
		User_pool_config       *map[string]string `puppet:"type => Optional[Struct[Optional[app_id_client_regex]=>String,Optional[aws_region]=>String,default_action=>String,user_pool_id=>String]]"`
	}

	Athena_database struct {
		Athena_database_id       *string `lyra:"tf-gen.ignore"`
		Bucket                   string
		Encryption_configuration *map[string]string `puppet:"type => Optional[Struct[encryption_option=>String,Optional[kms_key]=>String]]"`
		Force_destroy            bool               `puppet:"value=>false"`
		Name                     string
	}

	Athena_named_query struct {
		Athena_named_query_id *string `lyra:"tf-gen.ignore"`
		Database              string
		Description           *string
		Name                  string
		Query                 string
	}

	Autoscaling_attachment struct {
		Autoscaling_attachment_id *string `lyra:"tf-gen.ignore"`
		Alb_target_group_arn      *string
		Autoscaling_group_name    string
		Elb                       *string
	}

	Autoscaling_group struct {
		Autoscaling_group_id      *string `lyra:"tf-gen.ignore"`
		Arn                       *string
		Availability_zones        *[]string
		Default_cooldown          *int64
		Desired_capacity          *int64
		Enabled_metrics           *[]string
		Force_delete              bool  `puppet:"value=>false"`
		Health_check_grace_period int64 `puppet:"value=>300"`
		Health_check_type         *string
		Initial_lifecycle_hook    *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[default_result]=>String,Optional[heartbeat_timeout]=>Integer,lifecycle_transition=>String,name=>String,Optional[notification_metadata]=>String,Optional[notification_target_arn]=>String,Optional[role_arn]=>String]]]"`
		Launch_configuration      *string
		Launch_template           *map[string]string `puppet:"type => Optional[Struct[Optional[id]=>String,Optional[name]=>String,Optional[version]=>String]]"`
		Load_balancers            *[]string
		Max_size                  int64
		Metrics_granularity       string `puppet:"value=>'1Minute'"`
		Min_elb_capacity          *int64
		Min_size                  int64
		Mixed_instances_policy    *map[string][]interface{} `puppet:"type => Optional[Struct[Optional[instances_distribution]=>Struct[Optional[on_demand_allocation_strategy]=>String,Optional[on_demand_base_capacity]=>Integer,Optional[on_demand_percentage_above_base_capacity]=>Integer,Optional[spot_allocation_strategy]=>String,Optional[spot_instance_pools]=>Integer,Optional[spot_max_price]=>String],launch_template=>Struct[launch_template_specification=>Struct[Optional[launch_template_id]=>String,Optional[launch_template_name]=>String,Optional[version]=>String],Optional[override]=>Array[Struct[Optional[instance_type]=>String]]]]]"`
		Name                      *string
		Name_prefix               *string
		Placement_group           *string
		Protect_from_scale_in     bool `puppet:"value=>false"`
		Service_linked_role_arn   *string
		Suspended_processes       *[]string
		Tag                       *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[key=>String,propagate_at_launch=>Boolean,value=>String]]]"`
		Tags                      *[]map[string]string
		Target_group_arns         *[]string
		Termination_policies      *[]string
		Vpc_zone_identifier       *[]string
		Wait_for_capacity_timeout string `puppet:"value=>'10m'"`
		Wait_for_elb_capacity     *int64
	}

	Autoscaling_lifecycle_hook struct {
		Autoscaling_lifecycle_hook_id *string `lyra:"tf-gen.ignore"`
		Autoscaling_group_name        string
		Default_result                *string
		Heartbeat_timeout             *int64
		Lifecycle_transition          string
		Name                          string
		Notification_metadata         *string
		Notification_target_arn       *string
		Role_arn                      *string
	}

	Autoscaling_notification struct {
		Autoscaling_notification_id *string `lyra:"tf-gen.ignore"`
		Group_names                 []string
		Notifications               []string
		Topic_arn                   string
	}

	Autoscaling_policy struct {
		Autoscaling_policy_id         *string `lyra:"tf-gen.ignore"`
		Adjustment_type               *string
		Arn                           *string
		Autoscaling_group_name        string
		Cooldown                      *int64
		Estimated_instance_warmup     *int64
		Metric_aggregation_type       *string
		Min_adjustment_magnitude      *int64
		Min_adjustment_step           *int64
		Name                          string
		Policy_type                   string `puppet:"value=>'SimpleScaling'"`
		Scaling_adjustment            *int64
		Step_adjustment               *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[metric_interval_lower_bound]=>String,Optional[metric_interval_upper_bound]=>String,scaling_adjustment=>Integer]]]"`
		Target_tracking_configuration *map[string]interface{}   `puppet:"type => Optional[Struct[Optional[customized_metric_specification]=>Struct[Optional[metric_dimension]=>Array[Struct[name=>String,value=>String]],metric_name=>String,namespace=>String,statistic=>String,Optional[unit]=>String],Optional[disable_scale_in]=>Boolean,Optional[predefined_metric_specification]=>Struct[predefined_metric_type=>String,Optional[resource_label]=>String],target_value=>Float]]"`
	}

	Autoscaling_schedule struct {
		Autoscaling_schedule_id *string `lyra:"tf-gen.ignore"`
		Arn                     *string
		Autoscaling_group_name  string
		Desired_capacity        *int64
		End_time                *string
		Max_size                *int64
		Min_size                *int64
		Recurrence              *string
		Scheduled_action_name   string
		Start_time              *string
	}

	Batch_compute_environment struct {
		Batch_compute_environment_id *string `lyra:"tf-gen.ignore"`
		Arn                          *string
		Compute_environment_name     string
		Compute_resources            *map[string]interface{} `puppet:"type => Optional[Struct[Optional[bid_percentage]=>Integer,Optional[desired_vcpus]=>Integer,Optional[ec2_key_pair]=>String,Optional[image_id]=>String,instance_role=>String,instance_type=>Array[String],max_vcpus=>Integer,min_vcpus=>Integer,security_group_ids=>Array[String],Optional[spot_iam_fleet_role]=>String,subnets=>Array[String],Optional[tags]=>Hash[String,String],type=>String]]"`
		Ecc_cluster_arn              *string
		Ecs_cluster_arn              *string
		Service_role                 string
		State                        string `puppet:"value=>'ENABLED'"`
		Status                       *string
		Status_reason                *string
		Type                         string
	}

	Batch_job_definition struct {
		Batch_job_definition_id *string `lyra:"tf-gen.ignore"`
		Arn                     *string
		Container_properties    *string
		Name                    string
		Parameters              *map[string]string
		Retry_strategy          *map[string]int64 `puppet:"type => Optional[Struct[Optional[attempts]=>Integer]]"`
		Revision                *int64
		Timeout                 *map[string]int64 `puppet:"type => Optional[Struct[Optional[attempt_duration_seconds]=>Integer]]"`
		Type                    string
	}

	Batch_job_queue struct {
		Batch_job_queue_id   *string `lyra:"tf-gen.ignore"`
		Arn                  *string
		Compute_environments []string
		Name                 string
		Priority             int64
		State                string
	}

	Budgets_budget struct {
		Budgets_budget_id *string `lyra:"tf-gen.ignore"`
		Account_id        *string
		Budget_type       string
		Cost_filters      *map[string]string
		Cost_types        *map[string]bool `puppet:"type => Optional[Struct[Optional[include_credit]=>Boolean,Optional[include_discount]=>Boolean,Optional[include_other_subscription]=>Boolean,Optional[include_recurring]=>Boolean,Optional[include_refund]=>Boolean,Optional[include_subscription]=>Boolean,Optional[include_support]=>Boolean,Optional[include_tax]=>Boolean,Optional[include_upfront]=>Boolean,Optional[use_amortized]=>Boolean,Optional[use_blended]=>Boolean]]"`
		Limit_amount      string
		Limit_unit        string
		Name              *string
		Name_prefix       *string
		Time_period_end   string `puppet:"value=>'2087-06-15_00:00'"`
		Time_period_start string
		Time_unit         string
	}

	Cloud9_environment_ec2 struct {
		Cloud9_environment_ec2_id   *string `lyra:"tf-gen.ignore"`
		Arn                         *string
		Automatic_stop_time_minutes *int64
		Description                 *string
		Instance_type               string
		Name                        string
		Owner_arn                   *string
		Subnet_id                   *string
		Type                        *string
	}

	Cloudformation_stack struct {
		Cloudformation_stack_id *string `lyra:"tf-gen.ignore"`
		Capabilities            *[]string
		Disable_rollback        *bool
		Iam_role_arn            *string
		Name                    string
		Notification_arns       *[]string
		On_failure              *string
		Outputs                 *map[string]string
		Parameters              *map[string]string
		Policy_body             *string
		Policy_url              *string
		Tags                    *map[string]string
		Template_body           *string
		Template_url            *string
		Timeout_in_minutes      *int64
	}

	Cloudfront_distribution struct {
		Cloudfront_distribution_id     *string `lyra:"tf-gen.ignore"`
		Active_trusted_signers         *map[string]string
		Aliases                        *[]string
		Arn                            *string
		Cache_behavior                 *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[allowed_methods=>Array[String],cached_methods=>Array[String],Optional[compress]=>Boolean,Optional[default_ttl]=>Integer,Optional[field_level_encryption_id]=>String,forwarded_values=>Struct[cookies=>Struct[forward=>String,Optional[whitelisted_names]=>Array[String]],Optional[headers]=>Array[String],query_string=>Boolean,Optional[query_string_cache_keys]=>Array[String]],Optional[lambda_function_association]=>Array[Struct[event_type=>String,Optional[include_body]=>Boolean,lambda_arn=>String],0,4],Optional[max_ttl]=>Integer,Optional[min_ttl]=>Integer,path_pattern=>String,Optional[smooth_streaming]=>Boolean,target_origin_id=>String,Optional[trusted_signers]=>Array[String],viewer_protocol_policy=>String]]]"`
		Caller_reference               *string
		Comment                        *string
		Custom_error_response          *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[error_caching_min_ttl]=>Integer,error_code=>Integer,Optional[response_code]=>Integer,Optional[response_page_path]=>String]]]"`
		Default_cache_behavior         *map[string]interface{}   `puppet:"type => Optional[Struct[allowed_methods=>Array[String],cached_methods=>Array[String],Optional[compress]=>Boolean,Optional[default_ttl]=>Integer,Optional[field_level_encryption_id]=>String,forwarded_values=>Struct[cookies=>Struct[forward=>String,Optional[whitelisted_names]=>Array[String]],Optional[headers]=>Array[String],query_string=>Boolean,Optional[query_string_cache_keys]=>Array[String]],Optional[lambda_function_association]=>Array[Struct[event_type=>String,Optional[include_body]=>Boolean,lambda_arn=>String],0,4],Optional[max_ttl]=>Integer,Optional[min_ttl]=>Integer,Optional[smooth_streaming]=>Boolean,target_origin_id=>String,Optional[trusted_signers]=>Array[String],viewer_protocol_policy=>String]]"`
		Default_root_object            *string
		Domain_name                    *string
		Enabled                        bool
		Etag                           *string
		Hosted_zone_id                 *string
		Http_version                   string `puppet:"value=>'http2'"`
		In_progress_validation_batches *int64
		Is_ipv6_enabled                bool `puppet:"value=>false"`
		Last_modified_time             *string
		Logging_config                 *map[string]interface{}   `puppet:"type => Optional[Struct[bucket=>String,Optional[include_cookies]=>Boolean,Optional[prefix]=>String]]"`
		Ordered_cache_behavior         *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[allowed_methods=>Array[String],cached_methods=>Array[String],Optional[compress]=>Boolean,Optional[default_ttl]=>Integer,Optional[field_level_encryption_id]=>String,forwarded_values=>Struct[cookies=>Struct[forward=>String,Optional[whitelisted_names]=>Array[String]],Optional[headers]=>Array[String],query_string=>Boolean,Optional[query_string_cache_keys]=>Array[String]],Optional[lambda_function_association]=>Array[Struct[event_type=>String,Optional[include_body]=>Boolean,lambda_arn=>String],0,4],Optional[max_ttl]=>Integer,Optional[min_ttl]=>Integer,path_pattern=>String,Optional[smooth_streaming]=>Boolean,target_origin_id=>String,Optional[trusted_signers]=>Array[String],viewer_protocol_policy=>String]]]"`
		Origin                         []map[string]interface{}  `puppet:"type => Array[Struct[Optional[custom_header]=>Array[Struct[name=>String,value=>String]],Optional[custom_origin_config]=>Struct[http_port=>Integer,https_port=>Integer,Optional[origin_keepalive_timeout]=>Integer,origin_protocol_policy=>String,Optional[origin_read_timeout]=>Integer,origin_ssl_protocols=>Array[String]],domain_name=>String,origin_id=>String,Optional[origin_path]=>String,Optional[s3_origin_config]=>Struct[origin_access_identity=>String]]]"`
		Price_class                    string                    `puppet:"value=>'PriceClass_All'"`
		Restrictions                   *map[string][]interface{} `puppet:"type => Optional[Struct[geo_restriction=>Struct[Optional[locations]=>Array[String],restriction_type=>String]]]"`
		Retain_on_delete               bool                      `puppet:"value=>false"`
		Status                         *string
		Tags                           *map[string]string
		Viewer_certificate             *map[string]interface{} `puppet:"type => Optional[Struct[Optional[acm_certificate_arn]=>String,Optional[cloudfront_default_certificate]=>Boolean,Optional[iam_certificate_id]=>String,Optional[minimum_protocol_version]=>String,Optional[ssl_support_method]=>String]]"`
		Web_acl_id                     *string
	}

	Cloudfront_origin_access_identity struct {
		Cloudfront_origin_access_identity_id *string `lyra:"tf-gen.ignore"`
		Caller_reference                     *string
		Cloudfront_access_identity_path      *string
		Comment                              string `puppet:"value=>''"`
		Etag                                 *string
		Iam_arn                              *string
		S3_canonical_user_id                 *string
	}

	Cloudfront_public_key struct {
		Cloudfront_public_key_id *string `lyra:"tf-gen.ignore"`
		Caller_reference         *string
		Comment                  *string
		Encoded_key              string
		Etag                     *string
		Name                     *string
		Name_prefix              *string
	}

	Cloudhsm_v2_cluster struct {
		Cloudhsm_v2_cluster_id   *string            `lyra:"tf-gen.ignore"`
		Cluster_certificates     *map[string]string `puppet:"type => Optional[Struct[Optional[aws_hardware_certificate]=>String,Optional[cluster_certificate]=>String,Optional[cluster_csr]=>String,Optional[hsm_certificate]=>String,Optional[manufacturer_hardware_certificate]=>String]]"`
		Cluster_id               *string
		Cluster_state            *string
		Hsm_type                 string
		Security_group_id        *string
		Source_backup_identifier *string
		Subnet_ids               []string
		Tags                     *map[string]string
		Vpc_id                   *string
	}

	Cloudhsm_v2_hsm struct {
		Cloudhsm_v2_hsm_id *string `lyra:"tf-gen.ignore"`
		Availability_zone  *string
		Cluster_id         string
		Hsm_eni_id         *string
		Hsm_id             *string
		Hsm_state          *string
		Ip_address         *string
		Subnet_id          *string
	}

	Cloudtrail struct {
		Cloudtrail_id                 *string `lyra:"tf-gen.ignore"`
		Arn                           *string
		Cloud_watch_logs_group_arn    *string
		Cloud_watch_logs_role_arn     *string
		Enable_log_file_validation    bool                      `puppet:"value=>false"`
		Enable_logging                bool                      `puppet:"value=>true"`
		Event_selector                *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[data_resource]=>Array[Struct[type=>String,values=>Array[String,0,250]]],Optional[include_management_events]=>Boolean,Optional[read_write_type]=>String],0,5]]"`
		Home_region                   *string
		Include_global_service_events bool `puppet:"value=>true"`
		Is_multi_region_trail         bool `puppet:"value=>false"`
		Is_organization_trail         bool `puppet:"value=>false"`
		Kms_key_id                    *string
		Name                          string
		S3_bucket_name                string
		S3_key_prefix                 *string
		Sns_topic_name                *string
		Tags                          *map[string]string
	}

	Cloudwatch_dashboard struct {
		Cloudwatch_dashboard_id *string `lyra:"tf-gen.ignore"`
		Dashboard_arn           *string
		Dashboard_body          string
		Dashboard_name          string
	}

	Cloudwatch_event_permission struct {
		Cloudwatch_event_permission_id *string            `lyra:"tf-gen.ignore"`
		Action                         string             `puppet:"value=>'events:PutEvents'"`
		Condition                      *map[string]string `puppet:"type => Optional[Struct[key=>String,type=>String,value=>String]]"`
		Principal                      string
		Statement_id                   string
	}

	Cloudwatch_event_rule struct {
		Cloudwatch_event_rule_id *string `lyra:"tf-gen.ignore"`
		Arn                      *string
		Description              *string
		Event_pattern            *string
		Is_enabled               bool `puppet:"value=>true"`
		Name                     *string
		Name_prefix              *string
		Role_arn                 *string
		Schedule_expression      *string
	}

	Cloudwatch_event_target struct {
		Cloudwatch_event_target_id *string `lyra:"tf-gen.ignore"`
		Arn                        string
		Batch_target               *map[string]interface{} `puppet:"type => Optional[Struct[Optional[array_size]=>Integer,Optional[job_attempts]=>Integer,job_definition=>String,job_name=>String]]"`
		Ecs_target                 *map[string]interface{} `puppet:"type => Optional[Struct[Optional[group]=>String,Optional[launch_type]=>String,Optional[network_configuration]=>Struct[Optional[assign_public_ip]=>Boolean,Optional[security_groups]=>Array[String],subnets=>Array[String]],Optional[platform_version]=>String,Optional[task_count]=>Integer,task_definition_arn=>String]]"`
		Input                      *string
		Input_path                 *string
		Input_transformer          *map[string]interface{} `puppet:"type => Optional[Struct[Optional[input_paths]=>Hash[String,String],input_template=>String]]"`
		Kinesis_target             *map[string]string      `puppet:"type => Optional[Struct[Optional[partition_key_path]=>String]]"`
		Role_arn                   *string
		Rule                       string
		Run_command_targets        *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[key=>String,values=>Array[String]],0,5]]"`
		Sqs_target                 *map[string]string        `puppet:"type => Optional[Struct[Optional[message_group_id]=>String]]"`
		Target_id                  *string
	}

	Cloudwatch_log_destination struct {
		Cloudwatch_log_destination_id *string `lyra:"tf-gen.ignore"`
		Arn                           *string
		Name                          string
		Role_arn                      string
		Target_arn                    string
	}

	Cloudwatch_log_destination_policy struct {
		Cloudwatch_log_destination_policy_id *string `lyra:"tf-gen.ignore"`
		Access_policy                        string
		Destination_name                     string
	}

	Cloudwatch_log_group struct {
		Cloudwatch_log_group_id *string `lyra:"tf-gen.ignore"`
		Arn                     *string
		Kms_key_id              *string
		Name                    *string
		Name_prefix             *string
		Retention_in_days       int64 `puppet:"value=>0"`
		Tags                    *map[string]string
	}

	Cloudwatch_log_metric_filter struct {
		Cloudwatch_log_metric_filter_id *string `lyra:"tf-gen.ignore"`
		Log_group_name                  string
		Metric_transformation           *map[string]string `puppet:"type => Optional[Struct[Optional[default_value]=>String,name=>String,namespace=>String,value=>String]]"`
		Name                            string
		Pattern                         string
	}

	Cloudwatch_log_resource_policy struct {
		Cloudwatch_log_resource_policy_id *string `lyra:"tf-gen.ignore"`
		Policy_document                   string
		Policy_name                       string
	}

	Cloudwatch_log_stream struct {
		Cloudwatch_log_stream_id *string `lyra:"tf-gen.ignore"`
		Arn                      *string
		Log_group_name           string
		Name                     string
	}

	Cloudwatch_log_subscription_filter struct {
		Cloudwatch_log_subscription_filter_id *string `lyra:"tf-gen.ignore"`
		Destination_arn                       string
		Distribution                          *string
		Filter_pattern                        string
		Log_group_name                        string
		Name                                  string
		Role_arn                              *string
	}

	Cloudwatch_metric_alarm struct {
		Cloudwatch_metric_alarm_id            *string `lyra:"tf-gen.ignore"`
		Actions_enabled                       bool    `puppet:"value=>true"`
		Alarm_actions                         *[]string
		Alarm_description                     *string
		Alarm_name                            string
		Arn                                   *string
		Comparison_operator                   string
		Datapoints_to_alarm                   *int64
		Dimensions                            *map[string]string
		Evaluate_low_sample_count_percentiles *string
		Evaluation_periods                    int64
		Extended_statistic                    *string
		Insufficient_data_actions             *[]string
		Metric_name                           string
		Namespace                             string
		Ok_actions                            *[]string
		Period                                int64
		Statistic                             *string
		Threshold                             float64
		Treat_missing_data                    string `puppet:"value=>'missing'"`
		Unit                                  *string
	}

	Codebuild_project struct {
		Codebuild_project_id *string `lyra:"tf-gen.ignore"`
		Arn                  *string
		Artifacts            *map[string]interface{} `puppet:"type => Optional[Struct[Optional[encryption_disabled]=>Boolean,Optional[location]=>String,Optional[name]=>String,Optional[namespace_type]=>String,Optional[packaging]=>String,Optional[path]=>String,type=>String]]"`
		Badge_enabled        bool                    `puppet:"value=>false"`
		Badge_url            *string
		Build_timeout        int64              `puppet:"value=>60"`
		Cache                *map[string]string `puppet:"type => Optional[Struct[Optional[location]=>String,Optional[type]=>String]]"`
		Description          *string
		Encryption_key       *string
		Environment          *map[string]interface{} `puppet:"type => Optional[Struct[Optional[certificate]=>String,compute_type=>String,Optional[environment_variable]=>Array[Struct[name=>String,Optional[type]=>String,value=>String]],image=>String,Optional[privileged_mode]=>Boolean,type=>String]]"`
		Name                 string
		Secondary_artifacts  *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[artifact_identifier=>String,Optional[encryption_disabled]=>Boolean,Optional[location]=>String,Optional[name]=>String,Optional[namespace_type]=>String,Optional[packaging]=>String,Optional[path]=>String,type=>String]]]"`
		Secondary_sources    *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[auth]=>Array[Struct[Optional[resource]=>String,type=>String]],Optional[buildspec]=>String,Optional[git_clone_depth]=>Integer,Optional[insecure_ssl]=>Boolean,Optional[location]=>String,Optional[report_build_status]=>Boolean,source_identifier=>String,type=>String]]]"`
		Service_role         string
		Source               *map[string]interface{} `puppet:"type => Optional[Struct[Optional[auth]=>Array[Struct[Optional[resource]=>String,type=>String]],Optional[buildspec]=>String,Optional[git_clone_depth]=>Integer,Optional[insecure_ssl]=>Boolean,Optional[location]=>String,Optional[report_build_status]=>Boolean,type=>String]]"`
		Tags                 *map[string]string
		Timeout              *int64
		Vpc_config           *map[string]interface{} `puppet:"type => Optional[Struct[security_group_ids=>Array[String,0,5],subnets=>Array[String,0,16],vpc_id=>String]]"`
	}

	Codebuild_webhook struct {
		Codebuild_webhook_id *string `lyra:"tf-gen.ignore"`
		Branch_filter        *string
		Payload_url          *string
		Project_name         string
		Secret               *string
		Url                  *string
	}

	Codecommit_repository struct {
		Codecommit_repository_id *string `lyra:"tf-gen.ignore"`
		Arn                      *string
		Clone_url_http           *string
		Clone_url_ssh            *string
		Default_branch           *string
		Description              *string
		Repository_id            *string
		Repository_name          string
	}

	Codecommit_trigger struct {
		Codecommit_trigger_id *string `lyra:"tf-gen.ignore"`
		Configuration_id      *string
		Repository_name       string
		Trigger               []map[string]interface{} `puppet:"type => Array[Struct[Optional[branches]=>Array[String],Optional[custom_data]=>String,destination_arn=>String,events=>Array[String],name=>String],0,10]"`
	}

	Codedeploy_app struct {
		Codedeploy_app_id *string `lyra:"tf-gen.ignore"`
		Compute_platform  string  `puppet:"value=>'Server'"`
		Name              string
		Unique_id         *string
	}

	Codedeploy_deployment_config struct {
		Codedeploy_deployment_config_id *string `lyra:"tf-gen.ignore"`
		Compute_platform                string  `puppet:"value=>'Server'"`
		Deployment_config_id            *string
		Deployment_config_name          string
		Minimum_healthy_hosts           *map[string]interface{} `puppet:"type => Optional[Struct[Optional[type]=>String,Optional[value]=>Integer]]"`
		Traffic_routing_config          *map[string]interface{} `puppet:"type => Optional[Struct[Optional[time_based_canary]=>Struct[Optional[interval]=>Integer,Optional[percentage]=>Integer],Optional[time_based_linear]=>Struct[Optional[interval]=>Integer,Optional[percentage]=>Integer],Optional[type]=>String]]"`
	}

	Codedeploy_deployment_group struct {
		Codedeploy_deployment_group_id  *string                 `lyra:"tf-gen.ignore"`
		Alarm_configuration             *map[string]interface{} `puppet:"type => Optional[Struct[Optional[alarms]=>Array[String,0,10],Optional[enabled]=>Boolean,Optional[ignore_poll_alarm_failure]=>Boolean]]"`
		App_name                        string
		Auto_rollback_configuration     *map[string]interface{} `puppet:"type => Optional[Struct[Optional[enabled]=>Boolean,Optional[events]=>Array[String]]]"`
		Autoscaling_groups              *[]string
		Blue_green_deployment_config    *map[string][]interface{} `puppet:"type => Optional[Struct[Optional[deployment_ready_option]=>Struct[Optional[action_on_timeout]=>String,Optional[wait_time_in_minutes]=>Integer],Optional[green_fleet_provisioning_option]=>Struct[Optional[action]=>String],Optional[terminate_blue_instances_on_deployment_success]=>Struct[Optional[action]=>String,Optional[termination_wait_time_in_minutes]=>Integer]]]"`
		Deployment_config_name          string                    `puppet:"value=>'CodeDeployDefault.OneAtATime'"`
		Deployment_group_name           string
		Deployment_style                *map[string]string          `puppet:"type => Optional[Struct[Optional[deployment_option]=>String,Optional[deployment_type]=>String]]"`
		Ec2_tag_filter                  *[]map[string]string        `puppet:"type => Optional[Array[Struct[Optional[key]=>String,Optional[type]=>String,Optional[value]=>String]]]"`
		Ec2_tag_set                     *[]map[string][]interface{} `puppet:"type => Optional[Array[Struct[Optional[ec2_tag_filter]=>Array[Struct[Optional[key]=>String,Optional[type]=>String,Optional[value]=>String]]]]]"`
		Ecs_service                     *map[string]string          `puppet:"type => Optional[Struct[cluster_name=>String,service_name=>String]]"`
		Load_balancer_info              *map[string]interface{}     `puppet:"type => Optional[Struct[Optional[elb_info]=>Array[Struct[Optional[name]=>String]],Optional[target_group_info]=>Array[Struct[Optional[name]=>String]],Optional[target_group_pair_info]=>Struct[prod_traffic_route=>Struct[listener_arns=>Array[String]],target_group=>Array[Struct[name=>String],1,2],Optional[test_traffic_route]=>Struct[listener_arns=>Array[String]]]]]"`
		On_premises_instance_tag_filter *[]map[string]string        `puppet:"type => Optional[Array[Struct[Optional[key]=>String,Optional[type]=>String,Optional[value]=>String]]]"`
		Service_role_arn                string
		Trigger_configuration           *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[trigger_events=>Array[String],trigger_name=>String,trigger_target_arn=>String]]]"`
	}

	Codepipeline struct {
		Codepipeline_id *string `lyra:"tf-gen.ignore"`
		Arn             *string
		Artifact_store  *map[string]interface{} `puppet:"type => Optional[Struct[Optional[encryption_key]=>Struct[id=>String,type=>String],location=>String,type=>String]]"`
		Name            string
		Role_arn        string
		Stage           []map[string]interface{} `puppet:"type => Array[Struct[action=>Array[Struct[category=>String,Optional[configuration]=>Hash[String,String],Optional[input_artifacts]=>Array[String],name=>String,Optional[output_artifacts]=>Array[String],owner=>String,provider=>String,Optional[role_arn]=>String,Optional[run_order]=>Integer,version=>String]],name=>String],2]"`
	}

	Codepipeline_webhook struct {
		Codepipeline_webhook_id      *string `lyra:"tf-gen.ignore"`
		Authentication               string
		Authentication_configuration *map[string]string  `puppet:"type => Optional[Struct[Optional[allowed_ip_range]=>String,Optional[secret_token]=>String]]"`
		Filter                       []map[string]string `puppet:"type => Array[Struct[json_path=>String,match_equals=>String],1]"`
		Name                         string
		Target_action                string
		Target_pipeline              string
		Url                          *string
	}

	Cognito_identity_pool struct {
		Cognito_identity_pool_id         *string `lyra:"tf-gen.ignore"`
		Allow_unauthenticated_identities bool    `puppet:"value=>false"`
		Arn                              *string
		Cognito_identity_providers       *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[client_id]=>String,Optional[provider_name]=>String,Optional[server_side_token_check]=>Boolean]]]"`
		Developer_provider_name          *string
		Identity_pool_name               string
		Openid_connect_provider_arns     *[]string
		Saml_provider_arns               *[]string
		Supported_login_providers        *map[string]string
	}

	Cognito_identity_pool_roles_attachment struct {
		Cognito_identity_pool_roles_attachment_id *string `lyra:"tf-gen.ignore"`
		Identity_pool_id                          string
		Role_mapping                              *[]map[string]interface{}    `puppet:"type => Optional[Array[Struct[Optional[ambiguous_role_resolution]=>String,identity_provider=>String,Optional[mapping_rule]=>Array[Struct[claim=>String,match_type=>String,role_arn=>String,value=>String],0,25],type=>String]]]"`
		Roles                                     map[string]map[string]string `puppet:"type => Hash[String,Struct[Optional[authenticated]=>String,Optional[unauthenticated]=>String]]"`
	}

	Cognito_identity_provider struct {
		Cognito_identity_provider_id *string `lyra:"tf-gen.ignore"`
		Attribute_mapping            *map[string]string
		Idp_identifiers              *[]string
		Provider_details             map[string]string
		Provider_name                string
		Provider_type                string
		User_pool_id                 string
	}

	Cognito_resource_server struct {
		Cognito_resource_server_id *string `lyra:"tf-gen.ignore"`
		Identifier                 string
		Name                       string
		Scope                      *[]map[string]string `puppet:"type => Optional[Array[Struct[scope_description=>String,scope_name=>String],0,25]]"`
		Scope_identifiers          *[]string
		User_pool_id               string
	}

	Cognito_user_group struct {
		Cognito_user_group_id *string `lyra:"tf-gen.ignore"`
		Description           *string
		Name                  string
		Precedence            *int64
		Role_arn              *string
		User_pool_id          string
	}

	Cognito_user_pool struct {
		Cognito_user_pool_id          *string                 `lyra:"tf-gen.ignore"`
		Admin_create_user_config      *map[string]interface{} `puppet:"type => Optional[Struct[Optional[allow_admin_create_user_only]=>Boolean,Optional[invite_message_template]=>Struct[Optional[email_message]=>String,Optional[email_subject]=>String,Optional[sms_message]=>String],Optional[unused_account_validity_days]=>Integer]]"`
		Alias_attributes              *[]string
		Arn                           *string
		Auto_verified_attributes      *[]string
		Creation_date                 *string
		Device_configuration          *map[string]bool   `puppet:"type => Optional[Struct[Optional[challenge_required_on_new_device]=>Boolean,Optional[device_only_remembered_on_user_prompt]=>Boolean]]"`
		Email_configuration           *map[string]string `puppet:"type => Optional[Struct[Optional[reply_to_email_address]=>String,Optional[source_arn]=>String]]"`
		Email_verification_message    *string
		Email_verification_subject    *string
		Endpoint                      *string
		Lambda_config                 *map[string]string `puppet:"type => Optional[Struct[Optional[create_auth_challenge]=>String,Optional[custom_message]=>String,Optional[define_auth_challenge]=>String,Optional[post_authentication]=>String,Optional[post_confirmation]=>String,Optional[pre_authentication]=>String,Optional[pre_sign_up]=>String,Optional[pre_token_generation]=>String,Optional[user_migration]=>String,Optional[verify_auth_challenge_response]=>String]]"`
		Last_modified_date            *string
		Mfa_configuration             string `puppet:"value=>'OFF'"`
		Name                          string
		Password_policy               *map[string]interface{}   `puppet:"type => Optional[Struct[Optional[minimum_length]=>Integer,Optional[require_lowercase]=>Boolean,Optional[require_numbers]=>Boolean,Optional[require_symbols]=>Boolean,Optional[require_uppercase]=>Boolean]]"`
		Schema                        *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[attribute_data_type=>String,Optional[developer_only_attribute]=>Boolean,Optional[mutable]=>Boolean,name=>String,Optional[number_attribute_constraints]=>Struct[Optional[max_value]=>String,Optional[min_value]=>String],Optional[required]=>Boolean,Optional[string_attribute_constraints]=>Struct[Optional[max_length]=>String,Optional[min_length]=>String]],1,50]]"`
		Sms_authentication_message    *string
		Sms_configuration             *map[string]string `puppet:"type => Optional[Struct[external_id=>String,sns_caller_arn=>String]]"`
		Sms_verification_message      *string
		Tags                          *map[string]string
		Username_attributes           *[]string
		Verification_message_template *map[string]string `puppet:"type => Optional[Struct[Optional[default_email_option]=>String,Optional[email_message]=>String,Optional[email_message_by_link]=>String,Optional[email_subject]=>String,Optional[email_subject_by_link]=>String,Optional[sms_message]=>String]]"`
	}

	Cognito_user_pool_client struct {
		Cognito_user_pool_client_id          *string `lyra:"tf-gen.ignore"`
		Allowed_oauth_flows                  *[]string
		Allowed_oauth_flows_user_pool_client *bool
		Allowed_oauth_scopes                 *[]string
		Callback_urls                        *[]string
		Client_secret                        *string
		Default_redirect_uri                 *string
		Explicit_auth_flows                  *[]string
		Generate_secret                      *bool
		Logout_urls                          *[]string
		Name                                 string
		Read_attributes                      *[]string
		Refresh_token_validity               int64 `puppet:"value=>30"`
		Supported_identity_providers         *[]string
		User_pool_id                         string
		Write_attributes                     *[]string
	}

	Cognito_user_pool_domain struct {
		Cognito_user_pool_domain_id *string `lyra:"tf-gen.ignore"`
		Aws_account_id              *string
		Certificate_arn             *string
		Cloudfront_distribution_arn *string
		Domain                      string
		S3_bucket                   *string
		User_pool_id                string
		Version                     *string
	}

	Config_aggregate_authorization struct {
		Config_aggregate_authorization_id *string `lyra:"tf-gen.ignore"`
		Account_id                        string
		Arn                               *string
		Region                            string
	}

	Config_config_rule struct {
		Config_config_rule_id       *string `lyra:"tf-gen.ignore"`
		Arn                         *string
		Description                 *string
		Input_parameters            *string
		Maximum_execution_frequency *string
		Name                        string
		Rule_id                     *string
		Scope                       *map[string]interface{} `puppet:"type => Optional[Struct[Optional[compliance_resource_id]=>String,Optional[compliance_resource_types]=>Array[String,0,100],Optional[tag_key]=>String,Optional[tag_value]=>String]]"`
		Source                      *map[string]interface{} `puppet:"type => Optional[Struct[owner=>String,Optional[source_detail]=>Array[Struct[Optional[event_source]=>String,Optional[maximum_execution_frequency]=>String,Optional[message_type]=>String],0,25],source_identifier=>String]]"`
	}

	Config_configuration_aggregator struct {
		Config_configuration_aggregator_id *string                 `lyra:"tf-gen.ignore"`
		Account_aggregation_source         *map[string]interface{} `puppet:"type => Optional[Struct[account_ids=>Array[String,1],Optional[all_regions]=>Boolean,Optional[regions]=>Array[String,1]]]"`
		Arn                                *string
		Name                               string
		Organization_aggregation_source    *map[string]interface{} `puppet:"type => Optional[Struct[Optional[all_regions]=>Boolean,Optional[regions]=>Array[String,1],role_arn=>String]]"`
	}

	Config_configuration_recorder struct {
		Config_configuration_recorder_id *string                 `lyra:"tf-gen.ignore"`
		Name                             string                  `puppet:"value=>'default'"`
		Recording_group                  *map[string]interface{} `puppet:"type => Optional[Struct[Optional[all_supported]=>Boolean,Optional[include_global_resource_types]=>Boolean,Optional[resource_types]=>Array[String]]]"`
		Role_arn                         string
	}

	Config_configuration_recorder_status struct {
		Config_configuration_recorder_status_id *string `lyra:"tf-gen.ignore"`
		Is_enabled                              bool
		Name                                    string
	}

	Config_delivery_channel struct {
		Config_delivery_channel_id   *string `lyra:"tf-gen.ignore"`
		Name                         string  `puppet:"value=>'default'"`
		S3_bucket_name               string
		S3_key_prefix                *string
		Snapshot_delivery_properties *map[string]string `puppet:"type => Optional[Struct[Optional[delivery_frequency]=>String]]"`
		Sns_topic_arn                *string
	}

	Customer_gateway struct {
		Customer_gateway_id *string `lyra:"tf-gen.ignore"`
		Bgp_asn             int64
		Ip_address          string
		Tags                *map[string]string
		Type                string
	}

	Datasync_agent struct {
		Datasync_agent_id *string `lyra:"tf-gen.ignore"`
		Activation_key    *string
		Arn               *string
		Ip_address        *string
		Name              *string
		Tags              *map[string]string
	}

	Datasync_location_efs struct {
		Datasync_location_efs_id *string `lyra:"tf-gen.ignore"`
		Arn                      *string
		Ec2_config               *map[string]interface{} `puppet:"type => Optional[Struct[security_group_arns=>Array[String],subnet_arn=>String]]"`
		Efs_file_system_arn      string
		Subdirectory             string `puppet:"value=>'/'"`
		Tags                     *map[string]string
		Uri                      *string
	}

	Datasync_location_nfs struct {
		Datasync_location_nfs_id *string `lyra:"tf-gen.ignore"`
		Arn                      *string
		On_prem_config           *map[string][]interface{} `puppet:"type => Optional[Struct[agent_arns=>Array[String]]]"`
		Server_hostname          string
		Subdirectory             string
		Tags                     *map[string]string
		Uri                      *string
	}

	Datasync_location_s3 struct {
		Datasync_location_s3_id *string `lyra:"tf-gen.ignore"`
		Arn                     *string
		S3_bucket_arn           string
		S3_config               *map[string]string `puppet:"type => Optional[Struct[bucket_access_role_arn=>String]]"`
		Subdirectory            string
		Tags                    *map[string]string
		Uri                     *string
	}

	Datasync_task struct {
		Datasync_task_id         *string `lyra:"tf-gen.ignore"`
		Arn                      *string
		Cloudwatch_log_group_arn *string
		Destination_location_arn string
		Name                     *string
		Options                  *map[string]interface{} `puppet:"type => Optional[Struct[Optional[atime]=>String,Optional[bytes_per_second]=>Integer,Optional[gid]=>String,Optional[mtime]=>String,Optional[posix_permissions]=>String,Optional[preserve_deleted_files]=>String,Optional[preserve_devices]=>String,Optional[uid]=>String,Optional[verify_mode]=>String]]"`
		Source_location_arn      string
		Tags                     *map[string]string
	}

	Dax_cluster struct {
		Dax_cluster_id         *string `lyra:"tf-gen.ignore"`
		Arn                    *string
		Availability_zones     *[]string
		Cluster_address        *string
		Cluster_name           string
		Configuration_endpoint *string
		Description            *string
		Iam_role_arn           string
		Maintenance_window     *string
		Node_type              string
		Nodes                  *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[address]=>String,Optional[availability_zone]=>String,Optional[id]=>String,Optional[port]=>Integer]]]"`
		Notification_topic_arn *string
		Parameter_group_name   *string
		Port                   *int64
		Replication_factor     int64
		Security_group_ids     *[]string
		Server_side_encryption *map[string]bool `puppet:"type => Optional[Struct[Optional[enabled]=>Boolean]]"`
		Subnet_group_name      *string
		Tags                   *map[string]string
	}

	Dax_parameter_group struct {
		Dax_parameter_group_id *string `lyra:"tf-gen.ignore"`
		Description            *string
		Name                   string
		Parameters             *[]map[string]string `puppet:"type => Optional[Array[Struct[name=>String,value=>String]]]"`
	}

	Dax_subnet_group struct {
		Dax_subnet_group_id *string `lyra:"tf-gen.ignore"`
		Description         *string
		Name                string
		Subnet_ids          []string
		Vpc_id              *string
	}

	Db_cluster_snapshot struct {
		Db_cluster_snapshot_id         *string `lyra:"tf-gen.ignore"`
		Allocated_storage              *int64
		Availability_zones             *[]string
		Db_cluster_identifier          string
		Db_cluster_snapshot_arn        *string
		Db_cluster_snapshot_identifier string
		Engine                         *string
		Engine_version                 *string
		Kms_key_id                     *string
		License_model                  *string
		Port                           *int64
		Snapshot_type                  *string
		Source_db_cluster_snapshot_arn *string
		Status                         *string
		Storage_encrypted              *bool
		Vpc_id                         *string
	}

	Db_event_subscription struct {
		Db_event_subscription_id *string `lyra:"tf-gen.ignore"`
		Arn                      *string
		Customer_aws_id          *string
		Enabled                  bool `puppet:"value=>true"`
		Event_categories         *[]string
		Name                     *string
		Name_prefix              *string
		Sns_topic                string
		Source_ids               *[]string
		Source_type              *string
		Tags                     *map[string]string
	}

	Db_instance struct {
		Db_instance_id                      *string `lyra:"tf-gen.ignore"`
		Address                             *string
		Allocated_storage                   *int64
		Allow_major_version_upgrade         *bool
		Apply_immediately                   *bool
		Arn                                 *string
		Auto_minor_version_upgrade          bool `puppet:"value=>true"`
		Availability_zone                   *string
		Backup_retention_period             *int64
		Backup_window                       *string
		Ca_cert_identifier                  *string
		Character_set_name                  *string
		Copy_tags_to_snapshot               bool `puppet:"value=>false"`
		Db_subnet_group_name                *string
		Deletion_protection                 *bool
		Domain                              *string
		Domain_iam_role_name                *string
		Enabled_cloudwatch_logs_exports     *[]string
		Endpoint                            *string
		Engine                              *string
		Engine_version                      *string
		Final_snapshot_identifier           *string
		Hosted_zone_id                      *string
		Iam_database_authentication_enabled *bool
		Identifier                          *string
		Identifier_prefix                   *string
		Instance_class                      string
		Iops                                *int64
		Kms_key_id                          *string
		License_model                       *string
		Maintenance_window                  *string
		Monitoring_interval                 int64 `puppet:"value=>0"`
		Monitoring_role_arn                 *string
		Multi_az                            *bool
		Name                                *string
		Option_group_name                   *string
		Parameter_group_name                *string
		Password                            *string
		Port                                *int64
		Publicly_accessible                 bool `puppet:"value=>false"`
		Replicas                            *[]string
		Replicate_source_db                 *string
		Resource_id                         *string
		S3_import                           *map[string]string `puppet:"type => Optional[Struct[bucket_name=>String,Optional[bucket_prefix]=>String,ingestion_role=>String,source_engine=>String,source_engine_version=>String]]"`
		Security_group_names                *[]string
		Skip_final_snapshot                 bool `puppet:"value=>false"`
		Snapshot_identifier                 *string
		Status                              *string
		Storage_encrypted                   *bool
		Storage_type                        *string
		Tags                                *map[string]string
		Timezone                            *string
		Username                            *string
		Vpc_security_group_ids              *[]string
	}

	Db_option_group struct {
		Db_option_group_id       *string `lyra:"tf-gen.ignore"`
		Arn                      *string
		Engine_name              string
		Major_engine_version     string
		Name                     *string
		Name_prefix              *string
		Option                   *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[db_security_group_memberships]=>Array[String],option_name=>String,Optional[option_settings]=>Array[Struct[name=>String,value=>String]],Optional[port]=>Integer,Optional[version]=>String,Optional[vpc_security_group_memberships]=>Array[String]]]]"`
		Option_group_description string                    `puppet:"value=>'Managed by Terraform'"`
		Tags                     *map[string]string
	}

	Db_parameter_group struct {
		Db_parameter_group_id *string `lyra:"tf-gen.ignore"`
		Arn                   *string
		Description           string `puppet:"value=>'Managed by Terraform'"`
		Family                string
		Name                  *string
		Name_prefix           *string
		Parameter             *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[apply_method]=>String,name=>String,value=>String]]]"`
		Tags                  *map[string]string
	}

	Db_security_group struct {
		Db_security_group_id *string `lyra:"tf-gen.ignore"`
		Arn                  *string
		Description          string              `puppet:"value=>'Managed by Terraform'"`
		Ingress              []map[string]string `puppet:"type => Array[Struct[Optional[cidr]=>String,Optional[security_group_id]=>String,Optional[security_group_name]=>String,Optional[security_group_owner_id]=>String]]"`
		Name                 string
		Tags                 *map[string]string
	}

	Db_snapshot struct {
		Db_snapshot_id                *string `lyra:"tf-gen.ignore"`
		Allocated_storage             *int64
		Availability_zone             *string
		Db_instance_identifier        string
		Db_snapshot_arn               *string
		Db_snapshot_identifier        string
		Encrypted                     *bool
		Engine                        *string
		Engine_version                *string
		Iops                          *int64
		Kms_key_id                    *string
		License_model                 *string
		Option_group_name             *string
		Port                          *int64
		Snapshot_type                 *string
		Source_db_snapshot_identifier *string
		Source_region                 *string
		Status                        *string
		Storage_type                  *string
		Tags                          *map[string]string
		Vpc_id                        *string
	}

	Db_subnet_group struct {
		Db_subnet_group_id *string `lyra:"tf-gen.ignore"`
		Arn                *string
		Description        string `puppet:"value=>'Managed by Terraform'"`
		Name               *string
		Name_prefix        *string
		Subnet_ids         []string
		Tags               *map[string]string
	}

	Default_network_acl struct {
		Default_network_acl_lyra_id *string `lyra:"tf-gen.ignore"`
		Default_network_acl_id      string
		Egress                      *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[action=>String,Optional[cidr_block]=>String,from_port=>Integer,Optional[icmp_code]=>Integer,Optional[icmp_type]=>Integer,Optional[ipv6_cidr_block]=>String,protocol=>String,rule_no=>Integer,to_port=>Integer]]]"`
		Ingress                     *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[action=>String,Optional[cidr_block]=>String,from_port=>Integer,Optional[icmp_code]=>Integer,Optional[icmp_type]=>Integer,Optional[ipv6_cidr_block]=>String,protocol=>String,rule_no=>Integer,to_port=>Integer]]]"`
		Owner_id                    *string
		Subnet_ids                  *[]string
		Tags                        *map[string]string
		Vpc_id                      *string
	}

	Default_route_table struct {
		Default_route_table_lyra_id *string `lyra:"tf-gen.ignore"`
		Default_route_table_id      string
		Owner_id                    *string
		Propagating_vgws            *[]string
		Route                       *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[cidr_block]=>String,Optional[egress_only_gateway_id]=>String,Optional[gateway_id]=>String,Optional[instance_id]=>String,Optional[ipv6_cidr_block]=>String,Optional[nat_gateway_id]=>String,Optional[network_interface_id]=>String,Optional[transit_gateway_id]=>String,Optional[vpc_peering_connection_id]=>String]]]"`
		Tags                        *map[string]string
		Vpc_id                      *string
	}

	Default_security_group struct {
		Default_security_group_id *string `lyra:"tf-gen.ignore"`
		Arn                       *string
		Egress                    *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[cidr_blocks]=>Array[String],Optional[description]=>String,from_port=>Integer,Optional[ipv6_cidr_blocks]=>Array[String],Optional[prefix_list_ids]=>Array[String],protocol=>String,Optional[security_groups]=>Array[String],Optional[self]=>Boolean,to_port=>Integer]]]"`
		Ingress                   *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[cidr_blocks]=>Array[String],Optional[description]=>String,from_port=>Integer,Optional[ipv6_cidr_blocks]=>Array[String],Optional[prefix_list_ids]=>Array[String],protocol=>String,Optional[security_groups]=>Array[String],Optional[self]=>Boolean,to_port=>Integer]]]"`
		Name                      *string
		Owner_id                  *string
		Revoke_rules_on_delete    bool `puppet:"value=>false"`
		Tags                      *map[string]string
		Vpc_id                    *string
	}

	Default_subnet struct {
		Default_subnet_id               *string `lyra:"tf-gen.ignore"`
		Arn                             *string
		Assign_ipv6_address_on_creation *bool
		Availability_zone               string
		Availability_zone_id            *string
		Cidr_block                      *string
		Ipv6_cidr_block                 *string
		Ipv6_cidr_block_association_id  *string
		Map_public_ip_on_launch         *bool
		Owner_id                        *string
		Tags                            *map[string]string
		Vpc_id                          *string
	}

	Default_vpc struct {
		Default_vpc_id                   *string `lyra:"tf-gen.ignore"`
		Arn                              *string
		Assign_generated_ipv6_cidr_block *bool
		Cidr_block                       *string
		Default_network_acl_id           *string
		Default_route_table_id           *string
		Default_security_group_id        *string
		Dhcp_options_id                  *string
		Enable_classiclink               *bool
		Enable_classiclink_dns_support   *bool
		Enable_dns_hostnames             *bool
		Enable_dns_support               bool `puppet:"value=>true"`
		Instance_tenancy                 *string
		Ipv6_association_id              *string
		Ipv6_cidr_block                  *string
		Main_route_table_id              *string
		Owner_id                         *string
		Tags                             *map[string]string
	}

	Default_vpc_dhcp_options struct {
		Default_vpc_dhcp_options_id *string `lyra:"tf-gen.ignore"`
		Domain_name                 *string
		Domain_name_servers         *string
		Netbios_name_servers        *[]string
		Netbios_node_type           *string
		Ntp_servers                 *string
		Owner_id                    *string
		Tags                        *map[string]string
	}

	Devicefarm_project struct {
		Devicefarm_project_id *string `lyra:"tf-gen.ignore"`
		Arn                   *string
		Name                  string
	}

	Directory_service_conditional_forwarder struct {
		Directory_service_conditional_forwarder_id *string `lyra:"tf-gen.ignore"`
		Directory_id                               string
		Dns_ips                                    []string
		Remote_domain_name                         string
	}

	Directory_service_directory struct {
		Directory_service_directory_id *string `lyra:"tf-gen.ignore"`
		Access_url                     *string
		Alias                          *string
		Connect_settings               *map[string]interface{} `puppet:"type => Optional[Struct[customer_dns_ips=>Array[String],customer_username=>String,subnet_ids=>Array[String],vpc_id=>String]]"`
		Description                    *string
		Dns_ip_addresses               *[]string
		Edition                        *string
		Enable_sso                     bool `puppet:"value=>false"`
		Name                           string
		Password                       string
		Security_group_id              *string
		Short_name                     *string
		Size                           *string
		Tags                           *map[string]string
		Type                           string                  `puppet:"value=>'SimpleAD'"`
		Vpc_settings                   *map[string]interface{} `puppet:"type => Optional[Struct[subnet_ids=>Array[String],vpc_id=>String]]"`
	}

	Dlm_lifecycle_policy struct {
		Dlm_lifecycle_policy_id *string `lyra:"tf-gen.ignore"`
		Description             string
		Execution_role_arn      string
		Policy_details          *map[string]interface{} `puppet:"type => Optional[Struct[resource_types=>Array[String],schedule=>Array[Struct[Optional[copy_tags]=>Boolean,create_rule=>Struct[interval=>Integer,Optional[interval_unit]=>String,Optional[times]=>Array[String,0,1]],name=>String,retain_rule=>Struct[count=>Integer],Optional[tags_to_add]=>Hash[String,String]]],target_tags=>Hash[String,String]]]"`
		State                   string                  `puppet:"value=>'ENABLED'"`
	}

	Dms_certificate struct {
		Dms_certificate_id *string `lyra:"tf-gen.ignore"`
		Certificate_arn    *string
		Certificate_id     string
		Certificate_pem    *string
		Certificate_wallet *string
	}

	Dms_endpoint struct {
		Dms_endpoint_id             *string `lyra:"tf-gen.ignore"`
		Certificate_arn             *string
		Database_name               *string
		Endpoint_arn                *string
		Endpoint_id                 string
		Endpoint_type               string
		Engine_name                 string
		Extra_connection_attributes *string
		Kms_key_arn                 *string
		Mongodb_settings            *map[string]string `puppet:"type => Optional[Struct[Optional[auth_mechanism]=>String,Optional[auth_source]=>String,Optional[auth_type]=>String,Optional[docs_to_investigate]=>String,Optional[extract_doc_id]=>String,Optional[nesting_level]=>String]]"`
		Password                    *string
		Port                        *int64
		S3_settings                 *map[string]string `puppet:"type => Optional[Struct[Optional[bucket_folder]=>String,Optional[bucket_name]=>String,Optional[compression_type]=>String,Optional[csv_delimiter]=>String,Optional[csv_row_delimiter]=>String,Optional[external_table_definition]=>String,Optional[service_access_role_arn]=>String]]"`
		Server_name                 *string
		Service_access_role         *string
		Ssl_mode                    *string
		Tags                        *map[string]string
		Username                    *string
	}

	Dms_replication_instance struct {
		Dms_replication_instance_id      *string `lyra:"tf-gen.ignore"`
		Allocated_storage                *int64
		Apply_immediately                *bool
		Auto_minor_version_upgrade       *bool
		Availability_zone                *string
		Engine_version                   *string
		Kms_key_arn                      *string
		Multi_az                         *bool
		Preferred_maintenance_window     *string
		Publicly_accessible              *bool
		Replication_instance_arn         *string
		Replication_instance_class       string
		Replication_instance_id          string
		Replication_instance_private_ips *[]string
		Replication_instance_public_ips  *[]string
		Replication_subnet_group_id      *string
		Tags                             *map[string]string
		Vpc_security_group_ids           *[]string
	}

	Dms_replication_subnet_group struct {
		Dms_replication_subnet_group_id      *string `lyra:"tf-gen.ignore"`
		Replication_subnet_group_arn         *string
		Replication_subnet_group_description string
		Replication_subnet_group_id          string
		Subnet_ids                           []string
		Tags                                 *map[string]string
		Vpc_id                               *string
	}

	Dms_replication_task struct {
		Dms_replication_task_id   *string `lyra:"tf-gen.ignore"`
		Cdc_start_time            *string
		Migration_type            string
		Replication_instance_arn  string
		Replication_task_arn      *string
		Replication_task_id       string
		Replication_task_settings *string
		Source_endpoint_arn       string
		Table_mappings            string
		Tags                      *map[string]string
		Target_endpoint_arn       string
	}

	Docdb_cluster_parameter_group struct {
		Docdb_cluster_parameter_group_id *string `lyra:"tf-gen.ignore"`
		Arn                              *string
		Description                      string `puppet:"value=>'Managed by Terraform'"`
		Family                           string
		Name                             *string
		Name_prefix                      *string
		Parameter                        *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[apply_method]=>String,name=>String,value=>String]]]"`
		Tags                             *map[string]string
	}

	Docdb_subnet_group struct {
		Docdb_subnet_group_id *string `lyra:"tf-gen.ignore"`
		Arn                   *string
		Description           string `puppet:"value=>'Managed by Terraform'"`
		Name                  *string
		Name_prefix           *string
		Subnet_ids            []string
		Tags                  *map[string]string
	}

	Dx_bgp_peer struct {
		Dx_bgp_peer_id       *string `lyra:"tf-gen.ignore"`
		Address_family       string
		Amazon_address       *string
		Bgp_asn              int64
		Bgp_auth_key         *string
		Bgp_status           *string
		Customer_address     *string
		Virtual_interface_id string
	}

	Dx_connection struct {
		Dx_connection_id    *string `lyra:"tf-gen.ignore"`
		Arn                 *string
		Bandwidth           string
		Jumbo_frame_capable *bool
		Location            string
		Name                string
		Tags                *map[string]string
	}

	Dx_connection_association struct {
		Dx_connection_association_id *string `lyra:"tf-gen.ignore"`
		Connection_id                string
		Lag_id                       string
	}

	Dx_gateway struct {
		Dx_gateway_id   *string `lyra:"tf-gen.ignore"`
		Amazon_side_asn string
		Name            string
	}

	Dx_gateway_association struct {
		Dx_gateway_association_id *string `lyra:"tf-gen.ignore"`
		Dx_gateway_id             string
		Vpn_gateway_id            string
	}

	Dx_hosted_private_virtual_interface struct {
		Dx_hosted_private_virtual_interface_id *string `lyra:"tf-gen.ignore"`
		Address_family                         string
		Amazon_address                         *string
		Arn                                    *string
		Bgp_asn                                int64
		Bgp_auth_key                           *string
		Connection_id                          string
		Customer_address                       *string
		Jumbo_frame_capable                    *bool
		Mtu                                    int64 `puppet:"value=>1500"`
		Name                                   string
		Owner_account_id                       string
		Vlan                                   int64
	}

	Dx_hosted_private_virtual_interface_accepter struct {
		Dx_hosted_private_virtual_interface_accepter_id *string `lyra:"tf-gen.ignore"`
		Arn                                             *string
		Dx_gateway_id                                   *string
		Tags                                            *map[string]string
		Virtual_interface_id                            string
		Vpn_gateway_id                                  *string
	}

	Dx_hosted_public_virtual_interface struct {
		Dx_hosted_public_virtual_interface_id *string `lyra:"tf-gen.ignore"`
		Address_family                        string
		Amazon_address                        *string
		Arn                                   *string
		Bgp_asn                               int64
		Bgp_auth_key                          *string
		Connection_id                         string
		Customer_address                      *string
		Name                                  string
		Owner_account_id                      string
		Route_filter_prefixes                 []string
		Vlan                                  int64
	}

	Dx_hosted_public_virtual_interface_accepter struct {
		Dx_hosted_public_virtual_interface_accepter_id *string `lyra:"tf-gen.ignore"`
		Arn                                            *string
		Tags                                           *map[string]string
		Virtual_interface_id                           string
	}

	Dx_lag struct {
		Dx_lag_id             *string `lyra:"tf-gen.ignore"`
		Arn                   *string
		Connections_bandwidth string
		Force_destroy         bool `puppet:"value=>false"`
		Location              string
		Name                  string
		Number_of_connections *int64
		Tags                  *map[string]string
	}

	Dx_private_virtual_interface struct {
		Dx_private_virtual_interface_id *string `lyra:"tf-gen.ignore"`
		Address_family                  string
		Amazon_address                  *string
		Arn                             *string
		Bgp_asn                         int64
		Bgp_auth_key                    *string
		Connection_id                   string
		Customer_address                *string
		Dx_gateway_id                   *string
		Jumbo_frame_capable             *bool
		Mtu                             int64 `puppet:"value=>1500"`
		Name                            string
		Tags                            *map[string]string
		Vlan                            int64
		Vpn_gateway_id                  *string
	}

	Dx_public_virtual_interface struct {
		Dx_public_virtual_interface_id *string `lyra:"tf-gen.ignore"`
		Address_family                 string
		Amazon_address                 *string
		Arn                            *string
		Bgp_asn                        int64
		Bgp_auth_key                   *string
		Connection_id                  string
		Customer_address               *string
		Name                           string
		Route_filter_prefixes          []string
		Tags                           *map[string]string
		Vlan                           int64
	}

	Dynamodb_global_table struct {
		Dynamodb_global_table_id *string `lyra:"tf-gen.ignore"`
		Arn                      *string
		Name                     string
		Replica                  []map[string]string `puppet:"type => Array[Struct[region_name=>String]]"`
	}

	Dynamodb_table struct {
		Dynamodb_table_id      *string `lyra:"tf-gen.ignore"`
		Arn                    *string
		Attribute              []map[string]string       `puppet:"type => Array[Struct[name=>String,type=>String]]"`
		Billing_mode           string                    `puppet:"value=>'PROVISIONED'"`
		Global_secondary_index *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[hash_key=>String,name=>String,Optional[non_key_attributes]=>Array[String],projection_type=>String,Optional[range_key]=>String,Optional[read_capacity]=>Integer,Optional[write_capacity]=>Integer]]]"`
		Hash_key               string
		Local_secondary_index  *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[name=>String,Optional[non_key_attributes]=>Array[String],projection_type=>String,range_key=>String]]]"`
		Name                   string
		Point_in_time_recovery *map[string]bool `puppet:"type => Optional[Struct[enabled=>Boolean]]"`
		Range_key              *string
		Read_capacity          *int64
		Server_side_encryption *map[string]bool `puppet:"type => Optional[Struct[enabled=>Boolean]]"`
		Stream_arn             *string
		Stream_enabled         *bool
		Stream_label           *string
		Stream_view_type       *string
		Tags                   *map[string]string
		Ttl                    *map[string]interface{} `puppet:"type => Optional[Struct[attribute_name=>String,enabled=>Boolean]]"`
		Write_capacity         *int64
	}

	Dynamodb_table_item struct {
		Dynamodb_table_item_id *string `lyra:"tf-gen.ignore"`
		Hash_key               string
		Item                   string
		Range_key              *string
		Table_name             string
	}

	Ebs_snapshot struct {
		Ebs_snapshot_id        *string `lyra:"tf-gen.ignore"`
		Data_encryption_key_id *string
		Description            *string
		Encrypted              *bool
		Kms_key_id             *string
		Owner_alias            *string
		Owner_id               *string
		Tags                   *map[string]string
		Volume_id              string
		Volume_size            *int64
	}

	Ebs_snapshot_copy struct {
		Ebs_snapshot_copy_id   *string `lyra:"tf-gen.ignore"`
		Data_encryption_key_id *string
		Description            *string
		Encrypted              *bool
		Kms_key_id             *string
		Owner_alias            *string
		Owner_id               *string
		Source_region          string
		Source_snapshot_id     string
		Tags                   *map[string]string
		Volume_id              *string
		Volume_size            *int64
	}

	Ebs_volume struct {
		Ebs_volume_id     *string `lyra:"tf-gen.ignore"`
		Arn               *string
		Availability_zone string
		Encrypted         *bool
		Iops              *int64
		Kms_key_id        *string
		Size              *int64
		Snapshot_id       *string
		Tags              *map[string]string
		Type              *string
	}

	Ec2_capacity_reservation struct {
		Ec2_capacity_reservation_id *string `lyra:"tf-gen.ignore"`
		Availability_zone           string
		Ebs_optimized               bool `puppet:"value=>false"`
		End_date                    *time.Time
		End_date_type               string `puppet:"value=>'unlimited'"`
		Ephemeral_storage           bool   `puppet:"value=>false"`
		Instance_count              int64
		Instance_match_criteria     string `puppet:"value=>'open'"`
		Instance_platform           string
		Instance_type               string
		Tags                        *map[string]string
		Tenancy                     string `puppet:"value=>'default'"`
	}

	Ec2_fleet struct {
		Ec2_fleet_id                        *string                  `lyra:"tf-gen.ignore"`
		Excess_capacity_termination_policy  string                   `puppet:"value=>'termination'"`
		Launch_template_config              map[string][]interface{} `puppet:"type => Struct[launch_template_specification=>Struct[Optional[launch_template_id]=>String,Optional[launch_template_name]=>String,version=>String],Optional[override]=>Array[Struct[Optional[availability_zone]=>String,Optional[instance_type]=>String,Optional[max_price]=>String,Optional[priority]=>Float,Optional[subnet_id]=>String,Optional[weighted_capacity]=>Float],0,50]]"`
		On_demand_options                   *map[string]string       `puppet:"type => Optional[Struct[Optional[allocation_strategy]=>String]]"`
		Replace_unhealthy_instances         *bool
		Spot_options                        *map[string]interface{} `puppet:"type => Optional[Struct[Optional[allocation_strategy]=>String,Optional[instance_interruption_behavior]=>String,Optional[instance_pools_to_use_count]=>Integer]]"`
		Tags                                *map[string]string
		Target_capacity_specification       map[string]interface{} `puppet:"type => Struct[default_target_capacity_type=>String,Optional[on_demand_target_capacity]=>Integer,Optional[spot_target_capacity]=>Integer,total_target_capacity=>Integer]"`
		Terminate_instances                 bool                   `puppet:"value=>false"`
		Terminate_instances_with_expiration *bool
		Type                                string `puppet:"value=>'maintain'"`
	}

	Ec2_transit_gateway struct {
		Ec2_transit_gateway_id             *string `lyra:"tf-gen.ignore"`
		Amazon_side_asn                    int64   `puppet:"value=>64512"`
		Arn                                *string
		Association_default_route_table_id *string
		Auto_accept_shared_attachments     string `puppet:"value=>'disable'"`
		Default_route_table_association    string `puppet:"value=>'enable'"`
		Default_route_table_propagation    string `puppet:"value=>'enable'"`
		Description                        *string
		Dns_support                        string `puppet:"value=>'enable'"`
		Owner_id                           *string
		Propagation_default_route_table_id *string
		Tags                               *map[string]string
		Vpn_ecmp_support                   string `puppet:"value=>'enable'"`
	}

	Ec2_transit_gateway_route struct {
		Ec2_transit_gateway_route_id   *string `lyra:"tf-gen.ignore"`
		Destination_cidr_block         string
		Transit_gateway_attachment_id  string
		Transit_gateway_route_table_id string
	}

	Ec2_transit_gateway_route_table struct {
		Ec2_transit_gateway_route_table_id *string `lyra:"tf-gen.ignore"`
		Default_association_route_table    *bool
		Default_propagation_route_table    *bool
		Tags                               *map[string]string
		Transit_gateway_id                 string
	}

	Ec2_transit_gateway_route_table_association struct {
		Ec2_transit_gateway_route_table_association_id *string `lyra:"tf-gen.ignore"`
		Resource_id                                    *string
		Resource_type                                  *string
		Transit_gateway_attachment_id                  string
		Transit_gateway_route_table_id                 string
	}

	Ec2_transit_gateway_route_table_propagation struct {
		Ec2_transit_gateway_route_table_propagation_id *string `lyra:"tf-gen.ignore"`
		Resource_id                                    *string
		Resource_type                                  *string
		Transit_gateway_attachment_id                  string
		Transit_gateway_route_table_id                 string
	}

	Ec2_transit_gateway_vpc_attachment struct {
		Ec2_transit_gateway_vpc_attachment_id           *string `lyra:"tf-gen.ignore"`
		Dns_support                                     string  `puppet:"value=>'enable'"`
		Ipv6_support                                    string  `puppet:"value=>'disable'"`
		Subnet_ids                                      []string
		Tags                                            *map[string]string
		Transit_gateway_default_route_table_association bool `puppet:"value=>true"`
		Transit_gateway_default_route_table_propagation bool `puppet:"value=>true"`
		Transit_gateway_id                              string
		Vpc_id                                          string
		Vpc_owner_id                                    *string
	}

	Ecr_lifecycle_policy struct {
		Ecr_lifecycle_policy_id *string `lyra:"tf-gen.ignore"`
		Policy                  string
		Registry_id             *string
		Repository              string
	}

	Ecr_repository struct {
		Ecr_repository_id *string `lyra:"tf-gen.ignore"`
		Arn               *string
		Name              string
		Registry_id       *string
		Repository_url    *string
		Tags              *map[string]string
	}

	Ecr_repository_policy struct {
		Ecr_repository_policy_id *string `lyra:"tf-gen.ignore"`
		Policy                   string
		Registry_id              *string
		Repository               string
	}

	Ecs_cluster struct {
		Ecs_cluster_id *string `lyra:"tf-gen.ignore"`
		Arn            *string
		Name           string
		Tags           *map[string]string
	}

	Ecs_service struct {
		Ecs_service_id                     *string `lyra:"tf-gen.ignore"`
		Cluster                            *string
		Deployment_controller              *map[string]string `puppet:"type => Optional[Struct[Optional[type]=>String]]"`
		Deployment_maximum_percent         int64              `puppet:"value=>200"`
		Deployment_minimum_healthy_percent int64              `puppet:"value=>100"`
		Desired_count                      *int64
		Enable_ecs_managed_tags            bool `puppet:"value=>false"`
		Health_check_grace_period_seconds  *int64
		Iam_role                           *string
		Launch_type                        string                  `puppet:"value=>'EC2'"`
		Load_balancer                      *map[string]interface{} `puppet:"type => Optional[Struct[container_name=>String,container_port=>Integer,Optional[elb_name]=>String,Optional[target_group_arn]=>String]]"`
		Name                               string
		Network_configuration              *map[string]interface{} `puppet:"type => Optional[Struct[Optional[assign_public_ip]=>Boolean,Optional[security_groups]=>Array[String],subnets=>Array[String]]]"`
		Ordered_placement_strategy         *[]map[string]string    `puppet:"type => Optional[Array[Struct[Optional[field]=>String,type=>String],0,5]]"`
		Placement_constraints              *[]map[string]string    `puppet:"type => Optional[Array[Struct[Optional[expression]=>String,type=>String],0,10]]"`
		Placement_strategy                 *[]map[string]string    `puppet:"type => Optional[Array[Struct[Optional[field]=>String,type=>String],0,5]]"`
		Platform_version                   *string
		Propagate_tags                     *string
		Scheduling_strategy                string                  `puppet:"value=>'REPLICA'"`
		Service_registries                 *map[string]interface{} `puppet:"type => Optional[Struct[Optional[container_name]=>String,Optional[container_port]=>Integer,Optional[port]=>Integer,registry_arn=>String]]"`
		Tags                               *map[string]string
		Task_definition                    string
	}

	Ecs_task_definition struct {
		Ecs_task_definition_id   *string `lyra:"tf-gen.ignore"`
		Arn                      *string
		Container_definitions    string
		Cpu                      *string
		Execution_role_arn       *string
		Family                   string
		Ipc_mode                 *string
		Memory                   *string
		Network_mode             *string
		Pid_mode                 *string
		Placement_constraints    *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[expression]=>String,type=>String],0,10]]"`
		Requires_compatibilities *[]string
		Revision                 *int64
		Tags                     *map[string]string
		Task_role_arn            *string
		Volume                   *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[docker_volume_configuration]=>Struct[Optional[autoprovision]=>Boolean,Optional[driver]=>String,Optional[driver_opts]=>Hash[String,String],Optional[labels]=>Hash[String,String],Optional[scope]=>String],Optional[host_path]=>String,name=>String]]]"`
	}

	Efs_file_system struct {
		Efs_file_system_id              *string `lyra:"tf-gen.ignore"`
		Arn                             *string
		Creation_token                  *string
		Dns_name                        *string
		Encrypted                       *bool
		Kms_key_id                      *string
		Performance_mode                *string
		Provisioned_throughput_in_mibps *float64
		Reference_name                  *string
		Tags                            *map[string]string
		Throughput_mode                 string `puppet:"value=>'bursting'"`
	}

	Efs_mount_target struct {
		Efs_mount_target_id  *string `lyra:"tf-gen.ignore"`
		Dns_name             *string
		File_system_arn      *string
		File_system_id       string
		Ip_address           *string
		Network_interface_id *string
		Security_groups      *[]string
		Subnet_id            string
	}

	Egress_only_internet_gateway struct {
		Egress_only_internet_gateway_id *string `lyra:"tf-gen.ignore"`
		Vpc_id                          string
	}

	Eip struct {
		Eip_id                    *string `lyra:"tf-gen.ignore"`
		Allocation_id             *string
		Associate_with_private_ip *string
		Association_id            *string
		Domain                    *string
		Instance                  *string
		Network_interface         *string
		Private_ip                *string
		Public_ip                 *string
		Public_ipv4_pool          *string
		Tags                      *map[string]string
		Vpc                       *bool
	}

	Eip_association struct {
		Eip_association_id   *string `lyra:"tf-gen.ignore"`
		Allocation_id        *string
		Allow_reassociation  *bool
		Instance_id          *string
		Network_interface_id *string
		Private_ip_address   *string
		Public_ip            *string
	}

	Eks_cluster struct {
		Eks_cluster_id        *string `lyra:"tf-gen.ignore"`
		Arn                   *string
		Certificate_authority *map[string]string `puppet:"type => Optional[Struct[Optional[data]=>String]]"`
		Created_at            *string
		Endpoint              *string
		Name                  string
		Platform_version      *string
		Role_arn              string
		Version               *string
		Vpc_config            map[string]interface{} `puppet:"type => Struct[Optional[security_group_ids]=>Array[String],subnet_ids=>Array[String,1],Optional[vpc_id]=>String]"`
	}

	Elastic_beanstalk_application struct {
		Elastic_beanstalk_application_id *string                 `lyra:"tf-gen.ignore"`
		Appversion_lifecycle             *map[string]interface{} `puppet:"type => Optional[Struct[Optional[delete_source_from_s3]=>Boolean,Optional[max_age_in_days]=>Integer,Optional[max_count]=>Integer,service_role=>String]]"`
		Description                      *string
		Name                             string
	}

	Elastic_beanstalk_application_version struct {
		Elastic_beanstalk_application_version_id *string `lyra:"tf-gen.ignore"`
		Application                              string
		Bucket                                   string
		Description                              *string
		Force_delete                             bool `puppet:"value=>false"`
		Key                                      string
		Name                                     string
	}

	Elastic_beanstalk_configuration_template struct {
		Elastic_beanstalk_configuration_template_id *string `lyra:"tf-gen.ignore"`
		Application                                 string
		Description                                 *string
		Environment_id                              *string
		Name                                        string
		Setting                                     *[]map[string]string `puppet:"type => Optional[Array[Struct[name=>String,namespace=>String,Optional[resource]=>String,value=>String]]]"`
		Solution_stack_name                         *string
	}

	Elastic_beanstalk_environment struct {
		Elastic_beanstalk_environment_id *string              `lyra:"tf-gen.ignore"`
		All_settings                     *[]map[string]string `puppet:"type => Optional[Array[Struct[name=>String,namespace=>String,Optional[resource]=>String,value=>String]]]"`
		Application                      string
		Arn                              *string
		Autoscaling_groups               *[]string
		Cname                            *string
		Cname_prefix                     *string
		Description                      *string
		Instances                        *[]string
		Launch_configurations            *[]string
		Load_balancers                   *[]string
		Name                             string
		Platform_arn                     *string
		Poll_interval                    *string
		Queues                           *[]string
		Setting                          *[]map[string]string `puppet:"type => Optional[Array[Struct[name=>String,namespace=>String,Optional[resource]=>String,value=>String]]]"`
		Solution_stack_name              *string
		Tags                             *map[string]string
		Template_name                    *string
		Tier                             string `puppet:"value=>'WebServer'"`
		Triggers                         *[]string
		Version_label                    *string
		Wait_for_ready_timeout           string `puppet:"value=>'20m'"`
	}

	Elasticache_cluster struct {
		Elasticache_cluster_id       *string `lyra:"tf-gen.ignore"`
		Apply_immediately            *bool
		Availability_zone            *string
		Availability_zones           *[]string
		Az_mode                      *string
		Cache_nodes                  *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[address]=>String,Optional[availability_zone]=>String,Optional[id]=>String,Optional[port]=>Integer]]]"`
		Cluster_address              *string
		Cluster_id                   string
		Configuration_endpoint       *string
		Engine                       *string
		Engine_version               *string
		Maintenance_window           *string
		Node_type                    *string
		Notification_topic_arn       *string
		Num_cache_nodes              *int64
		Parameter_group_name         *string
		Port                         *int64
		Preferred_availability_zones *[]string
		Replication_group_id         *string
		Security_group_ids           *[]string
		Security_group_names         *[]string
		Snapshot_arns                *[]string
		Snapshot_name                *string
		Snapshot_retention_limit     *int64
		Snapshot_window              *string
		Subnet_group_name            *string
		Tags                         *map[string]string
	}

	Elasticache_parameter_group struct {
		Elasticache_parameter_group_id *string `lyra:"tf-gen.ignore"`
		Description                    string  `puppet:"value=>'Managed by Terraform'"`
		Family                         string
		Name                           string
		Parameter                      *[]map[string]string `puppet:"type => Optional[Array[Struct[name=>String,value=>String]]]"`
	}

	Elasticache_replication_group struct {
		Elasticache_replication_group_id *string `lyra:"tf-gen.ignore"`
		Apply_immediately                *bool
		At_rest_encryption_enabled       bool `puppet:"value=>false"`
		Auth_token                       *string
		Auto_minor_version_upgrade       bool `puppet:"value=>true"`
		Automatic_failover_enabled       bool `puppet:"value=>false"`
		Availability_zones               *[]string
		Cluster_mode                     *map[string]int64 `puppet:"type => Optional[Struct[num_node_groups=>Integer,replicas_per_node_group=>Integer]]"`
		Configuration_endpoint_address   *string
		Engine                           string `puppet:"value=>'redis'"`
		Engine_version                   *string
		Maintenance_window               *string
		Member_clusters                  *[]string
		Node_type                        *string
		Notification_topic_arn           *string
		Number_cache_clusters            *int64
		Parameter_group_name             *string
		Port                             *int64
		Primary_endpoint_address         *string
		Replication_group_description    string
		Replication_group_id             string
		Security_group_ids               *[]string
		Security_group_names             *[]string
		Snapshot_arns                    *[]string
		Snapshot_name                    *string
		Snapshot_retention_limit         *int64
		Snapshot_window                  *string
		Subnet_group_name                *string
		Tags                             *map[string]string
		Transit_encryption_enabled       bool `puppet:"value=>false"`
	}

	Elasticache_security_group struct {
		Elasticache_security_group_id *string `lyra:"tf-gen.ignore"`
		Description                   string  `puppet:"value=>'Managed by Terraform'"`
		Name                          string
		Security_group_names          []string
	}

	Elasticache_subnet_group struct {
		Elasticache_subnet_group_id *string `lyra:"tf-gen.ignore"`
		Description                 string  `puppet:"value=>'Managed by Terraform'"`
		Name                        string
		Subnet_ids                  []string
	}

	Elasticsearch_domain struct {
		Elasticsearch_domain_id *string `lyra:"tf-gen.ignore"`
		Access_policies         *string
		Advanced_options        *map[string]string
		Arn                     *string
		Cluster_config          *map[string]interface{} `puppet:"type => Optional[Struct[Optional[dedicated_master_count]=>Integer,Optional[dedicated_master_enabled]=>Boolean,Optional[dedicated_master_type]=>String,Optional[instance_count]=>Integer,Optional[instance_type]=>String,Optional[zone_awareness_enabled]=>Boolean]]"`
		Cognito_options         *map[string]interface{} `puppet:"type => Optional[Struct[Optional[enabled]=>Boolean,identity_pool_id=>String,role_arn=>String,user_pool_id=>String]]"`
		Domain_id               *string
		Domain_name             string
		Ebs_options             *map[string]interface{} `puppet:"type => Optional[Struct[ebs_enabled=>Boolean,Optional[iops]=>Integer,Optional[volume_size]=>Integer,Optional[volume_type]=>String]]"`
		Elasticsearch_version   string                  `puppet:"value=>'1.5'"`
		Encrypt_at_rest         *map[string]interface{} `puppet:"type => Optional[Struct[enabled=>Boolean,Optional[kms_key_id]=>String]]"`
		Endpoint                *string
		Kibana_endpoint         *string
		Log_publishing_options  *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[cloudwatch_log_group_arn=>String,Optional[enabled]=>Boolean,log_type=>String]]]"`
		Node_to_node_encryption *map[string]bool          `puppet:"type => Optional[Struct[enabled=>Boolean]]"`
		Snapshot_options        *map[string]int64         `puppet:"type => Optional[Struct[automated_snapshot_start_hour=>Integer]]"`
		Tags                    *map[string]string
		Vpc_options             *map[string]interface{} `puppet:"type => Optional[Struct[Optional[availability_zones]=>Array[String],Optional[security_group_ids]=>Array[String],Optional[subnet_ids]=>Array[String],Optional[vpc_id]=>String]]"`
	}

	Elasticsearch_domain_policy struct {
		Elasticsearch_domain_policy_id *string `lyra:"tf-gen.ignore"`
		Access_policies                string
		Domain_name                    string
	}

	Elastictranscoder_pipeline struct {
		Elastictranscoder_pipeline_id *string `lyra:"tf-gen.ignore"`
		Arn                           *string
		Aws_kms_key_arn               *string
		Content_config                *map[string]string        `puppet:"type => Optional[Struct[Optional[bucket]=>String,Optional[storage_class]=>String]]"`
		Content_config_permissions    *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[access]=>Array[String],Optional[grantee]=>String,Optional[grantee_type]=>String]]]"`
		Input_bucket                  string
		Name                          *string
		Notifications                 *map[string]string `puppet:"type => Optional[Struct[Optional[completed]=>String,Optional[error]=>String,Optional[progressing]=>String,Optional[warning]=>String]]"`
		Output_bucket                 *string
		Role                          string
		Thumbnail_config              *map[string]string        `puppet:"type => Optional[Struct[Optional[bucket]=>String,Optional[storage_class]=>String]]"`
		Thumbnail_config_permissions  *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[access]=>Array[String],Optional[grantee]=>String,Optional[grantee_type]=>String]]]"`
	}

	Elastictranscoder_preset struct {
		Elastictranscoder_preset_id *string `lyra:"tf-gen.ignore"`
		Arn                         *string
		Audio                       *map[string]string `puppet:"type => Optional[Struct[Optional[audio_packing_mode]=>String,Optional[bit_rate]=>String,Optional[channels]=>String,Optional[codec]=>String,Optional[sample_rate]=>String]]"`
		Audio_codec_options         *map[string]string `puppet:"type => Optional[Struct[Optional[bit_depth]=>String,Optional[bit_order]=>String,Optional[profile]=>String,Optional[signed]=>String]]"`
		Container                   string
		Description                 *string
		Name                        *string
		Thumbnails                  *map[string]string `puppet:"type => Optional[Struct[Optional[aspect_ratio]=>String,Optional[format]=>String,Optional[interval]=>String,Optional[max_height]=>String,Optional[max_width]=>String,Optional[padding_policy]=>String,Optional[resolution]=>String,Optional[sizing_policy]=>String]]"`
		Type                        *string
		Video                       *map[string]string `puppet:"type => Optional[Struct[Optional[aspect_ratio]=>String,Optional[bit_rate]=>String,Optional[codec]=>String,Optional[display_aspect_ratio]=>String,Optional[fixed_gop]=>String,Optional[frame_rate]=>String,Optional[keyframes_max_dist]=>String,Optional[max_frame_rate]=>String,Optional[max_height]=>String,Optional[max_width]=>String,Optional[padding_policy]=>String,Optional[resolution]=>String,Optional[sizing_policy]=>String]]"`
		Video_codec_options         *map[string]string
		Video_watermarks            *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[horizontal_align]=>String,Optional[horizontal_offset]=>String,Optional[id]=>String,Optional[max_height]=>String,Optional[max_width]=>String,Optional[opacity]=>String,Optional[sizing_policy]=>String,Optional[target]=>String,Optional[vertical_align]=>String,Optional[vertical_offset]=>String]]]"`
	}

	Elb struct {
		Elb_id                      *string                 `lyra:"tf-gen.ignore"`
		Access_logs                 *map[string]interface{} `puppet:"type => Optional[Struct[bucket=>String,Optional[bucket_prefix]=>String,Optional[enabled]=>Boolean,Optional[interval]=>Integer]]"`
		Arn                         *string
		Availability_zones          *[]string
		Connection_draining         bool  `puppet:"value=>false"`
		Connection_draining_timeout int64 `puppet:"value=>300"`
		Cross_zone_load_balancing   bool  `puppet:"value=>true"`
		Dns_name                    *string
		Health_check                *map[string]interface{} `puppet:"type => Optional[Struct[healthy_threshold=>Integer,interval=>Integer,target=>String,timeout=>Integer,unhealthy_threshold=>Integer]]"`
		Idle_timeout                int64                   `puppet:"value=>60"`
		Instances                   *[]string
		Internal                    *bool
		Listener                    []map[string]interface{} `puppet:"type => Array[Struct[instance_port=>Integer,instance_protocol=>String,lb_port=>Integer,lb_protocol=>String,Optional[ssl_certificate_id]=>String]]"`
		Name                        *string
		Name_prefix                 *string
		Security_groups             *[]string
		Source_security_group       *string
		Source_security_group_id    *string
		Subnets                     *[]string
		Tags                        *map[string]string
		Zone_id                     *string
	}

	Elb_attachment struct {
		Elb_attachment_id *string `lyra:"tf-gen.ignore"`
		Elb               string
		Instance          string
	}

	Emr_cluster struct {
		Emr_cluster_id                    *string `lyra:"tf-gen.ignore"`
		Additional_info                   *string
		Applications                      *[]string
		Autoscaling_role                  *string
		Bootstrap_action                  *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[args]=>Array[String],name=>String,path=>String]]]"`
		Cluster_state                     *string
		Configurations                    *string
		Configurations_json               *string
		Core_instance_count               *int64
		Core_instance_type                *string
		Custom_ami_id                     *string
		Ebs_root_volume_size              *int64
		Ec2_attributes                    *map[string]string        `puppet:"type => Optional[Struct[Optional[additional_master_security_groups]=>String,Optional[additional_slave_security_groups]=>String,Optional[emr_managed_master_security_group]=>String,Optional[emr_managed_slave_security_group]=>String,instance_profile=>String,Optional[key_name]=>String,Optional[service_access_security_group]=>String,Optional[subnet_id]=>String]]"`
		Instance_group                    *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[autoscaling_policy]=>String,Optional[bid_price]=>String,Optional[ebs_config]=>Array[Struct[Optional[iops]=>Integer,size=>Integer,type=>String,Optional[volumes_per_instance]=>Integer]],Optional[id]=>String,Optional[instance_count]=>Integer,instance_role=>String,instance_type=>String,Optional[name]=>String]]]"`
		Keep_job_flow_alive_when_no_steps *bool
		Kerberos_attributes               *map[string]string `puppet:"type => Optional[Struct[Optional[ad_domain_join_password]=>String,Optional[ad_domain_join_user]=>String,Optional[cross_realm_trust_principal_password]=>String,kdc_admin_password=>String,realm=>String]]"`
		Log_uri                           *string
		Master_instance_type              *string
		Master_public_dns                 *string
		Name                              string
		Release_label                     string
		Scale_down_behavior               *string
		Security_configuration            *string
		Service_role                      string
		Step                              *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[action_on_failure=>String,hadoop_jar_step=>Struct[Optional[args]=>Array[String],jar=>String,Optional[main_class]=>String,Optional[properties]=>Hash[String,String]],name=>String]]]"`
		Tags                              *map[string]string
		Termination_protection            *bool
		Visible_to_all_users              bool `puppet:"value=>true"`
	}

	Emr_instance_group struct {
		Emr_instance_group_id  *string `lyra:"tf-gen.ignore"`
		Cluster_id             string
		Ebs_config             *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[iops]=>Integer,size=>Integer,type=>String,Optional[volumes_per_instance]=>Integer]]]"`
		Ebs_optimized          *bool
		Instance_count         int64 `puppet:"value=>0"`
		Instance_type          string
		Name                   *string
		Running_instance_count *int64
		Status                 *string
	}

	Emr_security_configuration struct {
		Emr_security_configuration_id *string `lyra:"tf-gen.ignore"`
		Configuration                 string
		Creation_date                 *string
		Name                          *string
		Name_prefix                   *string
	}

	Flow_log struct {
		Flow_log_id          *string `lyra:"tf-gen.ignore"`
		Eni_id               *string
		Iam_role_arn         *string
		Log_destination      *string
		Log_destination_type string `puppet:"value=>'cloud-watch-logs'"`
		Log_group_name       *string
		Subnet_id            *string
		Traffic_type         string
		Vpc_id               *string
	}

	Gamelift_alias struct {
		Gamelift_alias_id *string `lyra:"tf-gen.ignore"`
		Arn               *string
		Description       *string
		Name              string
		Routing_strategy  *map[string]string `puppet:"type => Optional[Struct[Optional[fleet_id]=>String,Optional[message]=>String,type=>String]]"`
	}

	Gamelift_build struct {
		Gamelift_build_id *string `lyra:"tf-gen.ignore"`
		Name              string
		Operating_system  string
		Storage_location  *map[string]string `puppet:"type => Optional[Struct[bucket=>String,key=>String,role_arn=>String]]"`
		Version           *string
	}

	Gamelift_fleet struct {
		Gamelift_fleet_id                  *string `lyra:"tf-gen.ignore"`
		Arn                                *string
		Build_id                           string
		Description                        *string
		Ec2_inbound_permission             *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[from_port=>Integer,ip_range=>String,protocol=>String,to_port=>Integer],0,50]]"`
		Ec2_instance_type                  string
		Log_paths                          *[]string
		Metric_groups                      *[]string
		Name                               string
		New_game_session_protection_policy string `puppet:"value=>'NoProtection'"`
		Operating_system                   *string
		Resource_creation_limit_policy     *map[string]int64       `puppet:"type => Optional[Struct[Optional[new_game_sessions_per_creator]=>Integer,Optional[policy_period_in_minutes]=>Integer]]"`
		Runtime_configuration              *map[string]interface{} `puppet:"type => Optional[Struct[Optional[game_session_activation_timeout_seconds]=>Integer,Optional[max_concurrent_game_session_activations]=>Integer,Optional[server_process]=>Array[Struct[concurrent_executions=>Integer,launch_path=>String,Optional[parameters]=>String],0,50]]]"`
	}

	Gamelift_game_session_queue struct {
		Gamelift_game_session_queue_id *string `lyra:"tf-gen.ignore"`
		Arn                            *string
		Destinations                   *[]string
		Name                           string
		Player_latency_policy          *[]map[string]int64 `puppet:"type => Optional[Array[Struct[maximum_individual_player_latency_milliseconds=>Integer,Optional[policy_duration_seconds]=>Integer]]]"`
		Timeout_in_seconds             *int64
	}

	Glacier_vault struct {
		Glacier_vault_id *string `lyra:"tf-gen.ignore"`
		Access_policy    *string
		Arn              *string
		Location         *string
		Name             string
		Notification     *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[events=>Array[String],sns_topic=>String]]]"`
		Tags             *map[string]string
	}

	Glacier_vault_lock struct {
		Glacier_vault_lock_id *string `lyra:"tf-gen.ignore"`
		Complete_lock         bool
		Ignore_deletion_error bool `puppet:"value=>false"`
		Policy                string
		Vault_name            string
	}

	Globalaccelerator_accelerator struct {
		Globalaccelerator_accelerator_id *string                   `lyra:"tf-gen.ignore"`
		Attributes                       *map[string]interface{}   `puppet:"type => Optional[Struct[Optional[flow_logs_enabled]=>Boolean,Optional[flow_logs_s3_bucket]=>String,Optional[flow_logs_s3_prefix]=>String]]"`
		Enabled                          bool                      `puppet:"value=>true"`
		Ip_address_type                  string                    `puppet:"value=>'IPV4'"`
		Ip_sets                          *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[ip_addresses]=>Array[String],Optional[ip_family]=>String]]]"`
		Name                             string
	}

	Glue_catalog_database struct {
		Glue_catalog_database_id *string `lyra:"tf-gen.ignore"`
		Catalog_id               *string
		Description              *string
		Location_uri             *string
		Name                     string
		Parameters               *map[string]string
	}

	Glue_catalog_table struct {
		Glue_catalog_table_id *string `lyra:"tf-gen.ignore"`
		Catalog_id            *string
		Database_name         string
		Description           *string
		Name                  string
		Owner                 *string
		Parameters            *map[string]string
		Partition_keys        *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[comment]=>String,name=>String,Optional[type]=>String]]]"`
		Retention             *int64
		Storage_descriptor    *map[string]interface{} `puppet:"type => Optional[Struct[Optional[bucket_columns]=>Array[String],Optional[columns]=>Array[Struct[Optional[comment]=>String,name=>String,Optional[type]=>String]],Optional[compressed]=>Boolean,Optional[input_format]=>String,Optional[location]=>String,Optional[number_of_buckets]=>Integer,Optional[output_format]=>String,Optional[parameters]=>Hash[String,String],Optional[ser_de_info]=>Struct[Optional[name]=>String,Optional[parameters]=>Hash[String,String],Optional[serialization_library]=>String],Optional[skewed_info]=>Struct[Optional[skewed_column_names]=>Array[String],Optional[skewed_column_value_location_maps]=>Hash[String,String],Optional[skewed_column_values]=>Array[String]],Optional[sort_columns]=>Array[Struct[column=>String,sort_order=>Integer]],Optional[stored_as_sub_directories]=>Boolean]]"`
		Table_type            *string
		View_expanded_text    *string
		View_original_text    *string
	}

	Glue_classifier struct {
		Glue_classifier_id *string            `lyra:"tf-gen.ignore"`
		Grok_classifier    *map[string]string `puppet:"type => Optional[Struct[classification=>String,Optional[custom_patterns]=>String,grok_pattern=>String]]"`
		Json_classifier    *map[string]string `puppet:"type => Optional[Struct[json_path=>String]]"`
		Name               string
		Xml_classifier     *map[string]string `puppet:"type => Optional[Struct[classification=>String,row_tag=>String]]"`
	}

	Glue_connection struct {
		Glue_connection_id               *string `lyra:"tf-gen.ignore"`
		Catalog_id                       *string
		Connection_properties            map[string]string
		Connection_type                  string `puppet:"value=>'JDBC'"`
		Description                      *string
		Match_criteria                   *[]string
		Name                             string
		Physical_connection_requirements *map[string]interface{} `puppet:"type => Optional[Struct[Optional[availability_zone]=>String,Optional[security_group_id_list]=>Array[String],Optional[subnet_id]=>String]]"`
	}

	Glue_crawler struct {
		Glue_crawler_id        *string `lyra:"tf-gen.ignore"`
		Classifiers            *[]string
		Configuration          *string
		Database_name          string
		Description            *string
		Dynamodb_target        *[]map[string]string      `puppet:"type => Optional[Array[Struct[path=>String],1]]"`
		Jdbc_target            *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[connection_name=>String,Optional[exclusions]=>Array[String],path=>String],1]]"`
		Name                   string
		Role                   string
		S3_target              *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[exclusions]=>Array[String],path=>String],1]]"`
		Schedule               *string
		Schema_change_policy   *map[string]string `puppet:"type => Optional[Struct[Optional[delete_behavior]=>String,Optional[update_behavior]=>String]]"`
		Security_configuration *string
		Table_prefix           *string
	}

	Glue_job struct {
		Glue_job_id            *string            `lyra:"tf-gen.ignore"`
		Allocated_capacity     int64              `puppet:"value=>10"`
		Command                *map[string]string `puppet:"type => Optional[Struct[Optional[name]=>String,script_location=>String]]"`
		Connections            *[]string
		Default_arguments      *map[string]string
		Description            *string
		Execution_property     *map[string]int64 `puppet:"type => Optional[Struct[Optional[max_concurrent_runs]=>Integer]]"`
		Max_retries            *int64
		Name                   string
		Role_arn               string
		Security_configuration *string
		Timeout                int64 `puppet:"value=>2880"`
	}

	Glue_security_configuration struct {
		Glue_security_configuration_id *string                   `lyra:"tf-gen.ignore"`
		Encryption_configuration       *map[string][]interface{} `puppet:"type => Optional[Struct[cloudwatch_encryption=>Struct[Optional[cloudwatch_encryption_mode]=>String,Optional[kms_key_arn]=>String],job_bookmarks_encryption=>Struct[Optional[job_bookmarks_encryption_mode]=>String,Optional[kms_key_arn]=>String],s3_encryption=>Struct[Optional[kms_key_arn]=>String,Optional[s3_encryption_mode]=>String]]]"`
		Name                           string
	}

	Glue_trigger struct {
		Glue_trigger_id *string                  `lyra:"tf-gen.ignore"`
		Actions         []map[string]interface{} `puppet:"type => Array[Struct[Optional[arguments]=>Hash[String,String],job_name=>String,Optional[timeout]=>Integer],1]"`
		Description     *string
		Enabled         bool `puppet:"value=>true"`
		Name            string
		Predicate       *map[string]interface{} `puppet:"type => Optional[Struct[conditions=>Array[Struct[job_name=>String,Optional[logical_operator]=>String,state=>String],1],Optional[logical]=>String]]"`
		Schedule        *string
		Type            string
	}

	Guardduty_detector struct {
		Guardduty_detector_id        *string `lyra:"tf-gen.ignore"`
		Account_id                   *string
		Enable                       bool   `puppet:"value=>true"`
		Finding_publishing_frequency string `puppet:"value=>'SIX_HOURS'"`
	}

	Guardduty_ipset struct {
		Guardduty_ipset_id *string `lyra:"tf-gen.ignore"`
		Activate           bool
		Detector_id        string
		Format             string
		Location           string
		Name               string
	}

	Guardduty_member struct {
		Guardduty_member_id        *string `lyra:"tf-gen.ignore"`
		Account_id                 string
		Detector_id                string
		Disable_email_notification *bool
		Email                      string
		Invitation_message         *string
		Invite                     *bool
		Relationship_status        *string
	}

	Guardduty_threatintelset struct {
		Guardduty_threatintelset_id *string `lyra:"tf-gen.ignore"`
		Activate                    bool
		Detector_id                 string
		Format                      string
		Location                    string
		Name                        string
	}

	Iam_access_key struct {
		Iam_access_key_id *string `lyra:"tf-gen.ignore"`
		Encrypted_secret  *string
		Key_fingerprint   *string
		Pgp_key           *string
		Secret            *string
		Ses_smtp_password *string
		Status            *string
		User              string
	}

	Iam_account_alias struct {
		Iam_account_alias_id *string `lyra:"tf-gen.ignore"`
		Account_alias        string
	}

	Iam_account_password_policy struct {
		Iam_account_password_policy_id *string `lyra:"tf-gen.ignore"`
		Allow_users_to_change_password bool    `puppet:"value=>true"`
		Expire_passwords               *bool
		Hard_expiry                    *bool
		Max_password_age               *int64
		Minimum_password_length        int64 `puppet:"value=>6"`
		Password_reuse_prevention      *int64
		Require_lowercase_characters   *bool
		Require_numbers                *bool
		Require_symbols                *bool
		Require_uppercase_characters   *bool
	}

	Iam_group struct {
		Iam_group_id *string `lyra:"tf-gen.ignore"`
		Arn          *string
		Name         string
		Path         string `puppet:"value=>'/'"`
		Unique_id    *string
	}

	Iam_group_membership struct {
		Iam_group_membership_id *string `lyra:"tf-gen.ignore"`
		Group                   string
		Name                    string
		Users                   []string
	}

	Iam_group_policy struct {
		Iam_group_policy_id *string `lyra:"tf-gen.ignore"`
		Group               string
		Name                *string
		Name_prefix         *string
		Policy              string
	}

	Iam_group_policy_attachment struct {
		Iam_group_policy_attachment_id *string `lyra:"tf-gen.ignore"`
		Group                          string
		Policy_arn                     string
	}

	Iam_instance_profile struct {
		Iam_instance_profile_id *string `lyra:"tf-gen.ignore"`
		Arn                     *string
		Create_date             *string
		Name                    *string
		Name_prefix             *string
		Path                    string `puppet:"value=>'/'"`
		Role                    *string
		Roles                   *[]string
		Unique_id               *string
	}

	Iam_openid_connect_provider struct {
		Iam_openid_connect_provider_id *string `lyra:"tf-gen.ignore"`
		Arn                            *string
		Client_id_list                 []string
		Thumbprint_list                []string
		Url                            string
	}

	Iam_policy struct {
		Iam_policy_id *string `lyra:"tf-gen.ignore"`
		Arn           *string
		Description   *string
		Name          *string
		Name_prefix   *string
		Path          string `puppet:"value=>'/'"`
		Policy        string
	}

	Iam_policy_attachment struct {
		Iam_policy_attachment_id *string `lyra:"tf-gen.ignore"`
		Groups                   *[]string
		Name                     string
		Policy_arn               string
		Roles                    *[]string
		Users                    *[]string
	}

	Iam_role struct {
		Iam_role_id           *string `lyra:"tf-gen.ignore"`
		Arn                   *string
		Assume_role_policy    string
		Create_date           *string
		Description           *string
		Force_detach_policies bool  `puppet:"value=>false"`
		Max_session_duration  int64 `puppet:"value=>3600"`
		Name                  *string
		Name_prefix           *string
		Path                  string `puppet:"value=>'/'"`
		Permissions_boundary  *string
		Tags                  *map[string]string
		Unique_id             *string
	}

	Iam_role_policy struct {
		Iam_role_policy_id *string `lyra:"tf-gen.ignore"`
		Name               *string
		Name_prefix        *string
		Policy             string
		Role               string
	}

	Iam_role_policy_attachment struct {
		Iam_role_policy_attachment_id *string `lyra:"tf-gen.ignore"`
		Policy_arn                    string
		Role                          string
	}

	Iam_saml_provider struct {
		Iam_saml_provider_id   *string `lyra:"tf-gen.ignore"`
		Arn                    *string
		Name                   string
		Saml_metadata_document string
		Valid_until            *string
	}

	Iam_server_certificate struct {
		Iam_server_certificate_id *string `lyra:"tf-gen.ignore"`
		Arn                       *string
		Certificate_body          string
		Certificate_chain         *string
		Name                      *string
		Name_prefix               *string
		Path                      string `puppet:"value=>'/'"`
		Private_key               string
	}

	Iam_service_linked_role struct {
		Iam_service_linked_role_id *string `lyra:"tf-gen.ignore"`
		Arn                        *string
		Aws_service_name           string
		Create_date                *string
		Custom_suffix              *string
		Description                *string
		Name                       *string
		Path                       *string
		Unique_id                  *string
	}

	Iam_user struct {
		Iam_user_id          *string `lyra:"tf-gen.ignore"`
		Arn                  *string
		Force_destroy        bool `puppet:"value=>false"`
		Name                 string
		Path                 string `puppet:"value=>'/'"`
		Permissions_boundary *string
		Tags                 *map[string]string
		Unique_id            *string
	}

	Iam_user_group_membership struct {
		Iam_user_group_membership_id *string `lyra:"tf-gen.ignore"`
		Groups                       []string
		User                         string
	}

	Iam_user_login_profile struct {
		Iam_user_login_profile_id *string `lyra:"tf-gen.ignore"`
		Encrypted_password        *string
		Key_fingerprint           *string
		Password_length           int64 `puppet:"value=>20"`
		Password_reset_required   bool  `puppet:"value=>true"`
		Pgp_key                   string
		User                      string
	}

	Iam_user_policy struct {
		Iam_user_policy_id *string `lyra:"tf-gen.ignore"`
		Name               *string
		Name_prefix        *string
		Policy             string
		User               string
	}

	Iam_user_policy_attachment struct {
		Iam_user_policy_attachment_id *string `lyra:"tf-gen.ignore"`
		Policy_arn                    string
		User                          string
	}

	Iam_user_ssh_key struct {
		Iam_user_ssh_key_id *string `lyra:"tf-gen.ignore"`
		Encoding            string
		Fingerprint         *string
		Public_key          string
		Ssh_public_key_id   *string
		Status              *string
		Username            string
	}

	Inspector_assessment_target struct {
		Inspector_assessment_target_id *string `lyra:"tf-gen.ignore"`
		Arn                            *string
		Name                           string
		Resource_group_arn             *string
	}

	Inspector_assessment_template struct {
		Inspector_assessment_template_id *string `lyra:"tf-gen.ignore"`
		Arn                              *string
		Duration                         int64
		Name                             string
		Rules_package_arns               []string
		Target_arn                       string
	}

	Inspector_resource_group struct {
		Inspector_resource_group_id *string `lyra:"tf-gen.ignore"`
		Arn                         *string
		Tags                        map[string]string
	}

	Instance struct {
		Instance_id                          *string `lyra:"tf-gen.ignore"`
		Ami                                  string
		Arn                                  *string
		Associate_public_ip_address          *bool
		Availability_zone                    *string
		Block_device                         *map[string]string
		Cpu_core_count                       *int64
		Cpu_threads_per_core                 *int64
		Credit_specification                 *map[string]string `puppet:"type => Optional[Struct[Optional[cpu_credits]=>String]]"`
		Disable_api_termination              *bool
		Ebs_block_device                     *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[delete_on_termination]=>Boolean,device_name=>String,Optional[encrypted]=>Boolean,Optional[iops]=>Integer,Optional[snapshot_id]=>String,Optional[volume_id]=>String,Optional[volume_size]=>Integer,Optional[volume_type]=>String]]]"`
		Ebs_optimized                        *bool
		Ephemeral_block_device               *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[device_name=>String,Optional[no_device]=>Boolean,Optional[virtual_name]=>String]]]"`
		Get_password_data                    bool                      `puppet:"value=>false"`
		Host_id                              *string
		Iam_instance_profile                 *string
		Instance_initiated_shutdown_behavior *string
		Instance_state                       *string
		Instance_type                        string
		Ipv6_address_count                   *int64
		Ipv6_addresses                       *[]string
		Key_name                             *string
		Monitoring                           *bool
		Network_interface                    *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[delete_on_termination]=>Boolean,device_index=>Integer,network_interface_id=>String]]]"`
		Network_interface_id                 *string
		Password_data                        *string
		Placement_group                      *string
		Primary_network_interface_id         *string
		Private_dns                          *string
		Private_ip                           *string
		Public_dns                           *string
		Public_ip                            *string
		Root_block_device                    *map[string]interface{} `puppet:"type => Optional[Struct[Optional[delete_on_termination]=>Boolean,Optional[iops]=>Integer,Optional[volume_id]=>String,Optional[volume_size]=>Integer,Optional[volume_type]=>String]]"`
		Security_groups                      *[]string
		Source_dest_check                    bool `puppet:"value=>true"`
		Subnet_id                            *string
		Tags                                 *map[string]string
		Tenancy                              *string
		User_data                            *string
		User_data_base64                     *string
		Volume_tags                          *map[string]string
		Vpc_security_group_ids               *[]string
	}

	Internet_gateway struct {
		Internet_gateway_id *string `lyra:"tf-gen.ignore"`
		Owner_id            *string
		Tags                *map[string]string
		Vpc_id              *string
	}

	Iot_certificate struct {
		Iot_certificate_id *string `lyra:"tf-gen.ignore"`
		Active             bool
		Arn                *string
		Csr                string
	}

	Iot_policy struct {
		Iot_policy_id      *string `lyra:"tf-gen.ignore"`
		Arn                *string
		Default_version_id *string
		Name               string
		Policy             string
	}

	Iot_policy_attachment struct {
		Iot_policy_attachment_id *string `lyra:"tf-gen.ignore"`
		Policy                   string
		Target                   string
	}

	Iot_thing struct {
		Iot_thing_id      *string `lyra:"tf-gen.ignore"`
		Arn               *string
		Attributes        *map[string]string
		Default_client_id *string
		Name              string
		Thing_type_name   *string
		Version           *int64
	}

	Iot_thing_principal_attachment struct {
		Iot_thing_principal_attachment_id *string `lyra:"tf-gen.ignore"`
		Principal                         string
		Thing                             string
	}

	Iot_thing_type struct {
		Iot_thing_type_id *string `lyra:"tf-gen.ignore"`
		Arn               *string
		Deprecated        bool `puppet:"value=>false"`
		Name              string
		Properties        *map[string]interface{} `puppet:"type => Optional[Struct[Optional[description]=>String,Optional[searchable_attributes]=>Array[String,0,3]]]"`
	}

	Iot_topic_rule struct {
		Iot_topic_rule_id *string `lyra:"tf-gen.ignore"`
		Arn               *string
		Cloudwatch_alarm  *[]map[string]string `puppet:"type => Optional[Array[Struct[alarm_name=>String,role_arn=>String,state_reason=>String,state_value=>String]]]"`
		Cloudwatch_metric *[]map[string]string `puppet:"type => Optional[Array[Struct[metric_name=>String,metric_namespace=>String,Optional[metric_timestamp]=>String,metric_unit=>String,metric_value=>String,role_arn=>String]]]"`
		Description       *string
		Dynamodb          *[]map[string]string `puppet:"type => Optional[Array[Struct[hash_key_field=>String,Optional[hash_key_type]=>String,hash_key_value=>String,Optional[payload_field]=>String,range_key_field=>String,Optional[range_key_type]=>String,range_key_value=>String,role_arn=>String,table_name=>String]]]"`
		Elasticsearch     *[]map[string]string `puppet:"type => Optional[Array[Struct[endpoint=>String,id=>String,index=>String,role_arn=>String,type=>String]]]"`
		Enabled           bool
		Firehose          *[]map[string]string `puppet:"type => Optional[Array[Struct[delivery_stream_name=>String,role_arn=>String,Optional[separator]=>String]]]"`
		Kinesis           *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[partition_key]=>String,role_arn=>String,stream_name=>String]]]"`
		Lambda            *[]map[string]string `puppet:"type => Optional[Array[Struct[function_arn=>String]]]"`
		Name              string
		Republish         *[]map[string]string `puppet:"type => Optional[Array[Struct[role_arn=>String,topic=>String]]]"`
		S3                *[]map[string]string `puppet:"type => Optional[Array[Struct[bucket_name=>String,key=>String,role_arn=>String]]]"`
		Sns               *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[message_format]=>String,role_arn=>String,target_arn=>String]]]"`
		Sql               string
		Sql_version       string
		Sqs               *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[queue_url=>String,role_arn=>String,use_base64=>Boolean]]]"`
	}

	Key_pair struct {
		Key_pair_id     *string `lyra:"tf-gen.ignore"`
		Fingerprint     *string
		Key_name        *string
		Key_name_prefix *string
		Public_key      string
	}

	Kinesis_analytics_application struct {
		Kinesis_analytics_application_id *string `lyra:"tf-gen.ignore"`
		Arn                              *string
		Cloudwatch_logging_options       *map[string]string `puppet:"type => Optional[Struct[Optional[id]=>String,log_stream_arn=>String,role_arn=>String]]"`
		Code                             *string
		Create_timestamp                 *string
		Description                      *string
		Inputs                           *map[string]interface{} `puppet:"type => Optional[Struct[Optional[id]=>String,Optional[kinesis_firehose]=>Struct[resource_arn=>String,role_arn=>String],Optional[kinesis_stream]=>Struct[resource_arn=>String,role_arn=>String],name_prefix=>String,Optional[parallelism]=>Struct[count=>Integer],Optional[processing_configuration]=>Struct[lambda=>Struct[resource_arn=>String,role_arn=>String]],schema=>Struct[record_columns=>Array[Struct[Optional[mapping]=>String,name=>String,sql_type=>String]],Optional[record_encoding]=>String,record_format=>Struct[Optional[mapping_parameters]=>Struct[Optional[csv]=>Struct[record_column_delimiter=>String,record_row_delimiter=>String],Optional[json]=>Struct[record_row_path=>String]],Optional[record_format_type]=>String]],Optional[starting_position_configuration]=>Array[Struct[Optional[starting_position]=>String]],Optional[stream_names]=>Array[String]]]"`
		Last_update_timestamp            *string
		Name                             string
		Outputs                          *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[id]=>String,Optional[kinesis_firehose]=>Struct[resource_arn=>String,role_arn=>String],Optional[kinesis_stream]=>Struct[resource_arn=>String,role_arn=>String],Optional[lambda]=>Struct[resource_arn=>String,role_arn=>String],name=>String,schema=>Struct[Optional[record_format_type]=>String]],0,3]]"`
		Reference_data_sources           *map[string]interface{}   `puppet:"type => Optional[Struct[Optional[id]=>String,s3=>Struct[bucket_arn=>String,file_key=>String,role_arn=>String],schema=>Struct[record_columns=>Array[Struct[Optional[mapping]=>String,name=>String,sql_type=>String]],Optional[record_encoding]=>String,record_format=>Struct[Optional[mapping_parameters]=>Struct[Optional[csv]=>Struct[record_column_delimiter=>String,record_row_delimiter=>String],Optional[json]=>Struct[record_row_path=>String]],Optional[record_format_type]=>String]],table_name=>String]]"`
		Status                           *string
		Version                          *int64
	}

	Kinesis_firehose_delivery_stream struct {
		Kinesis_firehose_delivery_stream_id *string `lyra:"tf-gen.ignore"`
		Arn                                 *string
		Destination                         string
		Destination_id                      *string
		Elasticsearch_configuration         *map[string]interface{} `puppet:"type => Optional[Struct[Optional[buffering_interval]=>Integer,Optional[buffering_size]=>Integer,Optional[cloudwatch_logging_options]=>Struct[Optional[enabled]=>Boolean,Optional[log_group_name]=>String,Optional[log_stream_name]=>String],domain_arn=>String,index_name=>String,Optional[index_rotation_period]=>String,Optional[processing_configuration]=>Struct[Optional[enabled]=>Boolean,Optional[processors]=>Array[Struct[Optional[parameters]=>Array[Struct[parameter_name=>String,parameter_value=>String]],type=>String]]],Optional[retry_duration]=>Integer,role_arn=>String,Optional[s3_backup_mode]=>String,Optional[type_name]=>String]]"`
		Extended_s3_configuration           *map[string]interface{} `puppet:"type => Optional[Struct[bucket_arn=>String,Optional[buffer_interval]=>Integer,Optional[buffer_size]=>Integer,Optional[cloudwatch_logging_options]=>Struct[Optional[enabled]=>Boolean,Optional[log_group_name]=>String,Optional[log_stream_name]=>String],Optional[compression_format]=>String,Optional[data_format_conversion_configuration]=>Struct[Optional[enabled]=>Boolean,input_format_configuration=>Struct[deserializer=>Struct[Optional[hive_json_ser_de]=>Struct[Optional[timestamp_formats]=>Array[String]],Optional[open_x_json_ser_de]=>Struct[Optional[case_insensitive]=>Boolean,Optional[column_to_json_key_mappings]=>Hash[String,String],Optional[convert_dots_in_json_keys_to_underscores]=>Boolean]]],output_format_configuration=>Struct[serializer=>Struct[Optional[orc_ser_de]=>Struct[Optional[block_size_bytes]=>Integer,Optional[bloom_filter_columns]=>Array[String],Optional[bloom_filter_false_positive_probability]=>Float,Optional[compression]=>String,Optional[dictionary_key_threshold]=>Float,Optional[enable_padding]=>Boolean,Optional[format_version]=>String,Optional[padding_tolerance]=>Float,Optional[row_index_stride]=>Integer,Optional[stripe_size_bytes]=>Integer],Optional[parquet_ser_de]=>Struct[Optional[block_size_bytes]=>Integer,Optional[compression]=>String,Optional[enable_dictionary_compression]=>Boolean,Optional[max_padding_bytes]=>Integer,Optional[page_size_bytes]=>Integer,Optional[writer_version]=>String]]],schema_configuration=>Struct[Optional[catalog_id]=>String,database_name=>String,Optional[region]=>String,role_arn=>String,table_name=>String,Optional[version_id]=>String]],Optional[error_output_prefix]=>String,Optional[kms_key_arn]=>String,Optional[prefix]=>String,Optional[processing_configuration]=>Struct[Optional[enabled]=>Boolean,Optional[processors]=>Array[Struct[Optional[parameters]=>Array[Struct[parameter_name=>String,parameter_value=>String]],type=>String]]],role_arn=>String,Optional[s3_backup_configuration]=>Struct[bucket_arn=>String,Optional[buffer_interval]=>Integer,Optional[buffer_size]=>Integer,Optional[cloudwatch_logging_options]=>Struct[Optional[enabled]=>Boolean,Optional[log_group_name]=>String,Optional[log_stream_name]=>String],Optional[compression_format]=>String,Optional[kms_key_arn]=>String,Optional[prefix]=>String,role_arn=>String],Optional[s3_backup_mode]=>String]]"`
		Kinesis_source_configuration        *map[string]string      `puppet:"type => Optional[Struct[kinesis_stream_arn=>String,role_arn=>String]]"`
		Name                                string
		Redshift_configuration              *map[string]interface{} `puppet:"type => Optional[Struct[Optional[cloudwatch_logging_options]=>Struct[Optional[enabled]=>Boolean,Optional[log_group_name]=>String,Optional[log_stream_name]=>String],cluster_jdbcurl=>String,Optional[copy_options]=>String,Optional[data_table_columns]=>String,data_table_name=>String,password=>String,Optional[processing_configuration]=>Struct[Optional[enabled]=>Boolean,Optional[processors]=>Array[Struct[Optional[parameters]=>Array[Struct[parameter_name=>String,parameter_value=>String]],type=>String]]],Optional[retry_duration]=>Integer,role_arn=>String,Optional[s3_backup_configuration]=>Struct[bucket_arn=>String,Optional[buffer_interval]=>Integer,Optional[buffer_size]=>Integer,Optional[cloudwatch_logging_options]=>Struct[Optional[enabled]=>Boolean,Optional[log_group_name]=>String,Optional[log_stream_name]=>String],Optional[compression_format]=>String,Optional[kms_key_arn]=>String,Optional[prefix]=>String,role_arn=>String],Optional[s3_backup_mode]=>String,username=>String]]"`
		S3_configuration                    *map[string]interface{} `puppet:"type => Optional[Struct[bucket_arn=>String,Optional[buffer_interval]=>Integer,Optional[buffer_size]=>Integer,Optional[cloudwatch_logging_options]=>Struct[Optional[enabled]=>Boolean,Optional[log_group_name]=>String,Optional[log_stream_name]=>String],Optional[compression_format]=>String,Optional[kms_key_arn]=>String,Optional[prefix]=>String,role_arn=>String]]"`
		Splunk_configuration                *map[string]interface{} `puppet:"type => Optional[Struct[Optional[cloudwatch_logging_options]=>Struct[Optional[enabled]=>Boolean,Optional[log_group_name]=>String,Optional[log_stream_name]=>String],Optional[hec_acknowledgment_timeout]=>Integer,hec_endpoint=>String,Optional[hec_endpoint_type]=>String,hec_token=>String,Optional[processing_configuration]=>Struct[Optional[enabled]=>Boolean,Optional[processors]=>Array[Struct[Optional[parameters]=>Array[Struct[parameter_name=>String,parameter_value=>String]],type=>String]]],Optional[retry_duration]=>Integer,Optional[s3_backup_mode]=>String]]"`
		Tags                                *map[string]string
		Version_id                          *string
	}

	Kinesis_stream struct {
		Kinesis_stream_id   *string `lyra:"tf-gen.ignore"`
		Arn                 *string
		Encryption_type     string `puppet:"value=>'NONE'"`
		Kms_key_id          *string
		Name                string
		Retention_period    int64 `puppet:"value=>24"`
		Shard_count         int64
		Shard_level_metrics *[]string
		Tags                *map[string]string
	}

	Kms_alias struct {
		Kms_alias_id   *string `lyra:"tf-gen.ignore"`
		Arn            *string
		Name           *string
		Name_prefix    *string
		Target_key_arn *string
		Target_key_id  string
	}

	Kms_grant struct {
		Kms_grant_id          *string                              `lyra:"tf-gen.ignore"`
		Constraints           *[]map[string]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[encryption_context_equals]=>Hash[String,String],Optional[encryption_context_subset]=>Hash[String,String]]]]"`
		Grant_creation_tokens *[]string
		Grant_id              *string
		Grant_token           *string
		Grantee_principal     string
		Key_id                string
		Name                  *string
		Operations            []string
		Retire_on_delete      bool `puppet:"value=>false"`
		Retiring_principal    *string
	}

	Kms_key struct {
		Kms_key_id              *string `lyra:"tf-gen.ignore"`
		Arn                     *string
		Deletion_window_in_days *int64
		Description             *string
		Enable_key_rotation     bool `puppet:"value=>false"`
		Is_enabled              bool `puppet:"value=>true"`
		Key_id                  *string
		Key_usage               *string
		Policy                  *string
		Tags                    *map[string]string
	}

	Lambda_alias struct {
		Lambda_alias_id  *string `lyra:"tf-gen.ignore"`
		Arn              *string
		Description      *string
		Function_name    string
		Function_version string
		Invoke_arn       *string
		Name             string
		Routing_config   *map[string]map[string]interface{} `puppet:"type => Optional[Struct[Optional[additional_version_weights]=>Hash[String,Float]]]"`
	}

	Lambda_event_source_mapping struct {
		Lambda_event_source_mapping_id *string `lyra:"tf-gen.ignore"`
		Batch_size                     *int64
		Enabled                        bool `puppet:"value=>true"`
		Event_source_arn               string
		Function_arn                   *string
		Function_name                  string
		Last_modified                  *string
		Last_processing_result         *string
		Starting_position              *string
		Starting_position_timestamp    *time.Time
		State                          *string
		State_transition_reason        *string
		Uuid                           *string
	}

	Lambda_function struct {
		Lambda_function_id             *string `lyra:"tf-gen.ignore"`
		Arn                            *string
		Dead_letter_config             *map[string]string `puppet:"type => Optional[Struct[target_arn=>String]]"`
		Description                    *string
		Environment                    *map[string]map[string]interface{} `puppet:"type => Optional[Struct[Optional[variables]=>Hash[String,String]]]"`
		Filename                       *string
		Function_name                  string
		Handler                        string
		Invoke_arn                     *string
		Kms_key_arn                    *string
		Last_modified                  *string
		Layers                         *[]string
		Memory_size                    int64 `puppet:"value=>128"`
		Publish                        bool  `puppet:"value=>false"`
		Qualified_arn                  *string
		Reserved_concurrent_executions *int64
		Role                           string
		Runtime                        string
		S3_bucket                      *string
		S3_key                         *string
		S3_object_version              *string
		Source_code_hash               *string
		Source_code_size               *int64
		Tags                           *map[string]string
		Timeout                        int64              `puppet:"value=>3"`
		Tracing_config                 *map[string]string `puppet:"type => Optional[Struct[mode=>String]]"`
		Version                        *string
		Vpc_config                     *map[string]interface{} `puppet:"type => Optional[Struct[security_group_ids=>Array[String],subnet_ids=>Array[String],Optional[vpc_id]=>String]]"`
	}

	Lambda_layer_version struct {
		Lambda_layer_version_id *string `lyra:"tf-gen.ignore"`
		Arn                     *string
		Compatible_runtimes     *[]string
		Created_date            *string
		Description             *string
		Filename                *string
		Layer_arn               *string
		Layer_name              string
		License_info            *string
		S3_bucket               *string
		S3_key                  *string
		S3_object_version       *string
		Source_code_hash        *string
		Source_code_size        *int64
		Version                 *string
	}

	Lambda_permission struct {
		Lambda_permission_id *string `lyra:"tf-gen.ignore"`
		Action               string
		Event_source_token   *string
		Function_name        string
		Principal            string
		Qualifier            *string
		Source_account       *string
		Source_arn           *string
		Statement_id         *string
		Statement_id_prefix  *string
	}

	Launch_configuration struct {
		Launch_configuration_id          *string                   `lyra:"tf-gen.ignore"`
		Associate_public_ip_address      bool                      `puppet:"value=>false"`
		Ebs_block_device                 *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[delete_on_termination]=>Boolean,device_name=>String,Optional[encrypted]=>Boolean,Optional[iops]=>Integer,Optional[no_device]=>Boolean,Optional[snapshot_id]=>String,Optional[volume_size]=>Integer,Optional[volume_type]=>String]]]"`
		Ebs_optimized                    *bool
		Enable_monitoring                bool                 `puppet:"value=>true"`
		Ephemeral_block_device           *[]map[string]string `puppet:"type => Optional[Array[Struct[device_name=>String,virtual_name=>String]]]"`
		Iam_instance_profile             *string
		Image_id                         string
		Instance_type                    string
		Key_name                         *string
		Name                             *string
		Name_prefix                      *string
		Placement_tenancy                *string
		Root_block_device                *map[string]interface{} `puppet:"type => Optional[Struct[Optional[delete_on_termination]=>Boolean,Optional[iops]=>Integer,Optional[volume_size]=>Integer,Optional[volume_type]=>String]]"`
		Security_groups                  *[]string
		Spot_price                       *string
		User_data                        *string
		User_data_base64                 *string
		Vpc_classic_link_id              *string
		Vpc_classic_link_security_groups *[]string
	}

	Launch_template struct {
		Launch_template_id                   *string `lyra:"tf-gen.ignore"`
		Arn                                  *string
		Block_device_mappings                *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[device_name]=>String,Optional[ebs]=>Struct[Optional[delete_on_termination]=>String,Optional[encrypted]=>String,Optional[iops]=>Integer,Optional[kms_key_id]=>String,Optional[snapshot_id]=>String,Optional[volume_size]=>Integer,Optional[volume_type]=>String],Optional[no_device]=>String,Optional[virtual_name]=>String]]]"`
		Capacity_reservation_specification   *map[string]interface{}   `puppet:"type => Optional[Struct[Optional[capacity_reservation_preference]=>String,Optional[capacity_reservation_target]=>Struct[Optional[capacity_reservation_id]=>String]]]"`
		Credit_specification                 *map[string]string        `puppet:"type => Optional[Struct[Optional[cpu_credits]=>String]]"`
		Default_version                      *int64
		Description                          *string
		Disable_api_termination              *bool
		Ebs_optimized                        *string
		Elastic_gpu_specifications           *[]map[string]string `puppet:"type => Optional[Array[Struct[type=>String]]]"`
		Iam_instance_profile                 *map[string]string   `puppet:"type => Optional[Struct[Optional[arn]=>String,Optional[name]=>String]]"`
		Image_id                             *string
		Instance_initiated_shutdown_behavior *string
		Instance_market_options              *map[string]interface{} `puppet:"type => Optional[Struct[Optional[market_type]=>String,Optional[spot_options]=>Struct[Optional[block_duration_minutes]=>Integer,Optional[instance_interruption_behavior]=>String,Optional[max_price]=>String,Optional[spot_instance_type]=>String,Optional[valid_until]=>Timestamp]]]"`
		Instance_type                        *string
		Kernel_id                            *string
		Key_name                             *string
		Latest_version                       *int64
		License_specification                *[]map[string]string `puppet:"type => Optional[Array[Struct[license_configuration_arn=>String]]]"`
		Monitoring                           *map[string]bool     `puppet:"type => Optional[Struct[Optional[enabled]=>Boolean]]"`
		Name                                 *string
		Name_prefix                          *string
		Network_interfaces                   *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[associate_public_ip_address]=>Boolean,Optional[delete_on_termination]=>Boolean,Optional[description]=>String,Optional[device_index]=>Integer,Optional[ipv4_address_count]=>Integer,Optional[ipv4_addresses]=>Array[String],Optional[ipv6_address_count]=>Integer,Optional[ipv6_addresses]=>Array[String],Optional[network_interface_id]=>String,Optional[private_ip_address]=>String,Optional[security_groups]=>Array[String],Optional[subnet_id]=>String]]]"`
		Placement                            *map[string]string        `puppet:"type => Optional[Struct[Optional[affinity]=>String,Optional[availability_zone]=>String,Optional[group_name]=>String,Optional[host_id]=>String,Optional[spread_domain]=>String,Optional[tenancy]=>String]]"`
		Ram_disk_id                          *string
		Security_group_names                 *[]string
		Tag_specifications                   *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[resource_type]=>String,Optional[tags]=>Hash[String,String]]]]"`
		Tags                                 *map[string]string
		User_data                            *string
		Vpc_security_group_ids               *[]string
	}

	Lb struct {
		Lb_id                            *string                 `lyra:"tf-gen.ignore"`
		Access_logs                      *map[string]interface{} `puppet:"type => Optional[Struct[bucket=>String,Optional[enabled]=>Boolean,Optional[prefix]=>String]]"`
		Arn                              *string
		Arn_suffix                       *string
		Dns_name                         *string
		Enable_cross_zone_load_balancing bool  `puppet:"value=>false"`
		Enable_deletion_protection       bool  `puppet:"value=>false"`
		Enable_http2                     bool  `puppet:"value=>true"`
		Idle_timeout                     int64 `puppet:"value=>60"`
		Internal                         *bool
		Ip_address_type                  *string
		Load_balancer_type               string `puppet:"value=>'application'"`
		Name                             *string
		Name_prefix                      *string
		Security_groups                  *[]string
		Subnet_mapping                   *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[allocation_id]=>String,subnet_id=>String]]]"`
		Subnets                          *[]string
		Tags                             *map[string]string
		Vpc_id                           *string
		Zone_id                          *string
	}

	Lb_cookie_stickiness_policy struct {
		Lb_cookie_stickiness_policy_id *string `lyra:"tf-gen.ignore"`
		Cookie_expiration_period       *int64
		Lb_port                        int64
		Load_balancer                  string
		Name                           string
	}

	Lb_listener struct {
		Lb_listener_id    *string `lyra:"tf-gen.ignore"`
		Arn               *string
		Certificate_arn   *string
		Default_action    []map[string]interface{} `puppet:"type => Array[Struct[Optional[authenticate_cognito]=>Struct[Optional[authentication_request_extra_params]=>Hash[String,String],Optional[on_unauthenticated_request]=>String,Optional[scope]=>String,Optional[session_cookie_name]=>String,Optional[session_timeout]=>Integer,user_pool_arn=>String,user_pool_client_id=>String,user_pool_domain=>String],Optional[authenticate_oidc]=>Struct[Optional[authentication_request_extra_params]=>Hash[String,String],authorization_endpoint=>String,client_id=>String,client_secret=>String,issuer=>String,Optional[on_unauthenticated_request]=>String,Optional[scope]=>String,Optional[session_cookie_name]=>String,Optional[session_timeout]=>Integer,token_endpoint=>String,user_info_endpoint=>String],Optional[fixed_response]=>Struct[content_type=>String,Optional[message_body]=>String,Optional[status_code]=>String],Optional[order]=>Integer,Optional[redirect]=>Struct[Optional[host]=>String,Optional[path]=>String,Optional[port]=>String,Optional[protocol]=>String,Optional[query]=>String,status_code=>String],Optional[target_group_arn]=>String,type=>String]]"`
		Load_balancer_arn string
		Port              int64
		Protocol          string `puppet:"value=>'HTTP'"`
		Ssl_policy        *string
	}

	Lb_listener_certificate struct {
		Lb_listener_certificate_id *string `lyra:"tf-gen.ignore"`
		Certificate_arn            string
		Listener_arn               string
	}

	Lb_listener_rule struct {
		Lb_listener_rule_id *string                  `lyra:"tf-gen.ignore"`
		Action              []map[string]interface{} `puppet:"type => Array[Struct[Optional[authenticate_cognito]=>Struct[Optional[authentication_request_extra_params]=>Hash[String,String],Optional[on_unauthenticated_request]=>String,Optional[scope]=>String,Optional[session_cookie_name]=>String,Optional[session_timeout]=>Integer,user_pool_arn=>String,user_pool_client_id=>String,user_pool_domain=>String],Optional[authenticate_oidc]=>Struct[Optional[authentication_request_extra_params]=>Hash[String,String],authorization_endpoint=>String,client_id=>String,client_secret=>String,issuer=>String,Optional[on_unauthenticated_request]=>String,Optional[scope]=>String,Optional[session_cookie_name]=>String,Optional[session_timeout]=>Integer,token_endpoint=>String,user_info_endpoint=>String],Optional[fixed_response]=>Struct[content_type=>String,Optional[message_body]=>String,Optional[status_code]=>String],Optional[order]=>Integer,Optional[redirect]=>Struct[Optional[host]=>String,Optional[path]=>String,Optional[port]=>String,Optional[protocol]=>String,Optional[query]=>String,status_code=>String],Optional[target_group_arn]=>String,type=>String]]"`
		Arn                 *string
		Condition           []map[string]interface{} `puppet:"type => Array[Struct[Optional[field]=>String,Optional[values]=>Array[String,0,1]]]"`
		Listener_arn        string
		Priority            *int64
	}

	Lb_ssl_negotiation_policy struct {
		Lb_ssl_negotiation_policy_id *string              `lyra:"tf-gen.ignore"`
		Attribute                    *[]map[string]string `puppet:"type => Optional[Array[Struct[name=>String,value=>String]]]"`
		Lb_port                      int64
		Load_balancer                string
		Name                         string
	}

	Lb_target_group struct {
		Lb_target_group_id   *string `lyra:"tf-gen.ignore"`
		Arn                  *string
		Arn_suffix           *string
		Deregistration_delay int64                   `puppet:"value=>300"`
		Health_check         *map[string]interface{} `puppet:"type => Optional[Struct[Optional[healthy_threshold]=>Integer,Optional[interval]=>Integer,Optional[matcher]=>String,Optional[path]=>String,Optional[port]=>String,Optional[protocol]=>String,Optional[timeout]=>Integer,Optional[unhealthy_threshold]=>Integer]]"`
		Name                 *string
		Name_prefix          *string
		Port                 *int64
		Protocol             *string
		Proxy_protocol_v2    bool                    `puppet:"value=>false"`
		Slow_start           int64                   `puppet:"value=>0"`
		Stickiness           *map[string]interface{} `puppet:"type => Optional[Struct[Optional[cookie_duration]=>Integer,Optional[enabled]=>Boolean,type=>String]]"`
		Tags                 *map[string]string
		Target_type          string `puppet:"value=>'instance'"`
		Vpc_id               *string
	}

	Lb_target_group_attachment struct {
		Lb_target_group_attachment_id *string `lyra:"tf-gen.ignore"`
		Availability_zone             *string
		Port                          *int64
		Target_group_arn              string
		Target_id                     string
	}

	Licensemanager_association struct {
		Licensemanager_association_id *string `lyra:"tf-gen.ignore"`
		License_configuration_arn     string
		Resource_arn                  string
	}

	Licensemanager_license_configuration struct {
		Licensemanager_license_configuration_id *string `lyra:"tf-gen.ignore"`
		Description                             *string
		License_count                           *int64
		License_count_hard_limit                bool `puppet:"value=>false"`
		License_counting_type                   string
		License_rules                           *[]string
		Name                                    string
		Tags                                    *map[string]string
	}

	Lightsail_domain struct {
		Lightsail_domain_id *string `lyra:"tf-gen.ignore"`
		Arn                 *string
		Domain_name         string
	}

	Lightsail_instance struct {
		Lightsail_instance_id *string `lyra:"tf-gen.ignore"`
		Arn                   *string
		Availability_zone     string
		Blueprint_id          string
		Bundle_id             string
		Cpu_count             *int64
		Created_at            *string
		Ipv6_address          *string
		Is_static_ip          *bool
		Key_pair_name         *string
		Name                  string
		Private_ip_address    *string
		Public_ip_address     *string
		Ram_size              *int64
		User_data             *string
		Username              *string
	}

	Lightsail_key_pair struct {
		Lightsail_key_pair_id *string `lyra:"tf-gen.ignore"`
		Arn                   *string
		Encrypted_fingerprint *string
		Encrypted_private_key *string
		Fingerprint           *string
		Name                  *string
		Name_prefix           *string
		Pgp_key               *string
		Private_key           *string
		Public_key            *string
	}

	Lightsail_static_ip struct {
		Lightsail_static_ip_id *string `lyra:"tf-gen.ignore"`
		Arn                    *string
		Ip_address             *string
		Name                   string
		Support_code           *string
	}

	Lightsail_static_ip_attachment struct {
		Lightsail_static_ip_attachment_id *string `lyra:"tf-gen.ignore"`
		Instance_name                     string
		Static_ip_name                    string
	}

	Load_balancer_backend_server_policy struct {
		Load_balancer_backend_server_policy_id *string `lyra:"tf-gen.ignore"`
		Instance_port                          int64
		Load_balancer_name                     string
		Policy_names                           *[]string
	}

	Load_balancer_listener_policy struct {
		Load_balancer_listener_policy_id *string `lyra:"tf-gen.ignore"`
		Load_balancer_name               string
		Load_balancer_port               int64
		Policy_names                     *[]string
	}

	Load_balancer_policy struct {
		Load_balancer_policy_id *string `lyra:"tf-gen.ignore"`
		Load_balancer_name      string
		Policy_attribute        *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[name]=>String,Optional[value]=>String]]]"`
		Policy_name             string
		Policy_type_name        string
	}

	Macie_member_account_association struct {
		Macie_member_account_association_id *string `lyra:"tf-gen.ignore"`
		Member_account_id                   string
	}

	Macie_s3_bucket_association struct {
		Macie_s3_bucket_association_id *string `lyra:"tf-gen.ignore"`
		Bucket_name                    string
		Classification_type            *map[string]string `puppet:"type => Optional[Struct[Optional[continuous]=>String,Optional[one_time]=>String]]"`
		Member_account_id              *string
		Prefix                         *string
	}

	Main_route_table_association struct {
		Main_route_table_association_id *string `lyra:"tf-gen.ignore"`
		Original_route_table_id         *string
		Route_table_id                  string
		Vpc_id                          string
	}

	Media_package_channel struct {
		Media_package_channel_id *string `lyra:"tf-gen.ignore"`
		Arn                      *string
		Channel_id               string
		Description              string                      `puppet:"value=>'Managed by Terraform'"`
		Hls_ingest               *[]map[string][]interface{} `puppet:"type => Optional[Array[Struct[Optional[ingest_endpoints]=>Array[Struct[Optional[password]=>String,Optional[url]=>String,Optional[username]=>String]]]]]"`
	}

	Media_store_container struct {
		Media_store_container_id *string `lyra:"tf-gen.ignore"`
		Arn                      *string
		Endpoint                 *string
		Name                     string
	}

	Media_store_container_policy struct {
		Media_store_container_policy_id *string `lyra:"tf-gen.ignore"`
		Container_name                  string
		Policy                          string
	}

	Mq_broker struct {
		Mq_broker_id                  *string `lyra:"tf-gen.ignore"`
		Apply_immediately             bool    `puppet:"value=>false"`
		Arn                           *string
		Auto_minor_version_upgrade    bool `puppet:"value=>false"`
		Broker_name                   string
		Configuration                 *map[string]interface{} `puppet:"type => Optional[Struct[Optional[id]=>String,Optional[revision]=>Integer]]"`
		Deployment_mode               string                  `puppet:"value=>'SINGLE_INSTANCE'"`
		Engine_type                   string
		Engine_version                string
		Host_instance_type            string
		Instances                     *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[console_url]=>String,Optional[endpoints]=>Array[String],Optional[ip_address]=>String]]]"`
		Logs                          *map[string]bool          `puppet:"type => Optional[Struct[Optional[audit]=>Boolean,Optional[general]=>Boolean]]"`
		Maintenance_window_start_time *map[string]string        `puppet:"type => Optional[Struct[day_of_week=>String,time_of_day=>String,time_zone=>String]]"`
		Publicly_accessible           bool                      `puppet:"value=>false"`
		Security_groups               []string
		Subnet_ids                    *[]string
		Tags                          *map[string]string
		User                          []map[string]interface{} `puppet:"type => Array[Struct[Optional[console_access]=>Boolean,Optional[groups]=>Array[String],password=>String,username=>String]]"`
	}

	Mq_configuration struct {
		Mq_configuration_id *string `lyra:"tf-gen.ignore"`
		Arn                 *string
		Data                string
		Description         *string
		Engine_type         string
		Engine_version      string
		Latest_revision     *int64
		Name                string
		Tags                *map[string]string
	}

	Nat_gateway struct {
		Nat_gateway_id       *string `lyra:"tf-gen.ignore"`
		Allocation_id        string
		Network_interface_id *string
		Private_ip           *string
		Public_ip            *string
		Subnet_id            string
		Tags                 *map[string]string
	}

	Neptune_cluster struct {
		Neptune_cluster_id                   *string `lyra:"tf-gen.ignore"`
		Apply_immediately                    *bool
		Arn                                  *string
		Availability_zones                   *[]string
		Backup_retention_period              int64 `puppet:"value=>1"`
		Cluster_identifier                   *string
		Cluster_identifier_prefix            *string
		Cluster_members                      *[]string
		Cluster_resource_id                  *string
		Endpoint                             *string
		Engine                               string `puppet:"value=>'neptune'"`
		Engine_version                       *string
		Final_snapshot_identifier            *string
		Hosted_zone_id                       *string
		Iam_database_authentication_enabled  *bool
		Iam_roles                            *[]string
		Kms_key_arn                          *string
		Neptune_cluster_parameter_group_name string `puppet:"value=>'default.neptune1'"`
		Neptune_subnet_group_name            *string
		Port                                 int64 `puppet:"value=>8182"`
		Preferred_backup_window              *string
		Preferred_maintenance_window         *string
		Reader_endpoint                      *string
		Replication_source_identifier        *string
		Skip_final_snapshot                  bool `puppet:"value=>false"`
		Snapshot_identifier                  *string
		Storage_encrypted                    bool `puppet:"value=>false"`
		Tags                                 *map[string]string
		Vpc_security_group_ids               *[]string
	}

	Neptune_cluster_instance struct {
		Neptune_cluster_instance_id  *string `lyra:"tf-gen.ignore"`
		Address                      *string
		Apply_immediately            *bool
		Arn                          *string
		Auto_minor_version_upgrade   bool `puppet:"value=>true"`
		Availability_zone            *string
		Cluster_identifier           string
		Dbi_resource_id              *string
		Endpoint                     *string
		Engine                       string `puppet:"value=>'neptune'"`
		Engine_version               *string
		Identifier                   *string
		Identifier_prefix            *string
		Instance_class               string
		Kms_key_arn                  *string
		Neptune_parameter_group_name string `puppet:"value=>'default.neptune1'"`
		Neptune_subnet_group_name    *string
		Port                         int64 `puppet:"value=>8182"`
		Preferred_backup_window      *string
		Preferred_maintenance_window *string
		Promotion_tier               int64 `puppet:"value=>0"`
		Publicly_accessible          bool  `puppet:"value=>false"`
		Storage_encrypted            *bool
		Tags                         *map[string]string
		Writer                       *bool
	}

	Neptune_cluster_parameter_group struct {
		Neptune_cluster_parameter_group_id *string `lyra:"tf-gen.ignore"`
		Arn                                *string
		Description                        string `puppet:"value=>'Managed by Terraform'"`
		Family                             string
		Name                               *string
		Name_prefix                        *string
		Parameter                          *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[apply_method]=>String,name=>String,value=>String]]]"`
		Tags                               *map[string]string
	}

	Neptune_cluster_snapshot struct {
		Neptune_cluster_snapshot_id    *string `lyra:"tf-gen.ignore"`
		Allocated_storage              *int64
		Availability_zones             *[]string
		Db_cluster_identifier          string
		Db_cluster_snapshot_arn        *string
		Db_cluster_snapshot_identifier string
		Engine                         *string
		Engine_version                 *string
		Kms_key_id                     *string
		License_model                  *string
		Port                           *int64
		Snapshot_type                  *string
		Source_db_cluster_snapshot_arn *string
		Status                         *string
		Storage_encrypted              *bool
		Vpc_id                         *string
	}

	Neptune_event_subscription struct {
		Neptune_event_subscription_id *string `lyra:"tf-gen.ignore"`
		Arn                           *string
		Customer_aws_id               *string
		Enabled                       bool `puppet:"value=>true"`
		Event_categories              *[]string
		Name                          *string
		Name_prefix                   *string
		Sns_topic_arn                 string
		Source_ids                    *[]string
		Source_type                   *string
		Tags                          *map[string]string
	}

	Neptune_parameter_group struct {
		Neptune_parameter_group_id *string `lyra:"tf-gen.ignore"`
		Arn                        *string
		Description                string `puppet:"value=>'Managed by Terraform'"`
		Family                     string
		Name                       string
		Parameter                  *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[apply_method]=>String,name=>String,value=>String]]]"`
		Tags                       *map[string]string
	}

	Neptune_subnet_group struct {
		Neptune_subnet_group_id *string `lyra:"tf-gen.ignore"`
		Arn                     *string
		Description             string `puppet:"value=>'Managed by Terraform'"`
		Name                    *string
		Name_prefix             *string
		Subnet_ids              []string
		Tags                    *map[string]string
	}

	Network_acl struct {
		Network_acl_id *string                   `lyra:"tf-gen.ignore"`
		Egress         *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[action=>String,Optional[cidr_block]=>String,from_port=>Integer,Optional[icmp_code]=>Integer,Optional[icmp_type]=>Integer,Optional[ipv6_cidr_block]=>String,protocol=>String,rule_no=>Integer,to_port=>Integer]]]"`
		Ingress        *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[action=>String,Optional[cidr_block]=>String,from_port=>Integer,Optional[icmp_code]=>Integer,Optional[icmp_type]=>Integer,Optional[ipv6_cidr_block]=>String,protocol=>String,rule_no=>Integer,to_port=>Integer]]]"`
		Owner_id       *string
		Subnet_id      *string
		Subnet_ids     *[]string
		Tags           *map[string]string
		Vpc_id         string
	}

	Network_acl_rule struct {
		Network_acl_rule_id *string `lyra:"tf-gen.ignore"`
		Cidr_block          *string
		Egress              bool `puppet:"value=>false"`
		From_port           *int64
		Icmp_code           *string
		Icmp_type           *string
		Ipv6_cidr_block     *string
		Network_acl_id      string
		Protocol            string
		Rule_action         string
		Rule_number         int64
		To_port             *int64
	}

	Network_interface struct {
		Network_interface_id *string                   `lyra:"tf-gen.ignore"`
		Attachment           *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[attachment_id]=>String,device_index=>Integer,instance=>String]]]"`
		Description          *string
		Private_dns_name     *string
		Private_ip           *string
		Private_ips          *[]string
		Private_ips_count    *int64
		Security_groups      *[]string
		Source_dest_check    bool `puppet:"value=>true"`
		Subnet_id            string
		Tags                 *map[string]string
	}

	Network_interface_attachment struct {
		Network_interface_attachment_id *string `lyra:"tf-gen.ignore"`
		Attachment_id                   *string
		Device_index                    int64
		Instance_id                     string
		Network_interface_id            string
		Status                          *string
	}

	Network_interface_sg_attachment struct {
		Network_interface_sg_attachment_id *string `lyra:"tf-gen.ignore"`
		Network_interface_id               string
		Security_group_id                  string
	}

	Opsworks_application struct {
		Opsworks_application_id   *string              `lyra:"tf-gen.ignore"`
		App_source                *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[password]=>String,Optional[revision]=>String,Optional[ssh_key]=>String,type=>String,Optional[url]=>String,Optional[username]=>String]]]"`
		Auto_bundle_on_deploy     *string
		Aws_flow_ruby_settings    *string
		Data_source_arn           *string
		Data_source_database_name *string
		Data_source_type          *string
		Description               *string
		Document_root             *string
		Domains                   *[]string
		Enable_ssl                bool                      `puppet:"value=>false"`
		Environment               *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[key=>String,Optional[secure]=>Boolean,value=>String]]]"`
		Name                      string
		Rails_env                 *string
		Short_name                *string
		Ssl_configuration         *[]map[string]string `puppet:"type => Optional[Array[Struct[certificate=>String,Optional[chain]=>String,private_key=>String]]]"`
		Stack_id                  string
		Type                      string
	}

	Opsworks_custom_layer struct {
		Opsworks_custom_layer_id    *string `lyra:"tf-gen.ignore"`
		Auto_assign_elastic_ips     bool    `puppet:"value=>false"`
		Auto_assign_public_ips      bool    `puppet:"value=>false"`
		Auto_healing                bool    `puppet:"value=>true"`
		Custom_configure_recipes    *[]string
		Custom_deploy_recipes       *[]string
		Custom_instance_profile_arn *string
		Custom_json                 *string
		Custom_security_group_ids   *[]string
		Custom_setup_recipes        *[]string
		Custom_shutdown_recipes     *[]string
		Custom_undeploy_recipes     *[]string
		Drain_elb_on_shutdown       bool                      `puppet:"value=>true"`
		Ebs_volume                  *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[iops]=>Integer,mount_point=>String,number_of_disks=>Integer,Optional[raid_level]=>String,size=>Integer,Optional[type]=>String]]]"`
		Elastic_load_balancer       *string
		Install_updates_on_boot     bool  `puppet:"value=>true"`
		Instance_shutdown_timeout   int64 `puppet:"value=>120"`
		Name                        string
		Short_name                  string
		Stack_id                    string
		System_packages             *[]string
		Use_ebs_optimized_instances bool `puppet:"value=>false"`
	}

	Opsworks_ganglia_layer struct {
		Opsworks_ganglia_layer_id   *string `lyra:"tf-gen.ignore"`
		Auto_assign_elastic_ips     bool    `puppet:"value=>false"`
		Auto_assign_public_ips      bool    `puppet:"value=>false"`
		Auto_healing                bool    `puppet:"value=>true"`
		Custom_configure_recipes    *[]string
		Custom_deploy_recipes       *[]string
		Custom_instance_profile_arn *string
		Custom_json                 *string
		Custom_security_group_ids   *[]string
		Custom_setup_recipes        *[]string
		Custom_shutdown_recipes     *[]string
		Custom_undeploy_recipes     *[]string
		Drain_elb_on_shutdown       bool                      `puppet:"value=>true"`
		Ebs_volume                  *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[iops]=>Integer,mount_point=>String,number_of_disks=>Integer,Optional[raid_level]=>String,size=>Integer,Optional[type]=>String]]]"`
		Elastic_load_balancer       *string
		Install_updates_on_boot     bool   `puppet:"value=>true"`
		Instance_shutdown_timeout   int64  `puppet:"value=>120"`
		Name                        string `puppet:"value=>'Ganglia'"`
		Password                    string
		Stack_id                    string
		System_packages             *[]string
		Url                         string `puppet:"value=>'/ganglia'"`
		Use_ebs_optimized_instances bool   `puppet:"value=>false"`
		Username                    string `puppet:"value=>'opsworks'"`
	}

	Opsworks_haproxy_layer struct {
		Opsworks_haproxy_layer_id   *string `lyra:"tf-gen.ignore"`
		Auto_assign_elastic_ips     bool    `puppet:"value=>false"`
		Auto_assign_public_ips      bool    `puppet:"value=>false"`
		Auto_healing                bool    `puppet:"value=>true"`
		Custom_configure_recipes    *[]string
		Custom_deploy_recipes       *[]string
		Custom_instance_profile_arn *string
		Custom_json                 *string
		Custom_security_group_ids   *[]string
		Custom_setup_recipes        *[]string
		Custom_shutdown_recipes     *[]string
		Custom_undeploy_recipes     *[]string
		Drain_elb_on_shutdown       bool                      `puppet:"value=>true"`
		Ebs_volume                  *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[iops]=>Integer,mount_point=>String,number_of_disks=>Integer,Optional[raid_level]=>String,size=>Integer,Optional[type]=>String]]]"`
		Elastic_load_balancer       *string
		Healthcheck_method          string `puppet:"value=>'OPTIONS'"`
		Healthcheck_url             string `puppet:"value=>'/'"`
		Install_updates_on_boot     bool   `puppet:"value=>true"`
		Instance_shutdown_timeout   int64  `puppet:"value=>120"`
		Name                        string `puppet:"value=>'HAProxy'"`
		Stack_id                    string
		Stats_enabled               bool `puppet:"value=>true"`
		Stats_password              string
		Stats_url                   string `puppet:"value=>'/haproxy?stats'"`
		Stats_user                  string `puppet:"value=>'opsworks'"`
		System_packages             *[]string
		Use_ebs_optimized_instances bool `puppet:"value=>false"`
	}

	Opsworks_instance struct {
		Opsworks_instance_id         *string `lyra:"tf-gen.ignore"`
		Agent_version                string  `puppet:"value=>'INHERIT'"`
		Ami_id                       *string
		Architecture                 string `puppet:"value=>'x86_64'"`
		Auto_scaling_type            *string
		Availability_zone            *string
		Created_at                   *string
		Delete_ebs                   bool                      `puppet:"value=>true"`
		Delete_eip                   bool                      `puppet:"value=>true"`
		Ebs_block_device             *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[delete_on_termination]=>Boolean,device_name=>String,Optional[iops]=>Integer,Optional[snapshot_id]=>String,Optional[volume_size]=>Integer,Optional[volume_type]=>String]]]"`
		Ebs_optimized                bool                      `puppet:"value=>false"`
		Ec2_instance_id              *string
		Ecs_cluster_arn              *string
		Elastic_ip                   *string
		Ephemeral_block_device       *[]map[string]string `puppet:"type => Optional[Array[Struct[device_name=>String,virtual_name=>String]]]"`
		Hostname                     *string
		Infrastructure_class         *string
		Install_updates_on_boot      bool `puppet:"value=>true"`
		Instance_profile_arn         *string
		Instance_type                *string
		Last_service_error_id        *string
		Layer_ids                    []string
		Os                           *string
		Platform                     *string
		Private_dns                  *string
		Private_ip                   *string
		Public_dns                   *string
		Public_ip                    *string
		Registered_by                *string
		Reported_agent_version       *string
		Reported_os_family           *string
		Reported_os_name             *string
		Reported_os_version          *string
		Root_block_device            *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[delete_on_termination]=>Boolean,Optional[iops]=>Integer,Optional[volume_size]=>Integer,Optional[volume_type]=>String]]]"`
		Root_device_type             *string
		Root_device_volume_id        *string
		Security_group_ids           *[]string
		Ssh_host_dsa_key_fingerprint *string
		Ssh_host_rsa_key_fingerprint *string
		Ssh_key_name                 *string
		Stack_id                     string
		State                        *string
		Status                       *string
		Subnet_id                    *string
		Tenancy                      *string
		Virtualization_type          *string
	}

	Opsworks_java_app_layer struct {
		Opsworks_java_app_layer_id  *string `lyra:"tf-gen.ignore"`
		App_server                  string  `puppet:"value=>'tomcat'"`
		App_server_version          string  `puppet:"value=>'7'"`
		Auto_assign_elastic_ips     bool    `puppet:"value=>false"`
		Auto_assign_public_ips      bool    `puppet:"value=>false"`
		Auto_healing                bool    `puppet:"value=>true"`
		Custom_configure_recipes    *[]string
		Custom_deploy_recipes       *[]string
		Custom_instance_profile_arn *string
		Custom_json                 *string
		Custom_security_group_ids   *[]string
		Custom_setup_recipes        *[]string
		Custom_shutdown_recipes     *[]string
		Custom_undeploy_recipes     *[]string
		Drain_elb_on_shutdown       bool                      `puppet:"value=>true"`
		Ebs_volume                  *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[iops]=>Integer,mount_point=>String,number_of_disks=>Integer,Optional[raid_level]=>String,size=>Integer,Optional[type]=>String]]]"`
		Elastic_load_balancer       *string
		Install_updates_on_boot     bool   `puppet:"value=>true"`
		Instance_shutdown_timeout   int64  `puppet:"value=>120"`
		Jvm_options                 string `puppet:"value=>''"`
		Jvm_type                    string `puppet:"value=>'openjdk'"`
		Jvm_version                 string `puppet:"value=>'7'"`
		Name                        string `puppet:"value=>'Java App Server'"`
		Stack_id                    string
		System_packages             *[]string
		Use_ebs_optimized_instances bool `puppet:"value=>false"`
	}

	Opsworks_memcached_layer struct {
		Opsworks_memcached_layer_id *string `lyra:"tf-gen.ignore"`
		Allocated_memory            int64   `puppet:"value=>512"`
		Auto_assign_elastic_ips     bool    `puppet:"value=>false"`
		Auto_assign_public_ips      bool    `puppet:"value=>false"`
		Auto_healing                bool    `puppet:"value=>true"`
		Custom_configure_recipes    *[]string
		Custom_deploy_recipes       *[]string
		Custom_instance_profile_arn *string
		Custom_json                 *string
		Custom_security_group_ids   *[]string
		Custom_setup_recipes        *[]string
		Custom_shutdown_recipes     *[]string
		Custom_undeploy_recipes     *[]string
		Drain_elb_on_shutdown       bool                      `puppet:"value=>true"`
		Ebs_volume                  *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[iops]=>Integer,mount_point=>String,number_of_disks=>Integer,Optional[raid_level]=>String,size=>Integer,Optional[type]=>String]]]"`
		Elastic_load_balancer       *string
		Install_updates_on_boot     bool   `puppet:"value=>true"`
		Instance_shutdown_timeout   int64  `puppet:"value=>120"`
		Name                        string `puppet:"value=>'Memcached'"`
		Stack_id                    string
		System_packages             *[]string
		Use_ebs_optimized_instances bool `puppet:"value=>false"`
	}

	Opsworks_mysql_layer struct {
		Opsworks_mysql_layer_id        *string `lyra:"tf-gen.ignore"`
		Auto_assign_elastic_ips        bool    `puppet:"value=>false"`
		Auto_assign_public_ips         bool    `puppet:"value=>false"`
		Auto_healing                   bool    `puppet:"value=>true"`
		Custom_configure_recipes       *[]string
		Custom_deploy_recipes          *[]string
		Custom_instance_profile_arn    *string
		Custom_json                    *string
		Custom_security_group_ids      *[]string
		Custom_setup_recipes           *[]string
		Custom_shutdown_recipes        *[]string
		Custom_undeploy_recipes        *[]string
		Drain_elb_on_shutdown          bool                      `puppet:"value=>true"`
		Ebs_volume                     *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[iops]=>Integer,mount_point=>String,number_of_disks=>Integer,Optional[raid_level]=>String,size=>Integer,Optional[type]=>String]]]"`
		Elastic_load_balancer          *string
		Install_updates_on_boot        bool   `puppet:"value=>true"`
		Instance_shutdown_timeout      int64  `puppet:"value=>120"`
		Name                           string `puppet:"value=>'MySQL'"`
		Root_password                  *string
		Root_password_on_all_instances bool `puppet:"value=>true"`
		Stack_id                       string
		System_packages                *[]string
		Use_ebs_optimized_instances    bool `puppet:"value=>false"`
	}

	Opsworks_nodejs_app_layer struct {
		Opsworks_nodejs_app_layer_id *string `lyra:"tf-gen.ignore"`
		Auto_assign_elastic_ips      bool    `puppet:"value=>false"`
		Auto_assign_public_ips       bool    `puppet:"value=>false"`
		Auto_healing                 bool    `puppet:"value=>true"`
		Custom_configure_recipes     *[]string
		Custom_deploy_recipes        *[]string
		Custom_instance_profile_arn  *string
		Custom_json                  *string
		Custom_security_group_ids    *[]string
		Custom_setup_recipes         *[]string
		Custom_shutdown_recipes      *[]string
		Custom_undeploy_recipes      *[]string
		Drain_elb_on_shutdown        bool                      `puppet:"value=>true"`
		Ebs_volume                   *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[iops]=>Integer,mount_point=>String,number_of_disks=>Integer,Optional[raid_level]=>String,size=>Integer,Optional[type]=>String]]]"`
		Elastic_load_balancer        *string
		Install_updates_on_boot      bool   `puppet:"value=>true"`
		Instance_shutdown_timeout    int64  `puppet:"value=>120"`
		Name                         string `puppet:"value=>'Node.js App Server'"`
		Nodejs_version               string `puppet:"value=>'0.10.38'"`
		Stack_id                     string
		System_packages              *[]string
		Use_ebs_optimized_instances  bool `puppet:"value=>false"`
	}

	Opsworks_permission struct {
		Opsworks_permission_id *string `lyra:"tf-gen.ignore"`
		Allow_ssh              *bool
		Allow_sudo             *bool
		Level                  *string
		Stack_id               *string
		User_arn               string
	}

	Opsworks_php_app_layer struct {
		Opsworks_php_app_layer_id   *string `lyra:"tf-gen.ignore"`
		Auto_assign_elastic_ips     bool    `puppet:"value=>false"`
		Auto_assign_public_ips      bool    `puppet:"value=>false"`
		Auto_healing                bool    `puppet:"value=>true"`
		Custom_configure_recipes    *[]string
		Custom_deploy_recipes       *[]string
		Custom_instance_profile_arn *string
		Custom_json                 *string
		Custom_security_group_ids   *[]string
		Custom_setup_recipes        *[]string
		Custom_shutdown_recipes     *[]string
		Custom_undeploy_recipes     *[]string
		Drain_elb_on_shutdown       bool                      `puppet:"value=>true"`
		Ebs_volume                  *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[iops]=>Integer,mount_point=>String,number_of_disks=>Integer,Optional[raid_level]=>String,size=>Integer,Optional[type]=>String]]]"`
		Elastic_load_balancer       *string
		Install_updates_on_boot     bool   `puppet:"value=>true"`
		Instance_shutdown_timeout   int64  `puppet:"value=>120"`
		Name                        string `puppet:"value=>'PHP App Server'"`
		Stack_id                    string
		System_packages             *[]string
		Use_ebs_optimized_instances bool `puppet:"value=>false"`
	}

	Opsworks_rails_app_layer struct {
		Opsworks_rails_app_layer_id *string `lyra:"tf-gen.ignore"`
		App_server                  string  `puppet:"value=>'apache_passenger'"`
		Auto_assign_elastic_ips     bool    `puppet:"value=>false"`
		Auto_assign_public_ips      bool    `puppet:"value=>false"`
		Auto_healing                bool    `puppet:"value=>true"`
		Bundler_version             string  `puppet:"value=>'1.5.3'"`
		Custom_configure_recipes    *[]string
		Custom_deploy_recipes       *[]string
		Custom_instance_profile_arn *string
		Custom_json                 *string
		Custom_security_group_ids   *[]string
		Custom_setup_recipes        *[]string
		Custom_shutdown_recipes     *[]string
		Custom_undeploy_recipes     *[]string
		Drain_elb_on_shutdown       bool                      `puppet:"value=>true"`
		Ebs_volume                  *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[iops]=>Integer,mount_point=>String,number_of_disks=>Integer,Optional[raid_level]=>String,size=>Integer,Optional[type]=>String]]]"`
		Elastic_load_balancer       *string
		Install_updates_on_boot     bool   `puppet:"value=>true"`
		Instance_shutdown_timeout   int64  `puppet:"value=>120"`
		Manage_bundler              bool   `puppet:"value=>true"`
		Name                        string `puppet:"value=>'Rails App Server'"`
		Passenger_version           string `puppet:"value=>'4.0.46'"`
		Ruby_version                string `puppet:"value=>'2.0.0'"`
		Rubygems_version            string `puppet:"value=>'2.2.2'"`
		Stack_id                    string
		System_packages             *[]string
		Use_ebs_optimized_instances bool `puppet:"value=>false"`
	}

	Opsworks_rds_db_instance struct {
		Opsworks_rds_db_instance_id *string `lyra:"tf-gen.ignore"`
		Db_password                 string
		Db_user                     string
		Rds_db_instance_arn         string
		Stack_id                    string
	}

	Opsworks_stack struct {
		Opsworks_stack_id             *string `lyra:"tf-gen.ignore"`
		Agent_version                 *string
		Arn                           *string
		Berkshelf_version             string `puppet:"value=>'3.2.0'"`
		Color                         *string
		Configuration_manager_name    string               `puppet:"value=>'Chef'"`
		Configuration_manager_version string               `puppet:"value=>'11.10'"`
		Custom_cookbooks_source       *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[password]=>String,Optional[revision]=>String,Optional[ssh_key]=>String,type=>String,url=>String,Optional[username]=>String]]]"`
		Custom_json                   *string
		Default_availability_zone     *string
		Default_instance_profile_arn  string
		Default_os                    string `puppet:"value=>'Ubuntu 12.04 LTS'"`
		Default_root_device_type      string `puppet:"value=>'instance-store'"`
		Default_ssh_key_name          *string
		Default_subnet_id             *string
		Hostname_theme                string `puppet:"value=>'Layer_Dependent'"`
		Manage_berkshelf              bool   `puppet:"value=>false"`
		Name                          string
		Region                        string
		Service_role_arn              string
		Stack_endpoint                *string
		Tags                          *map[string]string
		Use_custom_cookbooks          bool `puppet:"value=>false"`
		Use_opsworks_security_groups  bool `puppet:"value=>true"`
		Vpc_id                        *string
	}

	Opsworks_static_web_layer struct {
		Opsworks_static_web_layer_id *string `lyra:"tf-gen.ignore"`
		Auto_assign_elastic_ips      bool    `puppet:"value=>false"`
		Auto_assign_public_ips       bool    `puppet:"value=>false"`
		Auto_healing                 bool    `puppet:"value=>true"`
		Custom_configure_recipes     *[]string
		Custom_deploy_recipes        *[]string
		Custom_instance_profile_arn  *string
		Custom_json                  *string
		Custom_security_group_ids    *[]string
		Custom_setup_recipes         *[]string
		Custom_shutdown_recipes      *[]string
		Custom_undeploy_recipes      *[]string
		Drain_elb_on_shutdown        bool                      `puppet:"value=>true"`
		Ebs_volume                   *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[iops]=>Integer,mount_point=>String,number_of_disks=>Integer,Optional[raid_level]=>String,size=>Integer,Optional[type]=>String]]]"`
		Elastic_load_balancer        *string
		Install_updates_on_boot      bool   `puppet:"value=>true"`
		Instance_shutdown_timeout    int64  `puppet:"value=>120"`
		Name                         string `puppet:"value=>'Static Web Server'"`
		Stack_id                     string
		System_packages              *[]string
		Use_ebs_optimized_instances  bool `puppet:"value=>false"`
	}

	Opsworks_user_profile struct {
		Opsworks_user_profile_id *string `lyra:"tf-gen.ignore"`
		Allow_self_management    bool    `puppet:"value=>false"`
		Ssh_public_key           *string
		Ssh_username             string
		User_arn                 string
	}

	Organizations_account struct {
		Organizations_account_id   *string `lyra:"tf-gen.ignore"`
		Arn                        *string
		Email                      string
		Iam_user_access_to_billing *string
		Joined_method              *string
		Joined_timestamp           *string
		Name                       string
		Role_name                  *string
		Status                     *string
	}

	Organizations_organization struct {
		Organizations_organization_id *string `lyra:"tf-gen.ignore"`
		Arn                           *string
		Aws_service_access_principals *[]string
		Feature_set                   string `puppet:"value=>'ALL'"`
		Master_account_arn            *string
		Master_account_email          *string
		Master_account_id             *string
	}

	Organizations_policy struct {
		Organizations_policy_id *string `lyra:"tf-gen.ignore"`
		Arn                     *string
		Content                 string
		Description             *string
		Name                    string
		Type                    string `puppet:"value=>'SERVICE_CONTROL_POLICY'"`
	}

	Organizations_policy_attachment struct {
		Organizations_policy_attachment_id *string `lyra:"tf-gen.ignore"`
		Policy_id                          string
		Target_id                          string
	}

	Pinpoint_adm_channel struct {
		Pinpoint_adm_channel_id *string `lyra:"tf-gen.ignore"`
		Application_id          string
		Client_id               string
		Client_secret           string
		Enabled                 bool `puppet:"value=>true"`
	}

	Pinpoint_apns_channel struct {
		Pinpoint_apns_channel_id      *string `lyra:"tf-gen.ignore"`
		Application_id                string
		Bundle_id                     *string
		Certificate                   *string
		Default_authentication_method *string
		Enabled                       bool `puppet:"value=>true"`
		Private_key                   *string
		Team_id                       *string
		Token_key                     *string
		Token_key_id                  *string
	}

	Pinpoint_apns_sandbox_channel struct {
		Pinpoint_apns_sandbox_channel_id *string `lyra:"tf-gen.ignore"`
		Application_id                   string
		Bundle_id                        *string
		Certificate                      *string
		Default_authentication_method    *string
		Enabled                          bool `puppet:"value=>true"`
		Private_key                      *string
		Team_id                          *string
		Token_key                        *string
		Token_key_id                     *string
	}

	Pinpoint_apns_voip_channel struct {
		Pinpoint_apns_voip_channel_id *string `lyra:"tf-gen.ignore"`
		Application_id                string
		Bundle_id                     *string
		Certificate                   *string
		Default_authentication_method *string
		Enabled                       bool `puppet:"value=>true"`
		Private_key                   *string
		Team_id                       *string
		Token_key                     *string
		Token_key_id                  *string
	}

	Pinpoint_apns_voip_sandbox_channel struct {
		Pinpoint_apns_voip_sandbox_channel_id *string `lyra:"tf-gen.ignore"`
		Application_id                        string
		Bundle_id                             *string
		Certificate                           *string
		Default_authentication_method         *string
		Enabled                               bool `puppet:"value=>true"`
		Private_key                           *string
		Team_id                               *string
		Token_key                             *string
		Token_key_id                          *string
	}

	Pinpoint_app struct {
		Pinpoint_app_id *string `lyra:"tf-gen.ignore"`
		Application_id  *string
		Campaign_hook   *map[string]string `puppet:"type => Optional[Struct[Optional[lambda_function_name]=>String,Optional[mode]=>String,Optional[web_url]=>String]]"`
		Limits          *map[string]int64  `puppet:"type => Optional[Struct[Optional[daily]=>Integer,Optional[maximum_duration]=>Integer,Optional[messages_per_second]=>Integer,Optional[total]=>Integer]]"`
		Name            *string
		Name_prefix     *string
		Quiet_time      *map[string]string `puppet:"type => Optional[Struct[Optional[end]=>String,Optional[start]=>String]]"`
	}

	Pinpoint_baidu_channel struct {
		Pinpoint_baidu_channel_id *string `lyra:"tf-gen.ignore"`
		Api_key                   string
		Application_id            string
		Enabled                   bool `puppet:"value=>true"`
		Secret_key                string
	}

	Pinpoint_email_channel struct {
		Pinpoint_email_channel_id *string `lyra:"tf-gen.ignore"`
		Application_id            string
		Enabled                   bool `puppet:"value=>true"`
		From_address              string
		Identity                  string
		Messages_per_second       *int64
		Role_arn                  string
	}

	Pinpoint_event_stream struct {
		Pinpoint_event_stream_id *string `lyra:"tf-gen.ignore"`
		Application_id           string
		Destination_stream_arn   string
		Role_arn                 string
	}

	Pinpoint_gcm_channel struct {
		Pinpoint_gcm_channel_id *string `lyra:"tf-gen.ignore"`
		Api_key                 string
		Application_id          string
		Enabled                 bool `puppet:"value=>true"`
	}

	Pinpoint_sms_channel struct {
		Pinpoint_sms_channel_id           *string `lyra:"tf-gen.ignore"`
		Application_id                    string
		Enabled                           bool `puppet:"value=>true"`
		Promotional_messages_per_second   *int64
		Sender_id                         *string
		Short_code                        *string
		Transactional_messages_per_second *int64
	}

	Placement_group struct {
		Placement_group_id *string `lyra:"tf-gen.ignore"`
		Name               string
		Strategy           string
	}

	Proxy_protocol_policy struct {
		Proxy_protocol_policy_id *string `lyra:"tf-gen.ignore"`
		Instance_ports           []string
		Load_balancer            string
	}

	Ram_resource_share struct {
		Ram_resource_share_id     *string `lyra:"tf-gen.ignore"`
		Allow_external_principals bool    `puppet:"value=>false"`
		Name                      string
		Tags                      *map[string]string
	}

	Rds_cluster struct {
		Rds_cluster_id                      *string `lyra:"tf-gen.ignore"`
		Apply_immediately                   *bool
		Arn                                 *string
		Availability_zones                  *[]string
		Backtrack_window                    *int64
		Backup_retention_period             int64 `puppet:"value=>1"`
		Cluster_identifier                  *string
		Cluster_identifier_prefix           *string
		Cluster_members                     *[]string
		Cluster_resource_id                 *string
		Database_name                       *string
		Db_cluster_parameter_group_name     *string
		Db_subnet_group_name                *string
		Deletion_protection                 *bool
		Enabled_cloudwatch_logs_exports     *[]string
		Endpoint                            *string
		Engine                              string `puppet:"value=>'aurora'"`
		Engine_mode                         string `puppet:"value=>'provisioned'"`
		Engine_version                      *string
		Final_snapshot_identifier           *string
		Global_cluster_identifier           *string
		Hosted_zone_id                      *string
		Iam_database_authentication_enabled *bool
		Iam_roles                           *[]string
		Kms_key_id                          *string
		Master_password                     *string
		Master_username                     *string
		Port                                *int64
		Preferred_backup_window             *string
		Preferred_maintenance_window        *string
		Reader_endpoint                     *string
		Replication_source_identifier       *string
		S3_import                           *map[string]string      `puppet:"type => Optional[Struct[bucket_name=>String,Optional[bucket_prefix]=>String,ingestion_role=>String,source_engine=>String,source_engine_version=>String]]"`
		Scaling_configuration               *map[string]interface{} `puppet:"type => Optional[Struct[Optional[auto_pause]=>Boolean,Optional[max_capacity]=>Integer,Optional[min_capacity]=>Integer,Optional[seconds_until_auto_pause]=>Integer]]"`
		Skip_final_snapshot                 bool                    `puppet:"value=>false"`
		Snapshot_identifier                 *string
		Source_region                       *string
		Storage_encrypted                   *bool
		Tags                                *map[string]string
		Vpc_security_group_ids              *[]string
	}

	Rds_cluster_endpoint struct {
		Rds_cluster_endpoint_id     *string `lyra:"tf-gen.ignore"`
		Arn                         *string
		Cluster_endpoint_identifier string
		Cluster_identifier          string
		Custom_endpoint_type        string
		Endpoint                    *string
		Excluded_members            *[]string
		Static_members              *[]string
	}

	Rds_cluster_instance struct {
		Rds_cluster_instance_id         *string `lyra:"tf-gen.ignore"`
		Apply_immediately               *bool
		Arn                             *string
		Auto_minor_version_upgrade      bool `puppet:"value=>true"`
		Availability_zone               *string
		Cluster_identifier              string
		Copy_tags_to_snapshot           bool `puppet:"value=>false"`
		Db_parameter_group_name         *string
		Db_subnet_group_name            *string
		Dbi_resource_id                 *string
		Endpoint                        *string
		Engine                          string `puppet:"value=>'aurora'"`
		Engine_version                  *string
		Identifier                      *string
		Identifier_prefix               *string
		Instance_class                  string
		Kms_key_id                      *string
		Monitoring_interval             int64 `puppet:"value=>0"`
		Monitoring_role_arn             *string
		Performance_insights_enabled    *bool
		Performance_insights_kms_key_id *string
		Port                            *int64
		Preferred_backup_window         *string
		Preferred_maintenance_window    *string
		Promotion_tier                  int64 `puppet:"value=>0"`
		Publicly_accessible             bool  `puppet:"value=>false"`
		Storage_encrypted               *bool
		Tags                            *map[string]string
		Writer                          *bool
	}

	Rds_cluster_parameter_group struct {
		Rds_cluster_parameter_group_id *string `lyra:"tf-gen.ignore"`
		Arn                            *string
		Description                    string `puppet:"value=>'Managed by Terraform'"`
		Family                         string
		Name                           *string
		Name_prefix                    *string
		Parameter                      *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[apply_method]=>String,name=>String,value=>String]]]"`
		Tags                           *map[string]string
	}

	Rds_global_cluster struct {
		Rds_global_cluster_id      *string `lyra:"tf-gen.ignore"`
		Arn                        *string
		Database_name              *string
		Deletion_protection        bool   `puppet:"value=>false"`
		Engine                     string `puppet:"value=>'aurora'"`
		Engine_version             *string
		Global_cluster_identifier  string
		Global_cluster_resource_id *string
		Storage_encrypted          *bool
	}

	Redshift_cluster struct {
		Redshift_cluster_id                 *string `lyra:"tf-gen.ignore"`
		Allow_version_upgrade               bool    `puppet:"value=>true"`
		Automated_snapshot_retention_period int64   `puppet:"value=>1"`
		Availability_zone                   *string
		Bucket_name                         *string
		Cluster_identifier                  string
		Cluster_parameter_group_name        *string
		Cluster_public_key                  *string
		Cluster_revision_number             *string
		Cluster_security_groups             *[]string
		Cluster_subnet_group_name           *string
		Cluster_type                        *string
		Cluster_version                     string `puppet:"value=>'1.0'"`
		Database_name                       *string
		Dns_name                            *string
		Elastic_ip                          *string
		Enable_logging                      *bool
		Encrypted                           bool `puppet:"value=>false"`
		Endpoint                            *string
		Enhanced_vpc_routing                *bool
		Final_snapshot_identifier           *string
		Iam_roles                           *[]string
		Kms_key_id                          *string
		Logging                             *map[string]interface{} `puppet:"type => Optional[Struct[Optional[bucket_name]=>String,enable=>Boolean,Optional[s3_key_prefix]=>String]]"`
		Master_password                     *string
		Master_username                     *string
		Node_type                           string
		Number_of_nodes                     int64 `puppet:"value=>1"`
		Owner_account                       *string
		Port                                int64 `puppet:"value=>5439"`
		Preferred_maintenance_window        *string
		Publicly_accessible                 bool `puppet:"value=>true"`
		S3_key_prefix                       *string
		Skip_final_snapshot                 bool `puppet:"value=>false"`
		Snapshot_cluster_identifier         *string
		Snapshot_copy                       *map[string]interface{} `puppet:"type => Optional[Struct[destination_region=>String,Optional[grant_name]=>String,Optional[retention_period]=>Integer]]"`
		Snapshot_identifier                 *string
		Tags                                *map[string]string
		Vpc_security_group_ids              *[]string
	}

	Redshift_event_subscription struct {
		Redshift_event_subscription_id *string `lyra:"tf-gen.ignore"`
		Customer_aws_id                *string
		Enabled                        bool `puppet:"value=>true"`
		Event_categories               *[]string
		Name                           string
		Severity                       *string
		Sns_topic_arn                  string
		Source_ids                     *[]string
		Source_type                    *string
		Status                         *string
		Tags                           *map[string]string
	}

	Redshift_parameter_group struct {
		Redshift_parameter_group_id *string `lyra:"tf-gen.ignore"`
		Description                 string  `puppet:"value=>'Managed by Terraform'"`
		Family                      string
		Name                        string
		Parameter                   *[]map[string]string `puppet:"type => Optional[Array[Struct[name=>String,value=>String]]]"`
	}

	Redshift_security_group struct {
		Redshift_security_group_id *string             `lyra:"tf-gen.ignore"`
		Description                string              `puppet:"value=>'Managed by Terraform'"`
		Ingress                    []map[string]string `puppet:"type => Array[Struct[Optional[cidr]=>String,Optional[security_group_name]=>String,Optional[security_group_owner_id]=>String]]"`
		Name                       string
	}

	Redshift_snapshot_copy_grant struct {
		Redshift_snapshot_copy_grant_id *string `lyra:"tf-gen.ignore"`
		Kms_key_id                      *string
		Snapshot_copy_grant_name        string
		Tags                            *map[string]string
	}

	Redshift_subnet_group struct {
		Redshift_subnet_group_id *string `lyra:"tf-gen.ignore"`
		Description              string  `puppet:"value=>'Managed by Terraform'"`
		Name                     string
		Subnet_ids               []string
		Tags                     *map[string]string
	}

	Resourcegroups_group struct {
		Resourcegroups_group_id *string `lyra:"tf-gen.ignore"`
		Arn                     *string
		Description             *string
		Name                    string
		Resource_query          map[string]string `puppet:"type => Struct[query=>String,Optional[type]=>String]"`
	}

	Route struct {
		Route_id                    *string `lyra:"tf-gen.ignore"`
		Destination_cidr_block      *string
		Destination_ipv6_cidr_block *string
		Destination_prefix_list_id  *string
		Egress_only_gateway_id      *string
		Gateway_id                  *string
		Instance_id                 *string
		Instance_owner_id           *string
		Nat_gateway_id              *string
		Network_interface_id        *string
		Origin                      *string
		Route_table_id              string
		State                       *string
		Transit_gateway_id          *string
		Vpc_peering_connection_id   *string
	}

	Route53_delegation_set struct {
		Route53_delegation_set_id *string `lyra:"tf-gen.ignore"`
		Name_servers              *[]string
		Reference_name            *string
	}

	Route53_health_check struct {
		Route53_health_check_id         *string `lyra:"tf-gen.ignore"`
		Child_health_threshold          *int64
		Child_healthchecks              *[]string
		Cloudwatch_alarm_name           *string
		Cloudwatch_alarm_region         *string
		Enable_sni                      *bool
		Failure_threshold               *int64
		Fqdn                            *string
		Insufficient_data_health_status *string
		Invert_healthcheck              *bool
		Ip_address                      *string
		Measure_latency                 bool `puppet:"value=>false"`
		Port                            *int64
		Reference_name                  *string
		Regions                         *[]string
		Request_interval                *int64
		Resource_path                   *string
		Search_string                   *string
		Tags                            *map[string]string
		Type                            string
	}

	Route53_query_log struct {
		Route53_query_log_id     *string `lyra:"tf-gen.ignore"`
		Cloudwatch_log_group_arn string
		Zone_id                  string
	}

	Route53_record struct {
		Route53_record_id                *string                   `lyra:"tf-gen.ignore"`
		Alias                            *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[evaluate_target_health=>Boolean,name=>String,zone_id=>String]]]"`
		Allow_overwrite                  bool                      `puppet:"value=>true"`
		Failover                         *string
		Failover_routing_policy          *[]map[string]string `puppet:"type => Optional[Array[Struct[type=>String]]]"`
		Fqdn                             *string
		Geolocation_routing_policy       *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[continent]=>String,Optional[country]=>String,Optional[subdivision]=>String]]]"`
		Health_check_id                  *string
		Latency_routing_policy           *[]map[string]string `puppet:"type => Optional[Array[Struct[region=>String]]]"`
		Multivalue_answer_routing_policy *bool
		Name                             string
		Records                          *[]string
		Set_identifier                   *string
		Ttl                              *int64
		Type                             string
		Weight                           *int64
		Weighted_routing_policy          *[]map[string]int64 `puppet:"type => Optional[Array[Struct[weight=>Integer]]]"`
		Zone_id                          string
	}

	Route53_zone struct {
		Route53_zone_id   *string `lyra:"tf-gen.ignore"`
		Comment           string  `puppet:"value=>'Managed by Terraform'"`
		Delegation_set_id *string
		Force_destroy     bool `puppet:"value=>false"`
		Name              string
		Name_servers      *[]string
		Tags              *map[string]string
		Vpc               *[]map[string]string `puppet:"type => Optional[Array[Struct[vpc_id=>String,Optional[vpc_region]=>String],1]]"`
		Vpc_id            *string
		Vpc_region        *string
		Zone_id           *string
	}

	Route53_zone_association struct {
		Route53_zone_association_id *string `lyra:"tf-gen.ignore"`
		Vpc_id                      string
		Vpc_region                  *string
		Zone_id                     string
	}

	Route_table struct {
		Route_table_id   *string `lyra:"tf-gen.ignore"`
		Owner_id         *string
		Propagating_vgws *[]string
		Route            *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[cidr_block]=>String,Optional[egress_only_gateway_id]=>String,Optional[gateway_id]=>String,Optional[instance_id]=>String,Optional[ipv6_cidr_block]=>String,Optional[nat_gateway_id]=>String,Optional[network_interface_id]=>String,Optional[transit_gateway_id]=>String,Optional[vpc_peering_connection_id]=>String]]]"`
		Tags             *map[string]string
		Vpc_id           string
	}

	Route_table_association struct {
		Route_table_association_id *string `lyra:"tf-gen.ignore"`
		Route_table_id             string
		Subnet_id                  string
	}

	S3_account_public_access_block struct {
		S3_account_public_access_block_id *string `lyra:"tf-gen.ignore"`
		Account_id                        *string
		Block_public_acls                 bool `puppet:"value=>false"`
		Block_public_policy               bool `puppet:"value=>false"`
		Ignore_public_acls                bool `puppet:"value=>false"`
		Restrict_public_buckets           bool `puppet:"value=>false"`
	}

	S3_bucket struct {
		S3_bucket_id                         *string `lyra:"tf-gen.ignore"`
		Acceleration_status                  *string
		Acl                                  string `puppet:"value=>'private'"`
		Arn                                  *string
		Bucket                               *string
		Bucket_domain_name                   *string
		Bucket_prefix                        *string
		Bucket_regional_domain_name          *string
		Cors_rule                            *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[allowed_headers]=>Array[String],allowed_methods=>Array[String],allowed_origins=>Array[String],Optional[expose_headers]=>Array[String],Optional[max_age_seconds]=>Integer]]]"`
		Force_destroy                        bool                      `puppet:"value=>false"`
		Hosted_zone_id                       *string
		Lifecycle_rule                       *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[abort_incomplete_multipart_upload_days]=>Integer,enabled=>Boolean,Optional[expiration]=>Array[Struct[Optional[date]=>String,Optional[days]=>Integer,Optional[expired_object_delete_marker]=>Boolean]],Optional[id]=>String,Optional[noncurrent_version_expiration]=>Array[Struct[Optional[days]=>Integer]],Optional[noncurrent_version_transition]=>Array[Struct[Optional[days]=>Integer,storage_class=>String]],Optional[prefix]=>String,Optional[tags]=>Hash[String,String],Optional[transition]=>Array[Struct[Optional[date]=>String,Optional[days]=>Integer,storage_class=>String]]]]]"`
		Logging                              *[]map[string]string      `puppet:"type => Optional[Array[Struct[target_bucket=>String,Optional[target_prefix]=>String]]]"`
		Object_lock_configuration            *map[string]interface{}   `puppet:"type => Optional[Struct[object_lock_enabled=>String,Optional[rule]=>Struct[default_retention=>Struct[Optional[days]=>Integer,mode=>String,Optional[years]=>Integer]]]]"`
		Policy                               *string
		Region                               *string
		Replication_configuration            *map[string]interface{} `puppet:"type => Optional[Struct[role=>String,rules=>Array[Struct[destination=>Struct[Optional[access_control_translation]=>Struct[owner=>String],Optional[account_id]=>String,bucket=>String,Optional[replica_kms_key_id]=>String,Optional[storage_class]=>String],Optional[filter]=>Struct[Optional[prefix]=>String,Optional[tags]=>Hash[String,String]],Optional[id]=>String,Optional[prefix]=>String,Optional[priority]=>Integer,Optional[source_selection_criteria]=>Struct[Optional[sse_kms_encrypted_objects]=>Struct[enabled=>Boolean]],status=>String]]]]"`
		Request_payer                        *string
		Server_side_encryption_configuration *map[string][]interface{} `puppet:"type => Optional[Struct[rule=>Struct[apply_server_side_encryption_by_default=>Struct[Optional[kms_master_key_id]=>String,sse_algorithm=>String]]]]"`
		Tags                                 *map[string]string
		Versioning                           *map[string]bool   `puppet:"type => Optional[Struct[Optional[enabled]=>Boolean,Optional[mfa_delete]=>Boolean]]"`
		Website                              *map[string]string `puppet:"type => Optional[Struct[Optional[error_document]=>String,Optional[index_document]=>String,Optional[redirect_all_requests_to]=>String,Optional[routing_rules]=>String]]"`
		Website_domain                       *string
		Website_endpoint                     *string
	}

	S3_bucket_inventory struct {
		S3_bucket_inventory_id   *string `lyra:"tf-gen.ignore"`
		Bucket                   string
		Destination              map[string][]interface{} `puppet:"type => Struct[bucket=>Struct[Optional[account_id]=>String,bucket_arn=>String,Optional[encryption]=>Struct[Optional[sse_kms]=>Struct[key_id=>String],Optional[sse_s3]=>Struct[]],format=>String,Optional[prefix]=>String]]"`
		Enabled                  bool                     `puppet:"value=>true"`
		Filter                   *map[string]string       `puppet:"type => Optional[Struct[Optional[prefix]=>String]]"`
		Included_object_versions string
		Name                     string
		Optional_fields          *[]string
		Schedule                 map[string]string `puppet:"type => Struct[frequency=>String]"`
	}

	S3_bucket_metric struct {
		S3_bucket_metric_id *string `lyra:"tf-gen.ignore"`
		Bucket              string
		Filter              *map[string]interface{} `puppet:"type => Optional[Struct[Optional[prefix]=>String,Optional[tags]=>Hash[String,String]]]"`
		Name                string
	}

	S3_bucket_notification struct {
		S3_bucket_notification_id *string `lyra:"tf-gen.ignore"`
		Bucket                    string
		Lambda_function           *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[events=>Array[String],Optional[filter_prefix]=>String,Optional[filter_suffix]=>String,Optional[id]=>String,Optional[lambda_function_arn]=>String]]]"`
		Queue                     *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[events=>Array[String],Optional[filter_prefix]=>String,Optional[filter_suffix]=>String,Optional[id]=>String,queue_arn=>String]]]"`
		Topic                     *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[events=>Array[String],Optional[filter_prefix]=>String,Optional[filter_suffix]=>String,Optional[id]=>String,topic_arn=>String]]]"`
	}

	S3_bucket_object struct {
		S3_bucket_object_id    *string `lyra:"tf-gen.ignore"`
		Acl                    string  `puppet:"value=>'private'"`
		Bucket                 string
		Cache_control          *string
		Content                *string
		Content_base64         *string
		Content_disposition    *string
		Content_encoding       *string
		Content_language       *string
		Content_type           *string
		Etag                   *string
		Key                    string
		Kms_key_id             *string
		Server_side_encryption *string
		Source                 *string
		Storage_class          *string
		Tags                   *map[string]string
		Version_id             *string
		Website_redirect       *string
	}

	S3_bucket_policy struct {
		S3_bucket_policy_id *string `lyra:"tf-gen.ignore"`
		Bucket              string
		Policy              string
	}

	S3_bucket_public_access_block struct {
		S3_bucket_public_access_block_id *string `lyra:"tf-gen.ignore"`
		Block_public_acls                bool    `puppet:"value=>false"`
		Block_public_policy              bool    `puppet:"value=>false"`
		Bucket                           string
		Ignore_public_acls               bool `puppet:"value=>false"`
		Restrict_public_buckets          bool `puppet:"value=>false"`
	}

	Sagemaker_notebook_instance struct {
		Sagemaker_notebook_instance_id *string `lyra:"tf-gen.ignore"`
		Arn                            *string
		Instance_type                  string
		Kms_key_id                     *string
		Name                           string
		Role_arn                       string
		Security_groups                *[]string
		Subnet_id                      *string
		Tags                           *map[string]string
	}

	Secretsmanager_secret struct {
		Secretsmanager_secret_id *string `lyra:"tf-gen.ignore"`
		Arn                      *string
		Description              *string
		Kms_key_id               *string
		Name                     *string
		Name_prefix              *string
		Policy                   *string
		Recovery_window_in_days  int64 `puppet:"value=>30"`
		Rotation_enabled         *bool
		Rotation_lambda_arn      *string
		Rotation_rules           *map[string]int64 `puppet:"type => Optional[Struct[automatically_after_days=>Integer]]"`
		Tags                     *map[string]string
	}

	Secretsmanager_secret_version struct {
		Secretsmanager_secret_version_id *string `lyra:"tf-gen.ignore"`
		Arn                              *string
		Secret_binary                    *string
		Secret_id                        string
		Secret_string                    *string
		Version_id                       *string
		Version_stages                   *[]string
	}

	Security_group struct {
		Security_group_id      *string `lyra:"tf-gen.ignore"`
		Arn                    *string
		Description            string                    `puppet:"value=>'Managed by Terraform'"`
		Egress                 *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[cidr_blocks]=>Array[String],Optional[description]=>String,from_port=>Integer,Optional[ipv6_cidr_blocks]=>Array[String],Optional[prefix_list_ids]=>Array[String],protocol=>String,Optional[security_groups]=>Array[String],Optional[self]=>Boolean,to_port=>Integer]]]"`
		Ingress                *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[cidr_blocks]=>Array[String],Optional[description]=>String,from_port=>Integer,Optional[ipv6_cidr_blocks]=>Array[String],Optional[prefix_list_ids]=>Array[String],protocol=>String,Optional[security_groups]=>Array[String],Optional[self]=>Boolean,to_port=>Integer]]]"`
		Name                   *string
		Name_prefix            *string
		Owner_id               *string
		Revoke_rules_on_delete bool `puppet:"value=>false"`
		Tags                   *map[string]string
		Vpc_id                 *string
	}

	Security_group_rule struct {
		Security_group_rule_id   *string `lyra:"tf-gen.ignore"`
		Cidr_blocks              *[]string
		Description              *string
		From_port                int64
		Ipv6_cidr_blocks         *[]string
		Prefix_list_ids          *[]string
		Protocol                 string
		Security_group_id        string
		Self                     bool `puppet:"value=>false"`
		Source_security_group_id *string
		To_port                  int64
		Type                     string
	}

	Securityhub_account struct {
		Securityhub_account_id *string `lyra:"tf-gen.ignore"`
	}

	Securityhub_product_subscription struct {
		Securityhub_product_subscription_id *string `lyra:"tf-gen.ignore"`
		Arn                                 *string
		Product_arn                         string
	}

	Securityhub_standards_subscription struct {
		Securityhub_standards_subscription_id *string `lyra:"tf-gen.ignore"`
		Standards_arn                         string
	}

	Service_discovery_http_namespace struct {
		Service_discovery_http_namespace_id *string `lyra:"tf-gen.ignore"`
		Arn                                 *string
		Description                         *string
		Name                                string
	}

	Service_discovery_private_dns_namespace struct {
		Service_discovery_private_dns_namespace_id *string `lyra:"tf-gen.ignore"`
		Arn                                        *string
		Description                                *string
		Hosted_zone                                *string
		Name                                       string
		Vpc                                        string
	}

	Service_discovery_public_dns_namespace struct {
		Service_discovery_public_dns_namespace_id *string `lyra:"tf-gen.ignore"`
		Arn                                       *string
		Description                               *string
		Hosted_zone                               *string
		Name                                      string
	}

	Service_discovery_service struct {
		Service_discovery_service_id *string `lyra:"tf-gen.ignore"`
		Arn                          *string
		Description                  *string
		Dns_config                   *map[string]interface{} `puppet:"type => Optional[Struct[dns_records=>Array[Struct[ttl=>Integer,type=>String]],namespace_id=>String,Optional[routing_policy]=>String]]"`
		Health_check_config          *map[string]interface{} `puppet:"type => Optional[Struct[Optional[failure_threshold]=>Integer,Optional[resource_path]=>String,Optional[type]=>String]]"`
		Health_check_custom_config   *map[string]int64       `puppet:"type => Optional[Struct[Optional[failure_threshold]=>Integer]]"`
		Name                         string
	}

	Servicecatalog_portfolio struct {
		Servicecatalog_portfolio_id *string `lyra:"tf-gen.ignore"`
		Arn                         *string
		Created_time                *string
		Description                 *string
		Name                        string
		Provider_name               *string
		Tags                        *map[string]string
	}

	Ses_active_receipt_rule_set struct {
		Ses_active_receipt_rule_set_id *string `lyra:"tf-gen.ignore"`
		Rule_set_name                  string
	}

	Ses_configuration_set struct {
		Ses_configuration_set_id *string `lyra:"tf-gen.ignore"`
		Name                     string
	}

	Ses_domain_dkim struct {
		Ses_domain_dkim_id *string `lyra:"tf-gen.ignore"`
		Dkim_tokens        *[]string
		Domain             string
	}

	Ses_domain_identity struct {
		Ses_domain_identity_id *string `lyra:"tf-gen.ignore"`
		Arn                    *string
		Domain                 string
		Verification_token     *string
	}

	Ses_domain_identity_verification struct {
		Ses_domain_identity_verification_id *string `lyra:"tf-gen.ignore"`
		Arn                                 *string
		Domain                              string
	}

	Ses_domain_mail_from struct {
		Ses_domain_mail_from_id *string `lyra:"tf-gen.ignore"`
		Behavior_on_mx_failure  string  `puppet:"value=>'UseDefaultValue'"`
		Domain                  string
		Mail_from_domain        string
	}

	Ses_event_destination struct {
		Ses_event_destination_id *string              `lyra:"tf-gen.ignore"`
		Cloudwatch_destination   *[]map[string]string `puppet:"type => Optional[Array[Struct[default_value=>String,dimension_name=>String,value_source=>String]]]"`
		Configuration_set_name   string
		Enabled                  bool               `puppet:"value=>false"`
		Kinesis_destination      *map[string]string `puppet:"type => Optional[Struct[role_arn=>String,stream_arn=>String]]"`
		Matching_types           []string
		Name                     string
		Sns_destination          *map[string]string `puppet:"type => Optional[Struct[topic_arn=>String]]"`
	}

	Ses_identity_notification_topic struct {
		Ses_identity_notification_topic_id *string `lyra:"tf-gen.ignore"`
		Identity                           string
		Notification_type                  string
		Topic_arn                          *string
	}

	Ses_receipt_filter struct {
		Ses_receipt_filter_id *string `lyra:"tf-gen.ignore"`
		Cidr                  string
		Name                  string
		Policy                string
	}

	Ses_receipt_rule struct {
		Ses_receipt_rule_id *string                   `lyra:"tf-gen.ignore"`
		Add_header_action   *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[header_name=>String,header_value=>String,position=>Integer]]]"`
		After               *string
		Bounce_action       *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[message=>String,position=>Integer,sender=>String,smtp_reply_code=>String,Optional[status_code]=>String,Optional[topic_arn]=>String]]]"`
		Enabled             *bool
		Lambda_action       *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[function_arn=>String,Optional[invocation_type]=>String,position=>Integer,Optional[topic_arn]=>String]]]"`
		Name                string
		Recipients          *[]string
		Rule_set_name       string
		S3_action           *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[bucket_name=>String,Optional[kms_key_arn]=>String,Optional[object_key_prefix]=>String,position=>Integer,Optional[topic_arn]=>String]]]"`
		Scan_enabled        *bool
		Sns_action          *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[position=>Integer,topic_arn=>String]]]"`
		Stop_action         *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[position=>Integer,scope=>String,Optional[topic_arn]=>String]]]"`
		Tls_policy          *string
		Workmail_action     *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[organization_arn=>String,position=>Integer,Optional[topic_arn]=>String]]]"`
	}

	Ses_receipt_rule_set struct {
		Ses_receipt_rule_set_id *string `lyra:"tf-gen.ignore"`
		Rule_set_name           string
	}

	Ses_template struct {
		Ses_template_id *string `lyra:"tf-gen.ignore"`
		Html            *string
		Name            string
		Subject         *string
		Text            *string
	}

	Sfn_activity struct {
		Sfn_activity_id *string `lyra:"tf-gen.ignore"`
		Creation_date   *string
		Name            string
		Tags            *map[string]string
	}

	Sfn_state_machine struct {
		Sfn_state_machine_id *string `lyra:"tf-gen.ignore"`
		Creation_date        *string
		Definition           string
		Name                 string
		Role_arn             string
		Status               *string
		Tags                 *map[string]string
	}

	Simpledb_domain struct {
		Simpledb_domain_id *string `lyra:"tf-gen.ignore"`
		Name               string
	}

	Snapshot_create_volume_permission struct {
		Snapshot_create_volume_permission_id *string `lyra:"tf-gen.ignore"`
		Account_id                           string
		Snapshot_id                          string
	}

	Sns_platform_application struct {
		Sns_platform_application_id      *string `lyra:"tf-gen.ignore"`
		Arn                              *string
		Event_delivery_failure_topic_arn *string
		Event_endpoint_created_topic_arn *string
		Event_endpoint_deleted_topic_arn *string
		Event_endpoint_updated_topic_arn *string
		Failure_feedback_role_arn        *string
		Name                             string
		Platform                         string
		Platform_credential              string
		Platform_principal               *string
		Success_feedback_role_arn        *string
		Success_feedback_sample_rate     *string
	}

	Sns_sms_preferences struct {
		Sns_sms_preferences_id                *string `lyra:"tf-gen.ignore"`
		Default_sender_id                     *string
		Default_sms_type                      *string
		Delivery_status_iam_role_arn          *string
		Delivery_status_success_sampling_rate *string
		Monthly_spend_limit                   *string
		Usage_report_s3_bucket                *string
	}

	Sns_topic struct {
		Sns_topic_id                             *string `lyra:"tf-gen.ignore"`
		Application_failure_feedback_role_arn    *string
		Application_success_feedback_role_arn    *string
		Application_success_feedback_sample_rate *int64
		Arn                                      *string
		Delivery_policy                          *string
		Display_name                             *string
		Http_failure_feedback_role_arn           *string
		Http_success_feedback_role_arn           *string
		Http_success_feedback_sample_rate        *int64
		Kms_master_key_id                        *string
		Lambda_failure_feedback_role_arn         *string
		Lambda_success_feedback_role_arn         *string
		Lambda_success_feedback_sample_rate      *int64
		Name                                     *string
		Name_prefix                              *string
		Policy                                   *string
		Sqs_failure_feedback_role_arn            *string
		Sqs_success_feedback_role_arn            *string
		Sqs_success_feedback_sample_rate         *int64
	}

	Sns_topic_policy struct {
		Sns_topic_policy_id *string `lyra:"tf-gen.ignore"`
		Arn                 string
		Policy              string
	}

	Sns_topic_subscription struct {
		Sns_topic_subscription_id       *string `lyra:"tf-gen.ignore"`
		Arn                             *string
		Confirmation_timeout_in_minutes int64 `puppet:"value=>1"`
		Delivery_policy                 *string
		Endpoint                        string
		Endpoint_auto_confirms          bool `puppet:"value=>false"`
		Filter_policy                   *string
		Protocol                        string
		Raw_message_delivery            bool `puppet:"value=>false"`
		Topic_arn                       string
	}

	Spot_datafeed_subscription struct {
		Spot_datafeed_subscription_id *string `lyra:"tf-gen.ignore"`
		Bucket                        string
		Prefix                        *string
	}

	Spot_fleet_request struct {
		Spot_fleet_request_id               *string `lyra:"tf-gen.ignore"`
		Allocation_strategy                 string  `puppet:"value=>'lowestPrice'"`
		Client_token                        *string
		Excess_capacity_termination_policy  string `puppet:"value=>'Default'"`
		Fleet_type                          string `puppet:"value=>'maintain'"`
		Iam_fleet_role                      string
		Instance_interruption_behaviour     string                   `puppet:"value=>'terminate'"`
		Instance_pools_to_use_count         int64                    `puppet:"value=>1"`
		Launch_specification                []map[string]interface{} `puppet:"type => Array[Struct[ami=>String,Optional[associate_public_ip_address]=>Boolean,Optional[availability_zone]=>String,Optional[ebs_block_device]=>Array[Struct[Optional[delete_on_termination]=>Boolean,device_name=>String,Optional[encrypted]=>Boolean,Optional[iops]=>Integer,Optional[snapshot_id]=>String,Optional[volume_size]=>Integer,Optional[volume_type]=>String]],Optional[ebs_optimized]=>Boolean,Optional[ephemeral_block_device]=>Array[Struct[device_name=>String,virtual_name=>String]],Optional[iam_instance_profile]=>String,Optional[iam_instance_profile_arn]=>String,instance_type=>String,Optional[key_name]=>String,Optional[monitoring]=>Boolean,Optional[placement_group]=>String,Optional[placement_tenancy]=>String,Optional[root_block_device]=>Array[Struct[Optional[delete_on_termination]=>Boolean,Optional[iops]=>Integer,Optional[volume_size]=>Integer,Optional[volume_type]=>String]],Optional[spot_price]=>String,Optional[subnet_id]=>String,Optional[tags]=>Hash[String,String],Optional[user_data]=>String,Optional[vpc_security_group_ids]=>Array[String],Optional[weighted_capacity]=>String]]"`
		Load_balancers                      *[]string
		Replace_unhealthy_instances         bool `puppet:"value=>false"`
		Spot_price                          *string
		Spot_request_state                  *string
		Target_capacity                     int64
		Target_group_arns                   *[]string
		Terminate_instances_with_expiration *bool
		Valid_from                          *time.Time
		Valid_until                         *time.Time
		Wait_for_fulfillment                bool `puppet:"value=>false"`
	}

	Spot_instance_request struct {
		Spot_instance_request_id             *string `lyra:"tf-gen.ignore"`
		Ami                                  string
		Arn                                  *string
		Associate_public_ip_address          *bool
		Availability_zone                    *string
		Block_device                         *map[string]string
		Block_duration_minutes               *int64
		Cpu_core_count                       *int64
		Cpu_threads_per_core                 *int64
		Credit_specification                 *map[string]string `puppet:"type => Optional[Struct[Optional[cpu_credits]=>String]]"`
		Disable_api_termination              *bool
		Ebs_block_device                     *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[delete_on_termination]=>Boolean,device_name=>String,Optional[encrypted]=>Boolean,Optional[iops]=>Integer,Optional[snapshot_id]=>String,Optional[volume_id]=>String,Optional[volume_size]=>Integer,Optional[volume_type]=>String]]]"`
		Ebs_optimized                        *bool
		Ephemeral_block_device               *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[device_name=>String,Optional[no_device]=>Boolean,Optional[virtual_name]=>String]]]"`
		Get_password_data                    bool                      `puppet:"value=>false"`
		Host_id                              *string
		Iam_instance_profile                 *string
		Instance_initiated_shutdown_behavior *string
		Instance_interruption_behaviour      string `puppet:"value=>'terminate'"`
		Instance_state                       *string
		Instance_type                        string
		Ipv6_address_count                   *int64
		Ipv6_addresses                       *[]string
		Key_name                             *string
		Launch_group                         *string
		Monitoring                           *bool
		Network_interface                    *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[delete_on_termination]=>Boolean,device_index=>Integer,network_interface_id=>String]]]"`
		Network_interface_id                 *string
		Password_data                        *string
		Placement_group                      *string
		Primary_network_interface_id         *string
		Private_dns                          *string
		Private_ip                           *string
		Public_dns                           *string
		Public_ip                            *string
		Root_block_device                    *map[string]interface{} `puppet:"type => Optional[Struct[Optional[delete_on_termination]=>Boolean,Optional[iops]=>Integer,Optional[volume_id]=>String,Optional[volume_size]=>Integer,Optional[volume_type]=>String]]"`
		Security_groups                      *[]string
		Source_dest_check                    bool `puppet:"value=>true"`
		Spot_bid_status                      *string
		Spot_instance_id                     *string
		Spot_price                           *string
		Spot_request_state                   *string
		Spot_type                            string `puppet:"value=>'persistent'"`
		Subnet_id                            *string
		Tags                                 *map[string]string
		Tenancy                              *string
		User_data                            *string
		User_data_base64                     *string
		Valid_from                           *time.Time
		Valid_until                          *time.Time
		Volume_tags                          *map[string]string
		Vpc_security_group_ids               *[]string
		Wait_for_fulfillment                 bool `puppet:"value=>false"`
	}

	Sqs_queue struct {
		Sqs_queue_id                      *string `lyra:"tf-gen.ignore"`
		Arn                               *string
		Content_based_deduplication       bool  `puppet:"value=>false"`
		Delay_seconds                     int64 `puppet:"value=>0"`
		Fifo_queue                        bool  `puppet:"value=>false"`
		Kms_data_key_reuse_period_seconds *int64
		Kms_master_key_id                 *string
		Max_message_size                  int64 `puppet:"value=>262144"`
		Message_retention_seconds         int64 `puppet:"value=>345600"`
		Name                              *string
		Name_prefix                       *string
		Policy                            *string
		Receive_wait_time_seconds         int64 `puppet:"value=>0"`
		Redrive_policy                    *string
		Tags                              *map[string]string
		Visibility_timeout_seconds        int64 `puppet:"value=>30"`
	}

	Sqs_queue_policy struct {
		Sqs_queue_policy_id *string `lyra:"tf-gen.ignore"`
		Policy              string
		Queue_url           string
	}

	Ssm_activation struct {
		Ssm_activation_id  *string `lyra:"tf-gen.ignore"`
		Activation_code    *string
		Description        *string
		Expiration_date    *time.Time
		Expired            *string
		Iam_role           string
		Name               *string
		Registration_count *int64
		Registration_limit *int64
	}

	Ssm_association struct {
		Ssm_association_id  *string `lyra:"tf-gen.ignore"`
		Association_id      *string
		Association_name    *string
		Document_version    *string
		Instance_id         *string
		Name                string
		Output_location     *map[string]string `puppet:"type => Optional[Struct[s3_bucket_name=>String,Optional[s3_key_prefix]=>String]]"`
		Parameters          *map[string]string
		Schedule_expression *string
		Targets             *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[key=>String,values=>Array[String]],0,5]]"`
	}

	Ssm_document struct {
		Ssm_document_id *string `lyra:"tf-gen.ignore"`
		Arn             *string
		Content         string
		Created_date    *string
		Default_version *string
		Description     *string
		Document_format string `puppet:"value=>'JSON'"`
		Document_type   string
		Hash            *string
		Hash_type       *string
		Latest_version  *string
		Name            string
		Owner           *string
		Parameter       *[]map[string]string          `puppet:"type => Optional[Array[Struct[Optional[default_value]=>String,Optional[description]=>String,Optional[name]=>String,Optional[type]=>String]]]"`
		Permissions     *map[string]map[string]string `puppet:"type => Optional[Hash[String,Struct[account_ids=>String,type=>String]]]"`
		Platform_types  *[]string
		Schema_version  *string
		Status          *string
		Tags            *map[string]string
	}

	Ssm_maintenance_window struct {
		Ssm_maintenance_window_id  *string `lyra:"tf-gen.ignore"`
		Allow_unassociated_targets bool    `puppet:"value=>false"`
		Cutoff                     int64
		Duration                   int64
		Enabled                    bool `puppet:"value=>true"`
		End_date                   *string
		Name                       string
		Schedule                   string
		Schedule_timezone          *string
		Start_date                 *string
	}

	Ssm_maintenance_window_target struct {
		Ssm_maintenance_window_target_id *string `lyra:"tf-gen.ignore"`
		Owner_information                *string
		Resource_type                    string
		Targets                          []map[string]interface{} `puppet:"type => Array[Struct[key=>String,values=>Array[String]],0,5]"`
		Window_id                        string
	}

	Ssm_maintenance_window_task struct {
		Ssm_maintenance_window_task_id *string `lyra:"tf-gen.ignore"`
		Description                    *string
		Logging_info                   *map[string]string `puppet:"type => Optional[Struct[s3_bucket_name=>String,Optional[s3_bucket_prefix]=>String,s3_region=>String]]"`
		Max_concurrency                string
		Max_errors                     string
		Name                           *string
		Priority                       *int64
		Service_role_arn               string
		Targets                        []map[string]interface{} `puppet:"type => Array[Struct[key=>String,values=>Array[String]]]"`
		Task_arn                       string
		Task_parameters                *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[name=>String,values=>Array[String]]]]"`
		Task_type                      string
		Window_id                      string
	}

	Ssm_parameter struct {
		Ssm_parameter_id *string `lyra:"tf-gen.ignore"`
		Allowed_pattern  *string
		Arn              *string
		Description      *string
		Key_id           *string
		Name             string
		Overwrite        *bool
		Tags             *map[string]string
		Type             string
		Value            string
	}

	Ssm_patch_baseline struct {
		Ssm_patch_baseline_id             *string                   `lyra:"tf-gen.ignore"`
		Approval_rule                     *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[approve_after_days=>Integer,Optional[compliance_level]=>String,Optional[enable_non_security]=>Boolean,patch_filter=>Array[Struct[key=>String,values=>Array[String]],0,10]]]]"`
		Approved_patches                  *[]string
		Approved_patches_compliance_level string `puppet:"value=>'UNSPECIFIED'"`
		Description                       *string
		Global_filter                     *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[key=>String,values=>Array[String]],0,4]]"`
		Name                              string
		Operating_system                  string `puppet:"value=>'WINDOWS'"`
		Rejected_patches                  *[]string
	}

	Ssm_patch_group struct {
		Ssm_patch_group_id *string `lyra:"tf-gen.ignore"`
		Baseline_id        string
		Patch_group        string
	}

	Ssm_resource_data_sync struct {
		Ssm_resource_data_sync_id *string `lyra:"tf-gen.ignore"`
		Name                      string
		S3_destination            *map[string]string `puppet:"type => Optional[Struct[bucket_name=>String,Optional[kms_key_arn]=>String,Optional[prefix]=>String,region=>String,Optional[sync_format]=>String]]"`
	}

	Storagegateway_cache struct {
		Storagegateway_cache_id *string `lyra:"tf-gen.ignore"`
		Disk_id                 string
		Gateway_arn             string
	}

	Storagegateway_cached_iscsi_volume struct {
		Storagegateway_cached_iscsi_volume_id *string `lyra:"tf-gen.ignore"`
		Arn                                   *string
		Chap_enabled                          *bool
		Gateway_arn                           string
		Lun_number                            *int64
		Network_interface_id                  string
		Network_interface_port                *int64
		Snapshot_id                           *string
		Source_volume_arn                     *string
		Target_arn                            *string
		Target_name                           string
		Volume_arn                            *string
		Volume_id                             *string
		Volume_size_in_bytes                  int64
	}

	Storagegateway_gateway struct {
		Storagegateway_gateway_id     *string `lyra:"tf-gen.ignore"`
		Activation_key                *string
		Arn                           *string
		Gateway_id                    *string
		Gateway_ip_address            *string
		Gateway_name                  string
		Gateway_timezone              string
		Gateway_type                  string `puppet:"value=>'STORED'"`
		Medium_changer_type           *string
		Smb_active_directory_settings *map[string]string `puppet:"type => Optional[Struct[domain_name=>String,password=>String,username=>String]]"`
		Smb_guest_password            *string
		Tape_drive_type               *string
	}

	Storagegateway_nfs_file_share struct {
		Storagegateway_nfs_file_share_id *string `lyra:"tf-gen.ignore"`
		Arn                              *string
		Client_list                      []string
		Default_storage_class            string `puppet:"value=>'S3_STANDARD'"`
		Fileshare_id                     *string
		Gateway_arn                      string
		Guess_mime_type_enabled          bool `puppet:"value=>true"`
		Kms_encrypted                    bool `puppet:"value=>false"`
		Kms_key_arn                      *string
		Location_arn                     string
		Nfs_file_share_defaults          *map[string]interface{} `puppet:"type => Optional[Struct[Optional[directory_mode]=>String,Optional[file_mode]=>String,Optional[group_id]=>Integer,Optional[owner_id]=>Integer]]"`
		Object_acl                       string                  `puppet:"value=>'private'"`
		Read_only                        bool                    `puppet:"value=>false"`
		Requester_pays                   bool                    `puppet:"value=>false"`
		Role_arn                         string
		Squash                           string `puppet:"value=>'RootSquash'"`
	}

	Storagegateway_smb_file_share struct {
		Storagegateway_smb_file_share_id *string `lyra:"tf-gen.ignore"`
		Arn                              *string
		Authentication                   string `puppet:"value=>'ActiveDirectory'"`
		Default_storage_class            string `puppet:"value=>'S3_STANDARD'"`
		Fileshare_id                     *string
		Gateway_arn                      string
		Guess_mime_type_enabled          bool `puppet:"value=>true"`
		Invalid_user_list                *[]string
		Kms_encrypted                    bool `puppet:"value=>false"`
		Kms_key_arn                      *string
		Location_arn                     string
		Object_acl                       string `puppet:"value=>'private'"`
		Read_only                        bool   `puppet:"value=>false"`
		Requester_pays                   bool   `puppet:"value=>false"`
		Role_arn                         string
		Valid_user_list                  *[]string
	}

	Storagegateway_upload_buffer struct {
		Storagegateway_upload_buffer_id *string `lyra:"tf-gen.ignore"`
		Disk_id                         string
		Gateway_arn                     string
	}

	Storagegateway_working_storage struct {
		Storagegateway_working_storage_id *string `lyra:"tf-gen.ignore"`
		Disk_id                           string
		Gateway_arn                       string
	}

	Subnet struct {
		Subnet_id                       *string `lyra:"tf-gen.ignore"`
		Arn                             *string
		Assign_ipv6_address_on_creation bool `puppet:"value=>false"`
		Availability_zone               *string
		Availability_zone_id            *string
		Cidr_block                      string
		Ipv6_cidr_block                 *string
		Ipv6_cidr_block_association_id  *string
		Map_public_ip_on_launch         bool `puppet:"value=>false"`
		Owner_id                        *string
		Tags                            *map[string]string
		Vpc_id                          string
	}

	Swf_domain struct {
		Swf_domain_id                               *string `lyra:"tf-gen.ignore"`
		Description                                 *string
		Name                                        *string
		Name_prefix                                 *string
		Workflow_execution_retention_period_in_days string
	}

	Transfer_server struct {
		Transfer_server_id     *string `lyra:"tf-gen.ignore"`
		Arn                    *string
		Endpoint               *string
		Force_destroy          bool   `puppet:"value=>false"`
		Identity_provider_type string `puppet:"value=>'SERVICE_MANAGED'"`
		Invocation_role        *string
		Logging_role           *string
		Tags                   *map[string]string
		Url                    *string
	}

	Transfer_ssh_key struct {
		Transfer_ssh_key_id *string `lyra:"tf-gen.ignore"`
		Body                string
		Server_id           string
		User_name           string
	}

	Transfer_user struct {
		Transfer_user_id *string `lyra:"tf-gen.ignore"`
		Arn              *string
		Home_directory   *string
		Policy           *string
		Role             string
		Server_id        string
		Tags             *map[string]string
		User_name        string
	}

	Volume_attachment struct {
		Volume_attachment_id *string `lyra:"tf-gen.ignore"`
		Device_name          string
		Force_detach         *bool
		Instance_id          string
		Skip_destroy         *bool
		Volume_id            string
	}

	Vpc struct {
		Vpc_id                           *string `lyra:"tf-gen.ignore"`
		Arn                              *string
		Assign_generated_ipv6_cidr_block bool `puppet:"value=>false"`
		Cidr_block                       string
		Default_network_acl_id           *string
		Default_route_table_id           *string
		Default_security_group_id        *string
		Dhcp_options_id                  *string
		Enable_classiclink               *bool
		Enable_classiclink_dns_support   *bool
		Enable_dns_hostnames             *bool
		Enable_dns_support               bool   `puppet:"value=>true"`
		Instance_tenancy                 string `puppet:"value=>'default'"`
		Ipv6_association_id              *string
		Ipv6_cidr_block                  *string
		Main_route_table_id              *string
		Owner_id                         *string
		Tags                             *map[string]string
	}

	Vpc_dhcp_options struct {
		Vpc_dhcp_options_id  *string `lyra:"tf-gen.ignore"`
		Domain_name          *string
		Domain_name_servers  *[]string
		Netbios_name_servers *[]string
		Netbios_node_type    *string
		Ntp_servers          *[]string
		Owner_id             *string
		Tags                 *map[string]string
	}

	Vpc_dhcp_options_association struct {
		Vpc_dhcp_options_association_id *string `lyra:"tf-gen.ignore"`
		Dhcp_options_id                 string
		Vpc_id                          string
	}

	Vpc_endpoint struct {
		Vpc_endpoint_id       *string `lyra:"tf-gen.ignore"`
		Auto_accept           *bool
		Cidr_blocks           *[]string
		Dns_entry             *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[dns_name]=>String,Optional[hosted_zone_id]=>String]]]"`
		Network_interface_ids *[]string
		Policy                *string
		Prefix_list_id        *string
		Private_dns_enabled   bool `puppet:"value=>false"`
		Route_table_ids       *[]string
		Security_group_ids    *[]string
		Service_name          string
		State                 *string
		Subnet_ids            *[]string
		Vpc_endpoint_type     string `puppet:"value=>'Gateway'"`
		Vpc_id                string
	}

	Vpc_endpoint_connection_notification struct {
		Vpc_endpoint_connection_notification_id *string `lyra:"tf-gen.ignore"`
		Connection_events                       []string
		Connection_notification_arn             string
		Notification_type                       *string
		State                                   *string
		Vpc_endpoint_id                         *string
		Vpc_endpoint_service_id                 *string
	}

	Vpc_endpoint_route_table_association struct {
		Vpc_endpoint_route_table_association_id *string `lyra:"tf-gen.ignore"`
		Route_table_id                          string
		Vpc_endpoint_id                         string
	}

	Vpc_endpoint_service struct {
		Vpc_endpoint_service_id    *string `lyra:"tf-gen.ignore"`
		Acceptance_required        bool
		Allowed_principals         *[]string
		Availability_zones         *[]string
		Base_endpoint_dns_names    *[]string
		Network_load_balancer_arns []string
		Private_dns_name           *string
		Service_name               *string
		Service_type               *string
		State                      *string
	}

	Vpc_endpoint_service_allowed_principal struct {
		Vpc_endpoint_service_allowed_principal_id *string `lyra:"tf-gen.ignore"`
		Principal_arn                             string
		Vpc_endpoint_service_id                   string
	}

	Vpc_endpoint_subnet_association struct {
		Vpc_endpoint_subnet_association_id *string `lyra:"tf-gen.ignore"`
		Subnet_id                          string
		Vpc_endpoint_id                    string
	}

	Vpc_ipv4_cidr_block_association struct {
		Vpc_ipv4_cidr_block_association_id *string `lyra:"tf-gen.ignore"`
		Cidr_block                         string
		Vpc_id                             string
	}

	Vpc_peering_connection struct {
		Vpc_peering_connection_id *string `lyra:"tf-gen.ignore"`
		Accept_status             *string
		Accepter                  *map[string]bool `puppet:"type => Optional[Struct[Optional[allow_classic_link_to_remote_vpc]=>Boolean,Optional[allow_remote_vpc_dns_resolution]=>Boolean,Optional[allow_vpc_to_remote_classic_link]=>Boolean]]"`
		Auto_accept               *bool
		Peer_owner_id             *string
		Peer_region               *string
		Peer_vpc_id               string
		Requester                 *map[string]bool `puppet:"type => Optional[Struct[Optional[allow_classic_link_to_remote_vpc]=>Boolean,Optional[allow_remote_vpc_dns_resolution]=>Boolean,Optional[allow_vpc_to_remote_classic_link]=>Boolean]]"`
		Tags                      *map[string]string
		Vpc_id                    string
	}

	Vpc_peering_connection_accepter struct {
		Vpc_peering_connection_accepter_id *string `lyra:"tf-gen.ignore"`
		Accept_status                      *string
		Accepter                           *map[string]bool `puppet:"type => Optional[Struct[Optional[allow_classic_link_to_remote_vpc]=>Boolean,Optional[allow_remote_vpc_dns_resolution]=>Boolean,Optional[allow_vpc_to_remote_classic_link]=>Boolean]]"`
		Auto_accept                        *bool
		Peer_owner_id                      *string
		Peer_region                        *string
		Peer_vpc_id                        *string
		Requester                          *map[string]bool `puppet:"type => Optional[Struct[Optional[allow_classic_link_to_remote_vpc]=>Boolean,Optional[allow_remote_vpc_dns_resolution]=>Boolean,Optional[allow_vpc_to_remote_classic_link]=>Boolean]]"`
		Tags                               *map[string]string
		Vpc_id                             *string
		Vpc_peering_connection_id          string
	}

	Vpc_peering_connection_options struct {
		Vpc_peering_connection_options_id *string          `lyra:"tf-gen.ignore"`
		Accepter                          *map[string]bool `puppet:"type => Optional[Struct[Optional[allow_classic_link_to_remote_vpc]=>Boolean,Optional[allow_remote_vpc_dns_resolution]=>Boolean,Optional[allow_vpc_to_remote_classic_link]=>Boolean]]"`
		Requester                         *map[string]bool `puppet:"type => Optional[Struct[Optional[allow_classic_link_to_remote_vpc]=>Boolean,Optional[allow_remote_vpc_dns_resolution]=>Boolean,Optional[allow_vpc_to_remote_classic_link]=>Boolean]]"`
		Vpc_peering_connection_id         string
	}

	Vpn_connection struct {
		Vpn_connection_id              *string `lyra:"tf-gen.ignore"`
		Customer_gateway_configuration *string
		Customer_gateway_id            string
		Routes                         *[]map[string]string `puppet:"type => Optional[Array[Struct[Optional[destination_cidr_block]=>String,Optional[source]=>String,Optional[state]=>String]]]"`
		Static_routes_only             *bool
		Tags                           *map[string]string
		Transit_gateway_id             *string
		Tunnel1_address                *string
		Tunnel1_bgp_asn                *string
		Tunnel1_bgp_holdtime           *int64
		Tunnel1_cgw_inside_address     *string
		Tunnel1_inside_cidr            *string
		Tunnel1_preshared_key          *string
		Tunnel1_vgw_inside_address     *string
		Tunnel2_address                *string
		Tunnel2_bgp_asn                *string
		Tunnel2_bgp_holdtime           *int64
		Tunnel2_cgw_inside_address     *string
		Tunnel2_inside_cidr            *string
		Tunnel2_preshared_key          *string
		Tunnel2_vgw_inside_address     *string
		Type                           string
		Vgw_telemetry                  *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[accepted_route_count]=>Integer,Optional[last_status_change]=>String,Optional[outside_ip_address]=>String,Optional[status]=>String,Optional[status_message]=>String]]]"`
		Vpn_gateway_id                 *string
	}

	Vpn_connection_route struct {
		Vpn_connection_route_id *string `lyra:"tf-gen.ignore"`
		Destination_cidr_block  string
		Vpn_connection_id       string
	}

	Vpn_gateway struct {
		Vpn_gateway_id    *string `lyra:"tf-gen.ignore"`
		Amazon_side_asn   *string
		Availability_zone *string
		Tags              *map[string]string
		Vpc_id            *string
	}

	Vpn_gateway_attachment struct {
		Vpn_gateway_attachment_id *string `lyra:"tf-gen.ignore"`
		Vpc_id                    string
		Vpn_gateway_id            string
	}

	Vpn_gateway_route_propagation struct {
		Vpn_gateway_route_propagation_id *string `lyra:"tf-gen.ignore"`
		Route_table_id                   string
		Vpn_gateway_id                   string
	}

	Waf_byte_match_set struct {
		Waf_byte_match_set_id *string                   `lyra:"tf-gen.ignore"`
		Byte_match_tuples     *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[field_to_match=>Struct[Optional[data]=>String,type=>String],positional_constraint=>String,Optional[target_string]=>String,text_transformation=>String]]]"`
		Name                  string
	}

	Waf_geo_match_set struct {
		Waf_geo_match_set_id *string              `lyra:"tf-gen.ignore"`
		Geo_match_constraint *[]map[string]string `puppet:"type => Optional[Array[Struct[type=>String,value=>String]]]"`
		Name                 string
	}

	Waf_ipset struct {
		Waf_ipset_id       *string `lyra:"tf-gen.ignore"`
		Arn                *string
		Ip_set_descriptors *[]map[string]string `puppet:"type => Optional[Array[Struct[type=>String,value=>String]]]"`
		Name               string
	}

	Waf_rate_based_rule struct {
		Waf_rate_based_rule_id *string `lyra:"tf-gen.ignore"`
		Metric_name            string
		Name                   string
		Predicates             *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[data_id=>String,negated=>Boolean,type=>String]]]"`
		Rate_key               string
		Rate_limit             int64
	}

	Waf_regex_match_set struct {
		Waf_regex_match_set_id *string `lyra:"tf-gen.ignore"`
		Name                   string
		Regex_match_tuple      *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[field_to_match=>Struct[Optional[data]=>String,type=>String],regex_pattern_set_id=>String,text_transformation=>String]]]"`
	}

	Waf_regex_pattern_set struct {
		Waf_regex_pattern_set_id *string `lyra:"tf-gen.ignore"`
		Name                     string
		Regex_pattern_strings    *[]string
	}

	Waf_rule struct {
		Waf_rule_id *string `lyra:"tf-gen.ignore"`
		Metric_name string
		Name        string
		Predicates  *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[data_id=>String,negated=>Boolean,type=>String]]]"`
	}

	Waf_rule_group struct {
		Waf_rule_group_id *string                   `lyra:"tf-gen.ignore"`
		Activated_rule    *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[action=>Struct[type=>String],priority=>Integer,rule_id=>String,Optional[type]=>String]]]"`
		Metric_name       string
		Name              string
	}

	Waf_size_constraint_set struct {
		Waf_size_constraint_set_id *string `lyra:"tf-gen.ignore"`
		Name                       string
		Size_constraints           *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[comparison_operator=>String,field_to_match=>Struct[Optional[data]=>String,type=>String],size=>Integer,text_transformation=>String]]]"`
	}

	Waf_sql_injection_match_set struct {
		Waf_sql_injection_match_set_id *string `lyra:"tf-gen.ignore"`
		Name                           string
		Sql_injection_match_tuples     *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[field_to_match=>Struct[Optional[data]=>String,type=>String],text_transformation=>String]]]"`
	}

	Waf_web_acl struct {
		Waf_web_acl_id *string            `lyra:"tf-gen.ignore"`
		Default_action *map[string]string `puppet:"type => Optional[Struct[type=>String]]"`
		Metric_name    string
		Name           string
		Rules          *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[action]=>Struct[type=>String],Optional[override_action]=>Struct[type=>String],priority=>Integer,rule_id=>String,Optional[type]=>String]]]"`
	}

	Waf_xss_match_set struct {
		Waf_xss_match_set_id *string `lyra:"tf-gen.ignore"`
		Name                 string
		Xss_match_tuples     *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[field_to_match=>Struct[Optional[data]=>String,type=>String],text_transformation=>String]]]"`
	}

	Wafregional_byte_match_set struct {
		Wafregional_byte_match_set_id *string                   `lyra:"tf-gen.ignore"`
		Byte_match_tuple              *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[field_to_match=>Struct[Optional[data]=>String,type=>String],positional_constraint=>String,Optional[target_string]=>String,text_transformation=>String]]]"`
		Byte_match_tuples             *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[field_to_match=>Struct[Optional[data]=>String,type=>String],positional_constraint=>String,Optional[target_string]=>String,text_transformation=>String]]]"`
		Name                          string
	}

	Wafregional_geo_match_set struct {
		Wafregional_geo_match_set_id *string              `lyra:"tf-gen.ignore"`
		Geo_match_constraint         *[]map[string]string `puppet:"type => Optional[Array[Struct[type=>String,value=>String]]]"`
		Name                         string
	}

	Wafregional_ipset struct {
		Wafregional_ipset_id *string `lyra:"tf-gen.ignore"`
		Arn                  *string
		Ip_set_descriptor    *[]map[string]string `puppet:"type => Optional[Array[Struct[type=>String,value=>String]]]"`
		Name                 string
	}

	Wafregional_rate_based_rule struct {
		Wafregional_rate_based_rule_id *string `lyra:"tf-gen.ignore"`
		Metric_name                    string
		Name                           string
		Predicate                      *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[data_id=>String,negated=>Boolean,type=>String]]]"`
		Rate_key                       string
		Rate_limit                     int64
	}

	Wafregional_regex_match_set struct {
		Wafregional_regex_match_set_id *string `lyra:"tf-gen.ignore"`
		Name                           string
		Regex_match_tuple              *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[field_to_match=>Struct[Optional[data]=>String,type=>String],regex_pattern_set_id=>String,text_transformation=>String]]]"`
	}

	Wafregional_regex_pattern_set struct {
		Wafregional_regex_pattern_set_id *string `lyra:"tf-gen.ignore"`
		Name                             string
		Regex_pattern_strings            *[]string
	}

	Wafregional_rule struct {
		Wafregional_rule_id *string `lyra:"tf-gen.ignore"`
		Metric_name         string
		Name                string
		Predicate           *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[data_id=>String,negated=>Boolean,type=>String]]]"`
	}

	Wafregional_rule_group struct {
		Wafregional_rule_group_id *string                   `lyra:"tf-gen.ignore"`
		Activated_rule            *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[action=>Struct[type=>String],priority=>Integer,rule_id=>String,Optional[type]=>String]]]"`
		Metric_name               string
		Name                      string
	}

	Wafregional_size_constraint_set struct {
		Wafregional_size_constraint_set_id *string `lyra:"tf-gen.ignore"`
		Name                               string
		Size_constraints                   *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[comparison_operator=>String,field_to_match=>Struct[Optional[data]=>String,type=>String],size=>Integer,text_transformation=>String]]]"`
	}

	Wafregional_sql_injection_match_set struct {
		Wafregional_sql_injection_match_set_id *string `lyra:"tf-gen.ignore"`
		Name                                   string
		Sql_injection_match_tuple              *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[field_to_match=>Struct[Optional[data]=>String,type=>String],text_transformation=>String]]]"`
	}

	Wafregional_web_acl struct {
		Wafregional_web_acl_id *string            `lyra:"tf-gen.ignore"`
		Default_action         *map[string]string `puppet:"type => Optional[Struct[type=>String]]"`
		Metric_name            string
		Name                   string
		Rule                   *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[Optional[action]=>Struct[type=>String],Optional[override_action]=>Struct[type=>String],priority=>Integer,rule_id=>String,Optional[type]=>String]]]"`
	}

	Wafregional_web_acl_association struct {
		Wafregional_web_acl_association_id *string `lyra:"tf-gen.ignore"`
		Resource_arn                       string
		Web_acl_id                         string
	}

	Wafregional_xss_match_set struct {
		Wafregional_xss_match_set_id *string `lyra:"tf-gen.ignore"`
		Name                         string
		Xss_match_tuple              *[]map[string]interface{} `puppet:"type => Optional[Array[Struct[field_to_match=>Struct[Optional[data]=>String,type=>String],text_transformation=>String]]]"`
	}
)

func Initialize(sb *service.Builder, p *schema.Provider) {
	// Generic handler API
	sb.RegisterAPI("TerraformAws::GenericHandler", bridge.NewTFHandler(nil, nil, "", ""))

	// Registration of resource types with handler
	var rt px.Type
	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Acm_certificate{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("acm_certificate_id", "arn", "domain_name", "domain_validation_options", "subject_alternative_names", "validation_emails", "validation_method")
		b.ImmutableAttributes("domain_name", "subject_alternative_names", "validation_method")
	}))[0]
	sb.RegisterHandler("TerraformAws::Acm_certificateHandler", bridge.NewTFHandler(p, rt, "acm_certificate_id", "aws_acm_certificate"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Acm_certificate_validation{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("acm_certificate_validation_id")
		b.ImmutableAttributes("certificate_arn", "validation_record_fqdns")
	}))[0]
	sb.RegisterHandler("TerraformAws::Acm_certificate_validationHandler", bridge.NewTFHandler(p, rt, "acm_certificate_validation_id", "aws_acm_certificate_validation"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Acmpca_certificate_authority{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("acmpca_certificate_authority_id", "arn", "certificate", "certificate_chain", "certificate_signing_request", "not_after", "not_before", "serial", "status")
	}))[0]
	sb.RegisterHandler("TerraformAws::Acmpca_certificate_authorityHandler", bridge.NewTFHandler(p, rt, "acmpca_certificate_authority_id", "aws_acmpca_certificate_authority"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Alb{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("alb_id", "access_logs", "arn", "arn_suffix", "dns_name", "internal", "ip_address_type", "name", "security_groups", "subnet_mapping", "subnets", "vpc_id", "zone_id")
		b.ImmutableAttributes("internal", "load_balancer_type", "name", "name_prefix", "subnet_mapping")
	}))[0]
	sb.RegisterHandler("TerraformAws::AlbHandler", bridge.NewTFHandler(p, rt, "alb_id", "aws_alb"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Alb_listener{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("alb_listener_id", "arn", "ssl_policy")
		b.ImmutableAttributes("load_balancer_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Alb_listenerHandler", bridge.NewTFHandler(p, rt, "alb_listener_id", "aws_alb_listener"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Alb_listener_certificate{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("alb_listener_certificate_id")
		b.ImmutableAttributes("certificate_arn", "listener_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Alb_listener_certificateHandler", bridge.NewTFHandler(p, rt, "alb_listener_certificate_id", "aws_alb_listener_certificate"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Alb_listener_rule{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("alb_listener_rule_id", "arn", "priority")
		b.ImmutableAttributes("listener_arn", "priority")
	}))[0]
	sb.RegisterHandler("TerraformAws::Alb_listener_ruleHandler", bridge.NewTFHandler(p, rt, "alb_listener_rule_id", "aws_alb_listener_rule"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Alb_target_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("alb_target_group_id", "arn", "arn_suffix", "health_check", "name", "stickiness")
		b.ImmutableAttributes("name", "name_prefix", "port", "protocol", "target_type", "vpc_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Alb_target_groupHandler", bridge.NewTFHandler(p, rt, "alb_target_group_id", "aws_alb_target_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Alb_target_group_attachment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("alb_target_group_attachment_id")
		b.ImmutableAttributes("availability_zone", "port", "target_group_arn", "target_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Alb_target_group_attachmentHandler", bridge.NewTFHandler(p, rt, "alb_target_group_attachment_id", "aws_alb_target_group_attachment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ami{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ami_id", "ebs_block_device", "ephemeral_block_device", "image_location", "manage_ebs_snapshots", "root_snapshot_id")
		b.ImmutableAttributes("architecture", "ena_support", "ephemeral_block_device", "image_location", "kernel_id", "manage_ebs_snapshots", "name", "ramdisk_id", "root_device_name", "sriov_net_support", "virtualization_type")
	}))[0]
	sb.RegisterHandler("TerraformAws::AmiHandler", bridge.NewTFHandler(p, rt, "ami_id", "aws_ami"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ami_copy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ami_copy_id", "architecture", "ebs_block_device", "ena_support", "ephemeral_block_device", "image_location", "kernel_id", "kms_key_id", "manage_ebs_snapshots", "ramdisk_id", "root_device_name", "root_snapshot_id", "sriov_net_support", "virtualization_type")
		b.ImmutableAttributes("encrypted", "ephemeral_block_device", "kms_key_id", "manage_ebs_snapshots", "name", "source_ami_id", "source_ami_region")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ami_copyHandler", bridge.NewTFHandler(p, rt, "ami_copy_id", "aws_ami_copy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ami_from_instance{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ami_from_instance_id", "architecture", "ebs_block_device", "ena_support", "ephemeral_block_device", "image_location", "kernel_id", "manage_ebs_snapshots", "ramdisk_id", "root_device_name", "root_snapshot_id", "sriov_net_support", "virtualization_type")
		b.ImmutableAttributes("ephemeral_block_device", "manage_ebs_snapshots", "name", "snapshot_without_reboot", "source_instance_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ami_from_instanceHandler", bridge.NewTFHandler(p, rt, "ami_from_instance_id", "aws_ami_from_instance"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ami_launch_permission{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ami_launch_permission_id")
		b.ImmutableAttributes("account_id", "image_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ami_launch_permissionHandler", bridge.NewTFHandler(p, rt, "ami_launch_permission_id", "aws_ami_launch_permission"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_account{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_account_id", "throttle_settings")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_accountHandler", bridge.NewTFHandler(p, rt, "api_gateway_account_id", "aws_api_gateway_account"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_api_key{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_api_key_id", "created_date", "last_updated_date", "value")
		b.ImmutableAttributes("name", "value")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_api_keyHandler", bridge.NewTFHandler(p, rt, "api_gateway_api_key_id", "aws_api_gateway_api_key"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_authorizer{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_authorizer_id")
		b.ImmutableAttributes("rest_api_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_authorizerHandler", bridge.NewTFHandler(p, rt, "api_gateway_authorizer_id", "aws_api_gateway_authorizer"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_base_path_mapping{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_base_path_mapping_id")
		b.ImmutableAttributes("api_id", "base_path", "domain_name", "stage_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_base_path_mappingHandler", bridge.NewTFHandler(p, rt, "api_gateway_base_path_mapping_id", "aws_api_gateway_base_path_mapping"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_client_certificate{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_client_certificate_id", "created_date", "expiration_date", "pem_encoded_certificate")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_client_certificateHandler", bridge.NewTFHandler(p, rt, "api_gateway_client_certificate_id", "aws_api_gateway_client_certificate"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_deployment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_deployment_id", "created_date", "execution_arn", "invoke_url")
		b.ImmutableAttributes("rest_api_id", "stage_description", "stage_name", "variables")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_deploymentHandler", bridge.NewTFHandler(p, rt, "api_gateway_deployment_id", "aws_api_gateway_deployment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_documentation_part{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_documentation_part_id")
		b.ImmutableAttributes("location", "rest_api_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_documentation_partHandler", bridge.NewTFHandler(p, rt, "api_gateway_documentation_part_id", "aws_api_gateway_documentation_part"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_documentation_version{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_documentation_version_id")
		b.ImmutableAttributes("rest_api_id", "version")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_documentation_versionHandler", bridge.NewTFHandler(p, rt, "api_gateway_documentation_version_id", "aws_api_gateway_documentation_version"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_domain_name{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_domain_name_id", "certificate_upload_date", "cloudfront_domain_name", "cloudfront_zone_id", "endpoint_configuration", "regional_domain_name", "regional_zone_id")
		b.ImmutableAttributes("certificate_body", "certificate_chain", "certificate_private_key", "domain_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_domain_nameHandler", bridge.NewTFHandler(p, rt, "api_gateway_domain_name_id", "aws_api_gateway_domain_name"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_gateway_response{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_gateway_response_id")
		b.ImmutableAttributes("response_type", "rest_api_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_gateway_responseHandler", bridge.NewTFHandler(p, rt, "api_gateway_gateway_response_id", "aws_api_gateway_gateway_response"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_integration{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_integration_id", "cache_namespace", "passthrough_behavior")
		b.ImmutableAttributes("credentials", "http_method", "integration_http_method", "passthrough_behavior", "resource_id", "rest_api_id", "type")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_integrationHandler", bridge.NewTFHandler(p, rt, "api_gateway_integration_id", "aws_api_gateway_integration"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_integration_response{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_integration_response_id")
		b.ImmutableAttributes("http_method", "resource_id", "rest_api_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_integration_responseHandler", bridge.NewTFHandler(p, rt, "api_gateway_integration_response_id", "aws_api_gateway_integration_response"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_method{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_method_id")
		b.ImmutableAttributes("http_method", "resource_id", "rest_api_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_methodHandler", bridge.NewTFHandler(p, rt, "api_gateway_method_id", "aws_api_gateway_method"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_method_response{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_method_response_id")
		b.ImmutableAttributes("http_method", "resource_id", "rest_api_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_method_responseHandler", bridge.NewTFHandler(p, rt, "api_gateway_method_response_id", "aws_api_gateway_method_response"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_method_settings{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_method_settings_id")
		b.ImmutableAttributes("method_path", "rest_api_id", "stage_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_method_settingsHandler", bridge.NewTFHandler(p, rt, "api_gateway_method_settings_id", "aws_api_gateway_method_settings"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_model{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_model_id")
		b.ImmutableAttributes("content_type", "name", "rest_api_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_modelHandler", bridge.NewTFHandler(p, rt, "api_gateway_model_id", "aws_api_gateway_model"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_request_validator{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_request_validator_id")
		b.ImmutableAttributes("rest_api_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_request_validatorHandler", bridge.NewTFHandler(p, rt, "api_gateway_request_validator_id", "aws_api_gateway_request_validator"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_resource{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_resource_id", "path")
		b.ImmutableAttributes("rest_api_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_resourceHandler", bridge.NewTFHandler(p, rt, "api_gateway_resource_id", "aws_api_gateway_resource"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_rest_api{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_rest_api_id", "created_date", "endpoint_configuration", "execution_arn", "root_resource_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_rest_apiHandler", bridge.NewTFHandler(p, rt, "api_gateway_rest_api_id", "aws_api_gateway_rest_api"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_stage{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_stage_id", "execution_arn", "invoke_url")
		b.ImmutableAttributes("rest_api_id", "stage_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_stageHandler", bridge.NewTFHandler(p, rt, "api_gateway_stage_id", "aws_api_gateway_stage"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_usage_plan{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_usage_plan_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_usage_planHandler", bridge.NewTFHandler(p, rt, "api_gateway_usage_plan_id", "aws_api_gateway_usage_plan"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_usage_plan_key{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_usage_plan_key_id", "name", "value")
		b.ImmutableAttributes("key_id", "key_type", "usage_plan_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_usage_plan_keyHandler", bridge.NewTFHandler(p, rt, "api_gateway_usage_plan_key_id", "aws_api_gateway_usage_plan_key"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Api_gateway_vpc_link{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("api_gateway_vpc_link_id")
		b.ImmutableAttributes("target_arns")
	}))[0]
	sb.RegisterHandler("TerraformAws::Api_gateway_vpc_linkHandler", bridge.NewTFHandler(p, rt, "api_gateway_vpc_link_id", "aws_api_gateway_vpc_link"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&App_cookie_stickiness_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("app_cookie_stickiness_policy_id")
		b.ImmutableAttributes("cookie_name", "lb_port", "load_balancer", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::App_cookie_stickiness_policyHandler", bridge.NewTFHandler(p, rt, "app_cookie_stickiness_policy_id", "aws_app_cookie_stickiness_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Appautoscaling_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("appautoscaling_policy_id", "arn")
		b.ImmutableAttributes("alarms", "name", "scalable_dimension", "service_namespace")
	}))[0]
	sb.RegisterHandler("TerraformAws::Appautoscaling_policyHandler", bridge.NewTFHandler(p, rt, "appautoscaling_policy_id", "aws_appautoscaling_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Appautoscaling_scheduled_action{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("appautoscaling_scheduled_action_id", "arn")
		b.ImmutableAttributes("end_time", "name", "resource_id", "scalable_dimension", "scalable_target_action", "schedule", "service_namespace", "start_time")
	}))[0]
	sb.RegisterHandler("TerraformAws::Appautoscaling_scheduled_actionHandler", bridge.NewTFHandler(p, rt, "appautoscaling_scheduled_action_id", "aws_appautoscaling_scheduled_action"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Appautoscaling_target{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("appautoscaling_target_id", "role_arn")
		b.ImmutableAttributes("resource_id", "scalable_dimension", "service_namespace")
	}))[0]
	sb.RegisterHandler("TerraformAws::Appautoscaling_targetHandler", bridge.NewTFHandler(p, rt, "appautoscaling_target_id", "aws_appautoscaling_target"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Appmesh_mesh{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("appmesh_mesh_id", "arn", "created_date", "last_updated_date")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Appmesh_meshHandler", bridge.NewTFHandler(p, rt, "appmesh_mesh_id", "aws_appmesh_mesh"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Appmesh_route{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("appmesh_route_id", "arn", "created_date", "last_updated_date")
		b.ImmutableAttributes("mesh_name", "name", "virtual_router_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Appmesh_routeHandler", bridge.NewTFHandler(p, rt, "appmesh_route_id", "aws_appmesh_route"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Appmesh_virtual_node{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("appmesh_virtual_node_id", "arn", "created_date", "last_updated_date")
		b.ImmutableAttributes("mesh_name", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Appmesh_virtual_nodeHandler", bridge.NewTFHandler(p, rt, "appmesh_virtual_node_id", "aws_appmesh_virtual_node"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Appmesh_virtual_router{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("appmesh_virtual_router_id", "arn", "created_date", "last_updated_date")
		b.ImmutableAttributes("mesh_name", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Appmesh_virtual_routerHandler", bridge.NewTFHandler(p, rt, "appmesh_virtual_router_id", "aws_appmesh_virtual_router"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Appsync_api_key{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("appsync_api_key_id", "key")
	}))[0]
	sb.RegisterHandler("TerraformAws::Appsync_api_keyHandler", bridge.NewTFHandler(p, rt, "appsync_api_key_id", "aws_appsync_api_key"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Appsync_datasource{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("appsync_datasource_id", "arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Appsync_datasourceHandler", bridge.NewTFHandler(p, rt, "appsync_datasource_id", "aws_appsync_datasource"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Appsync_graphql_api{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("appsync_graphql_api_id", "arn", "uris")
	}))[0]
	sb.RegisterHandler("TerraformAws::Appsync_graphql_apiHandler", bridge.NewTFHandler(p, rt, "appsync_graphql_api_id", "aws_appsync_graphql_api"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Athena_database{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("athena_database_id")
		b.ImmutableAttributes("bucket", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Athena_databaseHandler", bridge.NewTFHandler(p, rt, "athena_database_id", "aws_athena_database"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Athena_named_query{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("athena_named_query_id")
		b.ImmutableAttributes("database", "description", "name", "query")
	}))[0]
	sb.RegisterHandler("TerraformAws::Athena_named_queryHandler", bridge.NewTFHandler(p, rt, "athena_named_query_id", "aws_athena_named_query"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Autoscaling_attachment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("autoscaling_attachment_id")
		b.ImmutableAttributes("alb_target_group_arn", "autoscaling_group_name", "elb")
	}))[0]
	sb.RegisterHandler("TerraformAws::Autoscaling_attachmentHandler", bridge.NewTFHandler(p, rt, "autoscaling_attachment_id", "aws_autoscaling_attachment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Autoscaling_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("autoscaling_group_id", "arn", "availability_zones", "default_cooldown", "desired_capacity", "health_check_type", "load_balancers", "name", "service_linked_role_arn", "target_group_arns", "vpc_zone_identifier")
		b.ImmutableAttributes("name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Autoscaling_groupHandler", bridge.NewTFHandler(p, rt, "autoscaling_group_id", "aws_autoscaling_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Autoscaling_lifecycle_hook{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("autoscaling_lifecycle_hook_id", "default_result")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Autoscaling_lifecycle_hookHandler", bridge.NewTFHandler(p, rt, "autoscaling_lifecycle_hook_id", "aws_autoscaling_lifecycle_hook"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Autoscaling_notification{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("autoscaling_notification_id")
		b.ImmutableAttributes("topic_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Autoscaling_notificationHandler", bridge.NewTFHandler(p, rt, "autoscaling_notification_id", "aws_autoscaling_notification"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Autoscaling_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("autoscaling_policy_id", "arn", "metric_aggregation_type")
		b.ImmutableAttributes("autoscaling_group_name", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Autoscaling_policyHandler", bridge.NewTFHandler(p, rt, "autoscaling_policy_id", "aws_autoscaling_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Autoscaling_schedule{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("autoscaling_schedule_id", "arn", "desired_capacity", "end_time", "max_size", "min_size", "recurrence", "start_time")
		b.ImmutableAttributes("autoscaling_group_name", "scheduled_action_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Autoscaling_scheduleHandler", bridge.NewTFHandler(p, rt, "autoscaling_schedule_id", "aws_autoscaling_schedule"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Batch_compute_environment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("batch_compute_environment_id", "arn", "ecc_cluster_arn", "ecs_cluster_arn", "status", "status_reason")
		b.ImmutableAttributes("compute_environment_name", "type")
	}))[0]
	sb.RegisterHandler("TerraformAws::Batch_compute_environmentHandler", bridge.NewTFHandler(p, rt, "batch_compute_environment_id", "aws_batch_compute_environment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Batch_job_definition{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("batch_job_definition_id", "arn", "revision")
		b.ImmutableAttributes("container_properties", "name", "parameters", "retry_strategy", "timeout", "type")
	}))[0]
	sb.RegisterHandler("TerraformAws::Batch_job_definitionHandler", bridge.NewTFHandler(p, rt, "batch_job_definition_id", "aws_batch_job_definition"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Batch_job_queue{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("batch_job_queue_id", "arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Batch_job_queueHandler", bridge.NewTFHandler(p, rt, "batch_job_queue_id", "aws_batch_job_queue"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Budgets_budget{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("budgets_budget_id", "account_id", "cost_filters", "cost_types", "name", "name_prefix")
		b.ImmutableAttributes("account_id", "name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Budgets_budgetHandler", bridge.NewTFHandler(p, rt, "budgets_budget_id", "aws_budgets_budget"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloud9_environment_ec2{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloud9_environment_ec2_id", "arn", "owner_arn", "type")
		b.ImmutableAttributes("automatic_stop_time_minutes", "instance_type", "owner_arn", "subnet_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cloud9_environment_ec2Handler", bridge.NewTFHandler(p, rt, "cloud9_environment_ec2_id", "aws_cloud9_environment_ec2"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloudformation_stack{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloudformation_stack_id", "outputs", "parameters", "policy_body", "template_body")
		b.ImmutableAttributes("disable_rollback", "name", "on_failure", "timeout_in_minutes")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cloudformation_stackHandler", bridge.NewTFHandler(p, rt, "cloudformation_stack_id", "aws_cloudformation_stack"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloudfront_distribution{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloudfront_distribution_id", "active_trusted_signers", "arn", "caller_reference", "domain_name", "etag", "hosted_zone_id", "in_progress_validation_batches", "last_modified_time", "status")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cloudfront_distributionHandler", bridge.NewTFHandler(p, rt, "cloudfront_distribution_id", "aws_cloudfront_distribution"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloudfront_origin_access_identity{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloudfront_origin_access_identity_id", "caller_reference", "cloudfront_access_identity_path", "etag", "iam_arn", "s3_canonical_user_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cloudfront_origin_access_identityHandler", bridge.NewTFHandler(p, rt, "cloudfront_origin_access_identity_id", "aws_cloudfront_origin_access_identity"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloudfront_public_key{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloudfront_public_key_id", "caller_reference", "etag", "name", "name_prefix")
		b.ImmutableAttributes("encoded_key", "name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cloudfront_public_keyHandler", bridge.NewTFHandler(p, rt, "cloudfront_public_key_id", "aws_cloudfront_public_key"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloudhsm_v2_cluster{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloudhsm_v2_cluster_id", "cluster_certificates", "cluster_id", "cluster_state", "security_group_id", "vpc_id")
		b.ImmutableAttributes("hsm_type", "source_backup_identifier", "subnet_ids")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cloudhsm_v2_clusterHandler", bridge.NewTFHandler(p, rt, "cloudhsm_v2_cluster_id", "aws_cloudhsm_v2_cluster"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloudhsm_v2_hsm{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloudhsm_v2_hsm_id", "availability_zone", "hsm_eni_id", "hsm_id", "hsm_state", "ip_address", "subnet_id")
		b.ImmutableAttributes("availability_zone", "cluster_id", "ip_address", "subnet_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cloudhsm_v2_hsmHandler", bridge.NewTFHandler(p, rt, "cloudhsm_v2_hsm_id", "aws_cloudhsm_v2_hsm"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloudtrail{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloudtrail_id", "arn", "home_region")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::CloudtrailHandler", bridge.NewTFHandler(p, rt, "cloudtrail_id", "aws_cloudtrail"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloudwatch_dashboard{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloudwatch_dashboard_id", "dashboard_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cloudwatch_dashboardHandler", bridge.NewTFHandler(p, rt, "cloudwatch_dashboard_id", "aws_cloudwatch_dashboard"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloudwatch_event_permission{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloudwatch_event_permission_id")
		b.ImmutableAttributes("statement_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cloudwatch_event_permissionHandler", bridge.NewTFHandler(p, rt, "cloudwatch_event_permission_id", "aws_cloudwatch_event_permission"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloudwatch_event_rule{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloudwatch_event_rule_id", "arn", "name")
		b.ImmutableAttributes("name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cloudwatch_event_ruleHandler", bridge.NewTFHandler(p, rt, "cloudwatch_event_rule_id", "aws_cloudwatch_event_rule"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloudwatch_event_target{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloudwatch_event_target_id", "target_id")
		b.ImmutableAttributes("rule", "target_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cloudwatch_event_targetHandler", bridge.NewTFHandler(p, rt, "cloudwatch_event_target_id", "aws_cloudwatch_event_target"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloudwatch_log_destination{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloudwatch_log_destination_id", "arn")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cloudwatch_log_destinationHandler", bridge.NewTFHandler(p, rt, "cloudwatch_log_destination_id", "aws_cloudwatch_log_destination"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloudwatch_log_destination_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloudwatch_log_destination_policy_id")
		b.ImmutableAttributes("destination_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cloudwatch_log_destination_policyHandler", bridge.NewTFHandler(p, rt, "cloudwatch_log_destination_policy_id", "aws_cloudwatch_log_destination_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloudwatch_log_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloudwatch_log_group_id", "arn", "name")
		b.ImmutableAttributes("name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cloudwatch_log_groupHandler", bridge.NewTFHandler(p, rt, "cloudwatch_log_group_id", "aws_cloudwatch_log_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloudwatch_log_metric_filter{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloudwatch_log_metric_filter_id")
		b.ImmutableAttributes("log_group_name", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cloudwatch_log_metric_filterHandler", bridge.NewTFHandler(p, rt, "cloudwatch_log_metric_filter_id", "aws_cloudwatch_log_metric_filter"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloudwatch_log_resource_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloudwatch_log_resource_policy_id")
		b.ImmutableAttributes("policy_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cloudwatch_log_resource_policyHandler", bridge.NewTFHandler(p, rt, "cloudwatch_log_resource_policy_id", "aws_cloudwatch_log_resource_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloudwatch_log_stream{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloudwatch_log_stream_id", "arn")
		b.ImmutableAttributes("log_group_name", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cloudwatch_log_streamHandler", bridge.NewTFHandler(p, rt, "cloudwatch_log_stream_id", "aws_cloudwatch_log_stream"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloudwatch_log_subscription_filter{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloudwatch_log_subscription_filter_id", "role_arn")
		b.ImmutableAttributes("destination_arn", "log_group_name", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cloudwatch_log_subscription_filterHandler", bridge.NewTFHandler(p, rt, "cloudwatch_log_subscription_filter_id", "aws_cloudwatch_log_subscription_filter"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cloudwatch_metric_alarm{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cloudwatch_metric_alarm_id", "arn", "evaluate_low_sample_count_percentiles")
		b.ImmutableAttributes("alarm_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cloudwatch_metric_alarmHandler", bridge.NewTFHandler(p, rt, "cloudwatch_metric_alarm_id", "aws_cloudwatch_metric_alarm"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Codebuild_project{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("codebuild_project_id", "arn", "badge_url", "description", "encryption_key")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Codebuild_projectHandler", bridge.NewTFHandler(p, rt, "codebuild_project_id", "aws_codebuild_project"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Codebuild_webhook{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("codebuild_webhook_id", "payload_url", "secret", "url")
		b.ImmutableAttributes("project_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Codebuild_webhookHandler", bridge.NewTFHandler(p, rt, "codebuild_webhook_id", "aws_codebuild_webhook"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Codecommit_repository{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("codecommit_repository_id", "arn", "clone_url_http", "clone_url_ssh", "repository_id")
		b.ImmutableAttributes("repository_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Codecommit_repositoryHandler", bridge.NewTFHandler(p, rt, "codecommit_repository_id", "aws_codecommit_repository"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Codecommit_trigger{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("codecommit_trigger_id", "configuration_id")
		b.ImmutableAttributes("repository_name", "trigger")
	}))[0]
	sb.RegisterHandler("TerraformAws::Codecommit_triggerHandler", bridge.NewTFHandler(p, rt, "codecommit_trigger_id", "aws_codecommit_trigger"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Codedeploy_app{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("codedeploy_app_id", "unique_id")
		b.ImmutableAttributes("compute_platform", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Codedeploy_appHandler", bridge.NewTFHandler(p, rt, "codedeploy_app_id", "aws_codedeploy_app"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Codedeploy_deployment_config{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("codedeploy_deployment_config_id", "deployment_config_id")
		b.ImmutableAttributes("compute_platform", "deployment_config_name", "minimum_healthy_hosts", "traffic_routing_config")
	}))[0]
	sb.RegisterHandler("TerraformAws::Codedeploy_deployment_configHandler", bridge.NewTFHandler(p, rt, "codedeploy_deployment_config_id", "aws_codedeploy_deployment_config"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Codedeploy_deployment_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("codedeploy_deployment_group_id", "blue_green_deployment_config", "deployment_style", "load_balancer_info")
		b.ImmutableAttributes("deployment_group_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Codedeploy_deployment_groupHandler", bridge.NewTFHandler(p, rt, "codedeploy_deployment_group_id", "aws_codedeploy_deployment_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Codepipeline{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("codepipeline_id", "arn")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::CodepipelineHandler", bridge.NewTFHandler(p, rt, "codepipeline_id", "aws_codepipeline"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Codepipeline_webhook{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("codepipeline_webhook_id", "url")
		b.ImmutableAttributes("authentication", "authentication_configuration", "filter", "name", "target_action", "target_pipeline")
	}))[0]
	sb.RegisterHandler("TerraformAws::Codepipeline_webhookHandler", bridge.NewTFHandler(p, rt, "codepipeline_webhook_id", "aws_codepipeline_webhook"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cognito_identity_pool{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cognito_identity_pool_id", "arn")
		b.ImmutableAttributes("developer_provider_name", "identity_pool_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cognito_identity_poolHandler", bridge.NewTFHandler(p, rt, "cognito_identity_pool_id", "aws_cognito_identity_pool"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cognito_identity_pool_roles_attachment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cognito_identity_pool_roles_attachment_id")
		b.ImmutableAttributes("identity_pool_id", "roles")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cognito_identity_pool_roles_attachmentHandler", bridge.NewTFHandler(p, rt, "cognito_identity_pool_roles_attachment_id", "aws_cognito_identity_pool_roles_attachment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cognito_identity_provider{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cognito_identity_provider_id")
		b.ImmutableAttributes("user_pool_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cognito_identity_providerHandler", bridge.NewTFHandler(p, rt, "cognito_identity_provider_id", "aws_cognito_identity_provider"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cognito_resource_server{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cognito_resource_server_id", "scope_identifiers")
		b.ImmutableAttributes("identifier", "name", "user_pool_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cognito_resource_serverHandler", bridge.NewTFHandler(p, rt, "cognito_resource_server_id", "aws_cognito_resource_server"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cognito_user_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cognito_user_group_id")
		b.ImmutableAttributes("name", "user_pool_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cognito_user_groupHandler", bridge.NewTFHandler(p, rt, "cognito_user_group_id", "aws_cognito_user_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cognito_user_pool{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cognito_user_pool_id", "admin_create_user_config", "arn", "creation_date", "email_verification_message", "email_verification_subject", "endpoint", "lambda_config", "last_modified_date", "password_policy", "verification_message_template")
		b.ImmutableAttributes("alias_attributes", "name", "schema", "username_attributes")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cognito_user_poolHandler", bridge.NewTFHandler(p, rt, "cognito_user_pool_id", "aws_cognito_user_pool"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cognito_user_pool_client{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cognito_user_pool_client_id", "client_secret")
		b.ImmutableAttributes("generate_secret", "user_pool_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cognito_user_pool_clientHandler", bridge.NewTFHandler(p, rt, "cognito_user_pool_client_id", "aws_cognito_user_pool_client"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Cognito_user_pool_domain{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("cognito_user_pool_domain_id", "aws_account_id", "cloudfront_distribution_arn", "s3_bucket", "version")
		b.ImmutableAttributes("certificate_arn", "domain", "user_pool_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Cognito_user_pool_domainHandler", bridge.NewTFHandler(p, rt, "cognito_user_pool_domain_id", "aws_cognito_user_pool_domain"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Config_aggregate_authorization{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("config_aggregate_authorization_id", "arn")
		b.ImmutableAttributes("account_id", "region")
	}))[0]
	sb.RegisterHandler("TerraformAws::Config_aggregate_authorizationHandler", bridge.NewTFHandler(p, rt, "config_aggregate_authorization_id", "aws_config_aggregate_authorization"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Config_config_rule{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("config_config_rule_id", "arn", "rule_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Config_config_ruleHandler", bridge.NewTFHandler(p, rt, "config_config_rule_id", "aws_config_config_rule"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Config_configuration_aggregator{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("config_configuration_aggregator_id", "arn")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Config_configuration_aggregatorHandler", bridge.NewTFHandler(p, rt, "config_configuration_aggregator_id", "aws_config_configuration_aggregator"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Config_configuration_recorder{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("config_configuration_recorder_id", "recording_group")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Config_configuration_recorderHandler", bridge.NewTFHandler(p, rt, "config_configuration_recorder_id", "aws_config_configuration_recorder"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Config_configuration_recorder_status{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("config_configuration_recorder_status_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Config_configuration_recorder_statusHandler", bridge.NewTFHandler(p, rt, "config_configuration_recorder_status_id", "aws_config_configuration_recorder_status"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Config_delivery_channel{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("config_delivery_channel_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Config_delivery_channelHandler", bridge.NewTFHandler(p, rt, "config_delivery_channel_id", "aws_config_delivery_channel"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Customer_gateway{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("customer_gateway_id")
		b.ImmutableAttributes("bgp_asn", "ip_address", "type")
	}))[0]
	sb.RegisterHandler("TerraformAws::Customer_gatewayHandler", bridge.NewTFHandler(p, rt, "customer_gateway_id", "aws_customer_gateway"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Datasync_agent{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("datasync_agent_id", "activation_key", "arn", "ip_address")
		b.ImmutableAttributes("activation_key", "ip_address")
	}))[0]
	sb.RegisterHandler("TerraformAws::Datasync_agentHandler", bridge.NewTFHandler(p, rt, "datasync_agent_id", "aws_datasync_agent"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Datasync_location_efs{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("datasync_location_efs_id", "arn", "uri")
		b.ImmutableAttributes("ec2_config", "efs_file_system_arn", "subdirectory")
	}))[0]
	sb.RegisterHandler("TerraformAws::Datasync_location_efsHandler", bridge.NewTFHandler(p, rt, "datasync_location_efs_id", "aws_datasync_location_efs"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Datasync_location_nfs{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("datasync_location_nfs_id", "arn", "uri")
		b.ImmutableAttributes("on_prem_config", "server_hostname", "subdirectory")
	}))[0]
	sb.RegisterHandler("TerraformAws::Datasync_location_nfsHandler", bridge.NewTFHandler(p, rt, "datasync_location_nfs_id", "aws_datasync_location_nfs"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Datasync_location_s3{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("datasync_location_s3_id", "arn", "uri")
		b.ImmutableAttributes("s3_bucket_arn", "s3_config", "subdirectory")
	}))[0]
	sb.RegisterHandler("TerraformAws::Datasync_location_s3Handler", bridge.NewTFHandler(p, rt, "datasync_location_s3_id", "aws_datasync_location_s3"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Datasync_task{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("datasync_task_id", "arn")
		b.ImmutableAttributes("cloudwatch_log_group_arn", "destination_location_arn", "source_location_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Datasync_taskHandler", bridge.NewTFHandler(p, rt, "datasync_task_id", "aws_datasync_task"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dax_cluster{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dax_cluster_id", "arn", "cluster_address", "configuration_endpoint", "maintenance_window", "nodes", "parameter_group_name", "port", "security_group_ids", "subnet_group_name")
		b.ImmutableAttributes("availability_zones", "cluster_name", "iam_role_arn", "node_type", "subnet_group_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dax_clusterHandler", bridge.NewTFHandler(p, rt, "dax_cluster_id", "aws_dax_cluster"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dax_parameter_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dax_parameter_group_id", "parameters")
		b.ImmutableAttributes("description", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dax_parameter_groupHandler", bridge.NewTFHandler(p, rt, "dax_parameter_group_id", "aws_dax_parameter_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dax_subnet_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dax_subnet_group_id", "vpc_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dax_subnet_groupHandler", bridge.NewTFHandler(p, rt, "dax_subnet_group_id", "aws_dax_subnet_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Db_cluster_snapshot{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("db_cluster_snapshot_id", "allocated_storage", "availability_zones", "db_cluster_snapshot_arn", "engine", "engine_version", "kms_key_id", "license_model", "port", "snapshot_type", "source_db_cluster_snapshot_arn", "status", "storage_encrypted", "vpc_id")
		b.ImmutableAttributes("db_cluster_identifier", "db_cluster_snapshot_identifier")
	}))[0]
	sb.RegisterHandler("TerraformAws::Db_cluster_snapshotHandler", bridge.NewTFHandler(p, rt, "db_cluster_snapshot_id", "aws_db_cluster_snapshot"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Db_event_subscription{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("db_event_subscription_id", "arn", "customer_aws_id", "name")
		b.ImmutableAttributes("name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Db_event_subscriptionHandler", bridge.NewTFHandler(p, rt, "db_event_subscription_id", "aws_db_event_subscription"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Db_instance{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("db_instance_id", "address", "allocated_storage", "apply_immediately", "arn", "availability_zone", "backup_retention_period", "backup_window", "ca_cert_identifier", "character_set_name", "db_subnet_group_name", "endpoint", "engine", "engine_version", "hosted_zone_id", "identifier", "identifier_prefix", "kms_key_id", "license_model", "maintenance_window", "monitoring_role_arn", "multi_az", "name", "option_group_name", "parameter_group_name", "port", "replicas", "resource_id", "status", "storage_type", "timezone", "username", "vpc_security_group_ids")
		b.ImmutableAttributes("availability_zone", "character_set_name", "engine", "identifier", "identifier_prefix", "kms_key_id", "name", "snapshot_identifier", "storage_encrypted", "timezone", "username")
	}))[0]
	sb.RegisterHandler("TerraformAws::Db_instanceHandler", bridge.NewTFHandler(p, rt, "db_instance_id", "aws_db_instance"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Db_option_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("db_option_group_id", "arn", "name", "name_prefix")
		b.ImmutableAttributes("engine_name", "major_engine_version", "name", "name_prefix", "option_group_description")
	}))[0]
	sb.RegisterHandler("TerraformAws::Db_option_groupHandler", bridge.NewTFHandler(p, rt, "db_option_group_id", "aws_db_option_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Db_parameter_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("db_parameter_group_id", "arn", "name", "name_prefix")
		b.ImmutableAttributes("description", "family", "name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Db_parameter_groupHandler", bridge.NewTFHandler(p, rt, "db_parameter_group_id", "aws_db_parameter_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Db_security_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("db_security_group_id", "arn")
		b.ImmutableAttributes("description", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Db_security_groupHandler", bridge.NewTFHandler(p, rt, "db_security_group_id", "aws_db_security_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Db_snapshot{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("db_snapshot_id", "allocated_storage", "availability_zone", "db_snapshot_arn", "encrypted", "engine", "engine_version", "iops", "kms_key_id", "license_model", "option_group_name", "port", "snapshot_type", "source_db_snapshot_identifier", "source_region", "status", "storage_type", "vpc_id")
		b.ImmutableAttributes("db_instance_identifier", "db_snapshot_identifier")
	}))[0]
	sb.RegisterHandler("TerraformAws::Db_snapshotHandler", bridge.NewTFHandler(p, rt, "db_snapshot_id", "aws_db_snapshot"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Db_subnet_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("db_subnet_group_id", "arn", "name", "name_prefix")
		b.ImmutableAttributes("name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Db_subnet_groupHandler", bridge.NewTFHandler(p, rt, "db_subnet_group_id", "aws_db_subnet_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Default_network_acl{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("default_network_acl_lyra_id", "owner_id", "vpc_id")
		b.ImmutableAttributes("default_network_acl_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Default_network_aclHandler", bridge.NewTFHandler(p, rt, "default_network_acl_lyra_id", "aws_default_network_acl"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Default_route_table{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("default_route_table_lyra_id", "owner_id", "route", "vpc_id")
		b.ImmutableAttributes("default_route_table_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Default_route_tableHandler", bridge.NewTFHandler(p, rt, "default_route_table_lyra_id", "aws_default_route_table"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Default_security_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("default_security_group_id", "arn", "name", "owner_id", "vpc_id")
		b.ImmutableAttributes("vpc_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Default_security_groupHandler", bridge.NewTFHandler(p, rt, "default_security_group_id", "aws_default_security_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Default_subnet{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("default_subnet_id", "arn", "assign_ipv6_address_on_creation", "availability_zone_id", "cidr_block", "ipv6_cidr_block", "ipv6_cidr_block_association_id", "map_public_ip_on_launch", "owner_id", "vpc_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Default_subnetHandler", bridge.NewTFHandler(p, rt, "default_subnet_id", "aws_default_subnet"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Default_vpc{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("default_vpc_id", "arn", "assign_generated_ipv6_cidr_block", "cidr_block", "default_network_acl_id", "default_route_table_id", "default_security_group_id", "dhcp_options_id", "enable_classiclink", "enable_classiclink_dns_support", "enable_dns_hostnames", "instance_tenancy", "ipv6_association_id", "ipv6_cidr_block", "main_route_table_id", "owner_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Default_vpcHandler", bridge.NewTFHandler(p, rt, "default_vpc_id", "aws_default_vpc"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Default_vpc_dhcp_options{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("default_vpc_dhcp_options_id", "domain_name", "domain_name_servers", "ntp_servers", "owner_id")
		b.ImmutableAttributes("netbios_name_servers", "netbios_node_type")
	}))[0]
	sb.RegisterHandler("TerraformAws::Default_vpc_dhcp_optionsHandler", bridge.NewTFHandler(p, rt, "default_vpc_dhcp_options_id", "aws_default_vpc_dhcp_options"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Devicefarm_project{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("devicefarm_project_id", "arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Devicefarm_projectHandler", bridge.NewTFHandler(p, rt, "devicefarm_project_id", "aws_devicefarm_project"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Directory_service_conditional_forwarder{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("directory_service_conditional_forwarder_id")
		b.ImmutableAttributes("directory_id", "remote_domain_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Directory_service_conditional_forwarderHandler", bridge.NewTFHandler(p, rt, "directory_service_conditional_forwarder_id", "aws_directory_service_conditional_forwarder"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Directory_service_directory{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("directory_service_directory_id", "access_url", "alias", "dns_ip_addresses", "edition", "security_group_id", "short_name", "size")
		b.ImmutableAttributes("alias", "connect_settings", "description", "edition", "name", "password", "short_name", "size", "type", "vpc_settings")
	}))[0]
	sb.RegisterHandler("TerraformAws::Directory_service_directoryHandler", bridge.NewTFHandler(p, rt, "directory_service_directory_id", "aws_directory_service_directory"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dlm_lifecycle_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dlm_lifecycle_policy_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dlm_lifecycle_policyHandler", bridge.NewTFHandler(p, rt, "dlm_lifecycle_policy_id", "aws_dlm_lifecycle_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dms_certificate{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dms_certificate_id", "certificate_arn")
		b.ImmutableAttributes("certificate_id", "certificate_pem", "certificate_wallet")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dms_certificateHandler", bridge.NewTFHandler(p, rt, "dms_certificate_id", "aws_dms_certificate"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dms_endpoint{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dms_endpoint_id", "certificate_arn", "endpoint_arn", "extra_connection_attributes", "kms_key_arn", "ssl_mode")
		b.ImmutableAttributes("endpoint_id", "kms_key_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dms_endpointHandler", bridge.NewTFHandler(p, rt, "dms_endpoint_id", "aws_dms_endpoint"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dms_replication_instance{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dms_replication_instance_id", "allocated_storage", "auto_minor_version_upgrade", "availability_zone", "engine_version", "kms_key_arn", "multi_az", "preferred_maintenance_window", "publicly_accessible", "replication_instance_arn", "replication_instance_private_ips", "replication_instance_public_ips", "replication_subnet_group_id", "vpc_security_group_ids")
		b.ImmutableAttributes("availability_zone", "kms_key_arn", "publicly_accessible", "replication_instance_id", "replication_subnet_group_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dms_replication_instanceHandler", bridge.NewTFHandler(p, rt, "dms_replication_instance_id", "aws_dms_replication_instance"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dms_replication_subnet_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dms_replication_subnet_group_id", "replication_subnet_group_arn", "vpc_id")
		b.ImmutableAttributes("replication_subnet_group_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dms_replication_subnet_groupHandler", bridge.NewTFHandler(p, rt, "dms_replication_subnet_group_id", "aws_dms_replication_subnet_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dms_replication_task{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dms_replication_task_id", "replication_task_arn")
		b.ImmutableAttributes("replication_instance_arn", "replication_task_id", "source_endpoint_arn", "target_endpoint_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dms_replication_taskHandler", bridge.NewTFHandler(p, rt, "dms_replication_task_id", "aws_dms_replication_task"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Docdb_cluster_parameter_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("docdb_cluster_parameter_group_id", "arn", "name", "name_prefix")
		b.ImmutableAttributes("description", "family", "name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Docdb_cluster_parameter_groupHandler", bridge.NewTFHandler(p, rt, "docdb_cluster_parameter_group_id", "aws_docdb_cluster_parameter_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Docdb_subnet_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("docdb_subnet_group_id", "arn", "name", "name_prefix")
		b.ImmutableAttributes("name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Docdb_subnet_groupHandler", bridge.NewTFHandler(p, rt, "docdb_subnet_group_id", "aws_docdb_subnet_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dx_bgp_peer{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dx_bgp_peer_id", "amazon_address", "bgp_auth_key", "bgp_status", "customer_address")
		b.ImmutableAttributes("address_family", "amazon_address", "bgp_asn", "bgp_auth_key", "customer_address", "virtual_interface_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dx_bgp_peerHandler", bridge.NewTFHandler(p, rt, "dx_bgp_peer_id", "aws_dx_bgp_peer"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dx_connection{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dx_connection_id", "arn", "jumbo_frame_capable")
		b.ImmutableAttributes("bandwidth", "location", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dx_connectionHandler", bridge.NewTFHandler(p, rt, "dx_connection_id", "aws_dx_connection"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dx_connection_association{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dx_connection_association_id")
		b.ImmutableAttributes("connection_id", "lag_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dx_connection_associationHandler", bridge.NewTFHandler(p, rt, "dx_connection_association_id", "aws_dx_connection_association"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dx_gateway{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dx_gateway_id")
		b.ImmutableAttributes("amazon_side_asn", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dx_gatewayHandler", bridge.NewTFHandler(p, rt, "dx_gateway_id", "aws_dx_gateway"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dx_gateway_association{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dx_gateway_association_id")
		b.ImmutableAttributes("dx_gateway_id", "vpn_gateway_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dx_gateway_associationHandler", bridge.NewTFHandler(p, rt, "dx_gateway_association_id", "aws_dx_gateway_association"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dx_hosted_private_virtual_interface{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dx_hosted_private_virtual_interface_id", "amazon_address", "arn", "bgp_auth_key", "customer_address", "jumbo_frame_capable")
		b.ImmutableAttributes("address_family", "amazon_address", "bgp_asn", "bgp_auth_key", "connection_id", "customer_address", "mtu", "name", "owner_account_id", "vlan")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dx_hosted_private_virtual_interfaceHandler", bridge.NewTFHandler(p, rt, "dx_hosted_private_virtual_interface_id", "aws_dx_hosted_private_virtual_interface"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dx_hosted_private_virtual_interface_accepter{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dx_hosted_private_virtual_interface_accepter_id", "arn")
		b.ImmutableAttributes("dx_gateway_id", "virtual_interface_id", "vpn_gateway_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dx_hosted_private_virtual_interface_accepterHandler", bridge.NewTFHandler(p, rt, "dx_hosted_private_virtual_interface_accepter_id", "aws_dx_hosted_private_virtual_interface_accepter"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dx_hosted_public_virtual_interface{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dx_hosted_public_virtual_interface_id", "amazon_address", "arn", "bgp_auth_key", "customer_address")
		b.ImmutableAttributes("address_family", "amazon_address", "bgp_asn", "bgp_auth_key", "connection_id", "customer_address", "name", "owner_account_id", "route_filter_prefixes", "vlan")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dx_hosted_public_virtual_interfaceHandler", bridge.NewTFHandler(p, rt, "dx_hosted_public_virtual_interface_id", "aws_dx_hosted_public_virtual_interface"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dx_hosted_public_virtual_interface_accepter{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dx_hosted_public_virtual_interface_accepter_id", "arn")
		b.ImmutableAttributes("virtual_interface_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dx_hosted_public_virtual_interface_accepterHandler", bridge.NewTFHandler(p, rt, "dx_hosted_public_virtual_interface_accepter_id", "aws_dx_hosted_public_virtual_interface_accepter"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dx_lag{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dx_lag_id", "arn", "number_of_connections")
		b.ImmutableAttributes("connections_bandwidth", "location", "number_of_connections")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dx_lagHandler", bridge.NewTFHandler(p, rt, "dx_lag_id", "aws_dx_lag"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dx_private_virtual_interface{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dx_private_virtual_interface_id", "amazon_address", "arn", "bgp_auth_key", "customer_address", "jumbo_frame_capable")
		b.ImmutableAttributes("address_family", "amazon_address", "bgp_asn", "bgp_auth_key", "connection_id", "customer_address", "dx_gateway_id", "name", "vlan", "vpn_gateway_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dx_private_virtual_interfaceHandler", bridge.NewTFHandler(p, rt, "dx_private_virtual_interface_id", "aws_dx_private_virtual_interface"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dx_public_virtual_interface{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dx_public_virtual_interface_id", "amazon_address", "arn", "bgp_auth_key", "customer_address")
		b.ImmutableAttributes("address_family", "amazon_address", "bgp_asn", "bgp_auth_key", "connection_id", "customer_address", "name", "route_filter_prefixes", "vlan")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dx_public_virtual_interfaceHandler", bridge.NewTFHandler(p, rt, "dx_public_virtual_interface_id", "aws_dx_public_virtual_interface"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dynamodb_global_table{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dynamodb_global_table_id", "arn")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dynamodb_global_tableHandler", bridge.NewTFHandler(p, rt, "dynamodb_global_table_id", "aws_dynamodb_global_table"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dynamodb_table{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dynamodb_table_id", "arn", "point_in_time_recovery", "server_side_encryption", "stream_arn", "stream_label", "stream_view_type")
		b.ImmutableAttributes("hash_key", "local_secondary_index", "name", "range_key")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dynamodb_tableHandler", bridge.NewTFHandler(p, rt, "dynamodb_table_id", "aws_dynamodb_table"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Dynamodb_table_item{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("dynamodb_table_item_id")
		b.ImmutableAttributes("hash_key", "range_key", "table_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Dynamodb_table_itemHandler", bridge.NewTFHandler(p, rt, "dynamodb_table_item_id", "aws_dynamodb_table_item"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ebs_snapshot{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ebs_snapshot_id", "data_encryption_key_id", "encrypted", "kms_key_id", "owner_alias", "owner_id", "volume_size")
		b.ImmutableAttributes("description", "tags", "volume_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ebs_snapshotHandler", bridge.NewTFHandler(p, rt, "ebs_snapshot_id", "aws_ebs_snapshot"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ebs_snapshot_copy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ebs_snapshot_copy_id", "data_encryption_key_id", "owner_alias", "owner_id", "volume_id", "volume_size")
		b.ImmutableAttributes("description", "encrypted", "kms_key_id", "source_region", "source_snapshot_id", "tags")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ebs_snapshot_copyHandler", bridge.NewTFHandler(p, rt, "ebs_snapshot_copy_id", "aws_ebs_snapshot_copy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ebs_volume{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ebs_volume_id", "arn", "encrypted", "iops", "kms_key_id", "size", "snapshot_id", "type")
		b.ImmutableAttributes("availability_zone", "encrypted", "kms_key_id", "snapshot_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ebs_volumeHandler", bridge.NewTFHandler(p, rt, "ebs_volume_id", "aws_ebs_volume"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ec2_capacity_reservation{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ec2_capacity_reservation_id")
		b.ImmutableAttributes("availability_zone", "ebs_optimized", "ephemeral_storage", "instance_match_criteria", "instance_platform", "instance_type", "tenancy")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ec2_capacity_reservationHandler", bridge.NewTFHandler(p, rt, "ec2_capacity_reservation_id", "aws_ec2_capacity_reservation"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ec2_fleet{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ec2_fleet_id")
		b.ImmutableAttributes("launch_template_config", "replace_unhealthy_instances", "tags", "terminate_instances_with_expiration", "type")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ec2_fleetHandler", bridge.NewTFHandler(p, rt, "ec2_fleet_id", "aws_ec2_fleet"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ec2_transit_gateway{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ec2_transit_gateway_id", "arn", "association_default_route_table_id", "owner_id", "propagation_default_route_table_id")
		b.ImmutableAttributes("amazon_side_asn", "auto_accept_shared_attachments", "default_route_table_association", "default_route_table_propagation", "description", "dns_support", "vpn_ecmp_support")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ec2_transit_gatewayHandler", bridge.NewTFHandler(p, rt, "ec2_transit_gateway_id", "aws_ec2_transit_gateway"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ec2_transit_gateway_route{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ec2_transit_gateway_route_id")
		b.ImmutableAttributes("destination_cidr_block", "transit_gateway_attachment_id", "transit_gateway_route_table_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ec2_transit_gateway_routeHandler", bridge.NewTFHandler(p, rt, "ec2_transit_gateway_route_id", "aws_ec2_transit_gateway_route"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ec2_transit_gateway_route_table{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ec2_transit_gateway_route_table_id", "default_association_route_table", "default_propagation_route_table")
		b.ImmutableAttributes("transit_gateway_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ec2_transit_gateway_route_tableHandler", bridge.NewTFHandler(p, rt, "ec2_transit_gateway_route_table_id", "aws_ec2_transit_gateway_route_table"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ec2_transit_gateway_route_table_association{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ec2_transit_gateway_route_table_association_id", "resource_id", "resource_type")
		b.ImmutableAttributes("transit_gateway_attachment_id", "transit_gateway_route_table_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ec2_transit_gateway_route_table_associationHandler", bridge.NewTFHandler(p, rt, "ec2_transit_gateway_route_table_association_id", "aws_ec2_transit_gateway_route_table_association"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ec2_transit_gateway_route_table_propagation{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ec2_transit_gateway_route_table_propagation_id", "resource_id", "resource_type")
		b.ImmutableAttributes("transit_gateway_attachment_id", "transit_gateway_route_table_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ec2_transit_gateway_route_table_propagationHandler", bridge.NewTFHandler(p, rt, "ec2_transit_gateway_route_table_propagation_id", "aws_ec2_transit_gateway_route_table_propagation"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ec2_transit_gateway_vpc_attachment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ec2_transit_gateway_vpc_attachment_id", "vpc_owner_id")
		b.ImmutableAttributes("transit_gateway_id", "vpc_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ec2_transit_gateway_vpc_attachmentHandler", bridge.NewTFHandler(p, rt, "ec2_transit_gateway_vpc_attachment_id", "aws_ec2_transit_gateway_vpc_attachment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ecr_lifecycle_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ecr_lifecycle_policy_id", "registry_id")
		b.ImmutableAttributes("policy", "repository")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ecr_lifecycle_policyHandler", bridge.NewTFHandler(p, rt, "ecr_lifecycle_policy_id", "aws_ecr_lifecycle_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ecr_repository{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ecr_repository_id", "arn", "registry_id", "repository_url")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ecr_repositoryHandler", bridge.NewTFHandler(p, rt, "ecr_repository_id", "aws_ecr_repository"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ecr_repository_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ecr_repository_policy_id", "registry_id")
		b.ImmutableAttributes("repository")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ecr_repository_policyHandler", bridge.NewTFHandler(p, rt, "ecr_repository_policy_id", "aws_ecr_repository_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ecs_cluster{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ecs_cluster_id", "arn")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ecs_clusterHandler", bridge.NewTFHandler(p, rt, "ecs_cluster_id", "aws_ecs_cluster"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ecs_service{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ecs_service_id", "cluster", "iam_role", "platform_version")
		b.ImmutableAttributes("cluster", "iam_role", "launch_type", "load_balancer", "name", "ordered_placement_strategy", "placement_constraints", "placement_strategy", "propagate_tags", "scheduling_strategy", "service_registries")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ecs_serviceHandler", bridge.NewTFHandler(p, rt, "ecs_service_id", "aws_ecs_service"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ecs_task_definition{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ecs_task_definition_id", "arn", "network_mode", "revision")
		b.ImmutableAttributes("container_definitions", "cpu", "execution_role_arn", "family", "ipc_mode", "memory", "network_mode", "pid_mode", "placement_constraints", "requires_compatibilities", "task_role_arn", "volume")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ecs_task_definitionHandler", bridge.NewTFHandler(p, rt, "ecs_task_definition_id", "aws_ecs_task_definition"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Efs_file_system{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("efs_file_system_id", "arn", "creation_token", "dns_name", "encrypted", "kms_key_id", "performance_mode", "reference_name")
		b.ImmutableAttributes("creation_token", "encrypted", "kms_key_id", "performance_mode")
	}))[0]
	sb.RegisterHandler("TerraformAws::Efs_file_systemHandler", bridge.NewTFHandler(p, rt, "efs_file_system_id", "aws_efs_file_system"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Efs_mount_target{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("efs_mount_target_id", "dns_name", "file_system_arn", "ip_address", "network_interface_id", "security_groups")
		b.ImmutableAttributes("file_system_id", "ip_address", "subnet_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Efs_mount_targetHandler", bridge.NewTFHandler(p, rt, "efs_mount_target_id", "aws_efs_mount_target"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Egress_only_internet_gateway{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("egress_only_internet_gateway_id")
		b.ImmutableAttributes("vpc_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Egress_only_internet_gatewayHandler", bridge.NewTFHandler(p, rt, "egress_only_internet_gateway_id", "aws_egress_only_internet_gateway"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Eip{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("eip_id", "allocation_id", "association_id", "domain", "instance", "network_interface", "private_ip", "public_ip", "public_ipv4_pool", "vpc")
		b.ImmutableAttributes("public_ipv4_pool", "vpc")
	}))[0]
	sb.RegisterHandler("TerraformAws::EipHandler", bridge.NewTFHandler(p, rt, "eip_id", "aws_eip"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Eip_association{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("eip_association_id", "allocation_id", "instance_id", "network_interface_id", "private_ip_address", "public_ip")
		b.ImmutableAttributes("allocation_id", "allow_reassociation", "instance_id", "network_interface_id", "private_ip_address", "public_ip")
	}))[0]
	sb.RegisterHandler("TerraformAws::Eip_associationHandler", bridge.NewTFHandler(p, rt, "eip_association_id", "aws_eip_association"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Eks_cluster{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("eks_cluster_id", "arn", "certificate_authority", "created_at", "endpoint", "platform_version", "version")
		b.ImmutableAttributes("name", "role_arn", "vpc_config")
	}))[0]
	sb.RegisterHandler("TerraformAws::Eks_clusterHandler", bridge.NewTFHandler(p, rt, "eks_cluster_id", "aws_eks_cluster"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Elastic_beanstalk_application{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("elastic_beanstalk_application_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Elastic_beanstalk_applicationHandler", bridge.NewTFHandler(p, rt, "elastic_beanstalk_application_id", "aws_elastic_beanstalk_application"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Elastic_beanstalk_application_version{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("elastic_beanstalk_application_version_id")
		b.ImmutableAttributes("application", "bucket", "key", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Elastic_beanstalk_application_versionHandler", bridge.NewTFHandler(p, rt, "elastic_beanstalk_application_version_id", "aws_elastic_beanstalk_application_version"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Elastic_beanstalk_configuration_template{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("elastic_beanstalk_configuration_template_id", "setting")
		b.ImmutableAttributes("application", "environment_id", "name", "solution_stack_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Elastic_beanstalk_configuration_templateHandler", bridge.NewTFHandler(p, rt, "elastic_beanstalk_configuration_template_id", "aws_elastic_beanstalk_configuration_template"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Elastic_beanstalk_environment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("elastic_beanstalk_environment_id", "all_settings", "arn", "autoscaling_groups", "cname", "cname_prefix", "instances", "launch_configurations", "load_balancers", "platform_arn", "queues", "solution_stack_name", "triggers", "version_label")
		b.ImmutableAttributes("cname_prefix", "name", "tier")
	}))[0]
	sb.RegisterHandler("TerraformAws::Elastic_beanstalk_environmentHandler", bridge.NewTFHandler(p, rt, "elastic_beanstalk_environment_id", "aws_elastic_beanstalk_environment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Elasticache_cluster{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("elasticache_cluster_id", "apply_immediately", "availability_zone", "az_mode", "cache_nodes", "cluster_address", "configuration_endpoint", "engine", "engine_version", "maintenance_window", "node_type", "num_cache_nodes", "parameter_group_name", "replication_group_id", "security_group_ids", "security_group_names", "snapshot_window", "subnet_group_name")
		b.ImmutableAttributes("availability_zone", "availability_zones", "cluster_id", "engine", "port", "replication_group_id", "security_group_names", "snapshot_arns", "snapshot_name", "subnet_group_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Elasticache_clusterHandler", bridge.NewTFHandler(p, rt, "elasticache_cluster_id", "aws_elasticache_cluster"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Elasticache_parameter_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("elasticache_parameter_group_id")
		b.ImmutableAttributes("description", "family", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Elasticache_parameter_groupHandler", bridge.NewTFHandler(p, rt, "elasticache_parameter_group_id", "aws_elasticache_parameter_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Elasticache_replication_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("elasticache_replication_group_id", "apply_immediately", "cluster_mode", "configuration_endpoint_address", "engine_version", "maintenance_window", "member_clusters", "node_type", "number_cache_clusters", "parameter_group_name", "primary_endpoint_address", "security_group_ids", "security_group_names", "snapshot_window", "subnet_group_name")
		b.ImmutableAttributes("at_rest_encryption_enabled", "auth_token", "availability_zones", "engine", "port", "replication_group_id", "security_group_names", "snapshot_arns", "snapshot_name", "subnet_group_name", "transit_encryption_enabled")
	}))[0]
	sb.RegisterHandler("TerraformAws::Elasticache_replication_groupHandler", bridge.NewTFHandler(p, rt, "elasticache_replication_group_id", "aws_elasticache_replication_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Elasticache_security_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("elasticache_security_group_id")
		b.ImmutableAttributes("description", "name", "security_group_names")
	}))[0]
	sb.RegisterHandler("TerraformAws::Elasticache_security_groupHandler", bridge.NewTFHandler(p, rt, "elasticache_security_group_id", "aws_elasticache_security_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Elasticache_subnet_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("elasticache_subnet_group_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Elasticache_subnet_groupHandler", bridge.NewTFHandler(p, rt, "elasticache_subnet_group_id", "aws_elasticache_subnet_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Elasticsearch_domain{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("elasticsearch_domain_id", "access_policies", "advanced_options", "arn", "cluster_config", "domain_id", "ebs_options", "encrypt_at_rest", "endpoint", "kibana_endpoint", "node_to_node_encryption")
		b.ImmutableAttributes("domain_name", "vpc_options")
	}))[0]
	sb.RegisterHandler("TerraformAws::Elasticsearch_domainHandler", bridge.NewTFHandler(p, rt, "elasticsearch_domain_id", "aws_elasticsearch_domain"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Elasticsearch_domain_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("elasticsearch_domain_policy_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Elasticsearch_domain_policyHandler", bridge.NewTFHandler(p, rt, "elasticsearch_domain_policy_id", "aws_elasticsearch_domain_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Elastictranscoder_pipeline{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("elastictranscoder_pipeline_id", "arn", "content_config", "name", "output_bucket", "thumbnail_config")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Elastictranscoder_pipelineHandler", bridge.NewTFHandler(p, rt, "elastictranscoder_pipeline_id", "aws_elastictranscoder_pipeline"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Elastictranscoder_preset{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("elastictranscoder_preset_id", "arn", "name", "type")
		b.ImmutableAttributes("audio", "audio_codec_options", "container", "description", "name", "thumbnails", "video", "video_codec_options", "video_watermarks")
	}))[0]
	sb.RegisterHandler("TerraformAws::Elastictranscoder_presetHandler", bridge.NewTFHandler(p, rt, "elastictranscoder_preset_id", "aws_elastictranscoder_preset"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Elb{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("elb_id", "arn", "availability_zones", "dns_name", "health_check", "instances", "internal", "name", "security_groups", "source_security_group", "source_security_group_id", "subnets", "zone_id")
		b.ImmutableAttributes("internal", "name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::ElbHandler", bridge.NewTFHandler(p, rt, "elb_id", "aws_elb"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Elb_attachment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("elb_attachment_id")
		b.ImmutableAttributes("elb", "instance")
	}))[0]
	sb.RegisterHandler("TerraformAws::Elb_attachmentHandler", bridge.NewTFHandler(p, rt, "elb_attachment_id", "aws_elb_attachment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Emr_cluster{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("emr_cluster_id", "cluster_state", "core_instance_count", "core_instance_type", "instance_group", "keep_job_flow_alive_when_no_steps", "master_instance_type", "master_public_dns", "scale_down_behavior", "step", "termination_protection")
		b.ImmutableAttributes("additional_info", "applications", "autoscaling_role", "bootstrap_action", "configurations", "configurations_json", "core_instance_type", "custom_ami_id", "ebs_root_volume_size", "ec2_attributes", "instance_group", "keep_job_flow_alive_when_no_steps", "kerberos_attributes", "log_uri", "master_instance_type", "name", "release_label", "scale_down_behavior", "security_configuration", "service_role", "step")
	}))[0]
	sb.RegisterHandler("TerraformAws::Emr_clusterHandler", bridge.NewTFHandler(p, rt, "emr_cluster_id", "aws_emr_cluster"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Emr_instance_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("emr_instance_group_id", "running_instance_count", "status")
		b.ImmutableAttributes("cluster_id", "ebs_config", "ebs_optimized", "instance_type", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Emr_instance_groupHandler", bridge.NewTFHandler(p, rt, "emr_instance_group_id", "aws_emr_instance_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Emr_security_configuration{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("emr_security_configuration_id", "creation_date", "name")
		b.ImmutableAttributes("configuration", "name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Emr_security_configurationHandler", bridge.NewTFHandler(p, rt, "emr_security_configuration_id", "aws_emr_security_configuration"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Flow_log{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("flow_log_id", "log_destination", "log_group_name")
		b.ImmutableAttributes("eni_id", "iam_role_arn", "log_destination", "log_destination_type", "log_group_name", "subnet_id", "traffic_type", "vpc_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Flow_logHandler", bridge.NewTFHandler(p, rt, "flow_log_id", "aws_flow_log"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Gamelift_alias{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("gamelift_alias_id", "arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Gamelift_aliasHandler", bridge.NewTFHandler(p, rt, "gamelift_alias_id", "aws_gamelift_alias"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Gamelift_build{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("gamelift_build_id")
		b.ImmutableAttributes("operating_system", "storage_location")
	}))[0]
	sb.RegisterHandler("TerraformAws::Gamelift_buildHandler", bridge.NewTFHandler(p, rt, "gamelift_build_id", "aws_gamelift_build"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Gamelift_fleet{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("gamelift_fleet_id", "arn", "log_paths", "metric_groups", "operating_system")
		b.ImmutableAttributes("build_id", "ec2_instance_type")
	}))[0]
	sb.RegisterHandler("TerraformAws::Gamelift_fleetHandler", bridge.NewTFHandler(p, rt, "gamelift_fleet_id", "aws_gamelift_fleet"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Gamelift_game_session_queue{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("gamelift_game_session_queue_id", "arn")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Gamelift_game_session_queueHandler", bridge.NewTFHandler(p, rt, "gamelift_game_session_queue_id", "aws_gamelift_game_session_queue"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Glacier_vault{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("glacier_vault_id", "arn", "location")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Glacier_vaultHandler", bridge.NewTFHandler(p, rt, "glacier_vault_id", "aws_glacier_vault"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Glacier_vault_lock{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("glacier_vault_lock_id")
		b.ImmutableAttributes("complete_lock", "policy", "vault_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Glacier_vault_lockHandler", bridge.NewTFHandler(p, rt, "glacier_vault_lock_id", "aws_glacier_vault_lock"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Globalaccelerator_accelerator{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("globalaccelerator_accelerator_id", "ip_sets")
	}))[0]
	sb.RegisterHandler("TerraformAws::Globalaccelerator_acceleratorHandler", bridge.NewTFHandler(p, rt, "globalaccelerator_accelerator_id", "aws_globalaccelerator_accelerator"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Glue_catalog_database{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("glue_catalog_database_id", "catalog_id")
		b.ImmutableAttributes("catalog_id", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Glue_catalog_databaseHandler", bridge.NewTFHandler(p, rt, "glue_catalog_database_id", "aws_glue_catalog_database"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Glue_catalog_table{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("glue_catalog_table_id", "catalog_id")
		b.ImmutableAttributes("catalog_id", "database_name", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Glue_catalog_tableHandler", bridge.NewTFHandler(p, rt, "glue_catalog_table_id", "aws_glue_catalog_table"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Glue_classifier{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("glue_classifier_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Glue_classifierHandler", bridge.NewTFHandler(p, rt, "glue_classifier_id", "aws_glue_classifier"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Glue_connection{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("glue_connection_id", "catalog_id")
		b.ImmutableAttributes("catalog_id", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Glue_connectionHandler", bridge.NewTFHandler(p, rt, "glue_connection_id", "aws_glue_connection"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Glue_crawler{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("glue_crawler_id")
		b.ImmutableAttributes("database_name", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Glue_crawlerHandler", bridge.NewTFHandler(p, rt, "glue_crawler_id", "aws_glue_crawler"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Glue_job{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("glue_job_id", "execution_property")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Glue_jobHandler", bridge.NewTFHandler(p, rt, "glue_job_id", "aws_glue_job"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Glue_security_configuration{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("glue_security_configuration_id")
		b.ImmutableAttributes("encryption_configuration", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Glue_security_configurationHandler", bridge.NewTFHandler(p, rt, "glue_security_configuration_id", "aws_glue_security_configuration"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Glue_trigger{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("glue_trigger_id")
		b.ImmutableAttributes("name", "type")
	}))[0]
	sb.RegisterHandler("TerraformAws::Glue_triggerHandler", bridge.NewTFHandler(p, rt, "glue_trigger_id", "aws_glue_trigger"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Guardduty_detector{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("guardduty_detector_id", "account_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Guardduty_detectorHandler", bridge.NewTFHandler(p, rt, "guardduty_detector_id", "aws_guardduty_detector"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Guardduty_ipset{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("guardduty_ipset_id")
		b.ImmutableAttributes("detector_id", "format")
	}))[0]
	sb.RegisterHandler("TerraformAws::Guardduty_ipsetHandler", bridge.NewTFHandler(p, rt, "guardduty_ipset_id", "aws_guardduty_ipset"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Guardduty_member{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("guardduty_member_id", "relationship_status")
		b.ImmutableAttributes("account_id", "detector_id", "disable_email_notification", "email", "invitation_message")
	}))[0]
	sb.RegisterHandler("TerraformAws::Guardduty_memberHandler", bridge.NewTFHandler(p, rt, "guardduty_member_id", "aws_guardduty_member"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Guardduty_threatintelset{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("guardduty_threatintelset_id")
		b.ImmutableAttributes("detector_id", "format")
	}))[0]
	sb.RegisterHandler("TerraformAws::Guardduty_threatintelsetHandler", bridge.NewTFHandler(p, rt, "guardduty_threatintelset_id", "aws_guardduty_threatintelset"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_access_key{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_access_key_id", "encrypted_secret", "key_fingerprint", "secret", "ses_smtp_password", "status")
		b.ImmutableAttributes("pgp_key", "user")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_access_keyHandler", bridge.NewTFHandler(p, rt, "iam_access_key_id", "aws_iam_access_key"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_account_alias{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_account_alias_id")
		b.ImmutableAttributes("account_alias")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_account_aliasHandler", bridge.NewTFHandler(p, rt, "iam_account_alias_id", "aws_iam_account_alias"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_account_password_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_account_password_policy_id", "expire_passwords", "hard_expiry", "max_password_age", "password_reuse_prevention", "require_lowercase_characters", "require_numbers", "require_symbols", "require_uppercase_characters")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_account_password_policyHandler", bridge.NewTFHandler(p, rt, "iam_account_password_policy_id", "aws_iam_account_password_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_group_id", "arn", "unique_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_groupHandler", bridge.NewTFHandler(p, rt, "iam_group_id", "aws_iam_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_group_membership{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_group_membership_id")
		b.ImmutableAttributes("group", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_group_membershipHandler", bridge.NewTFHandler(p, rt, "iam_group_membership_id", "aws_iam_group_membership"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_group_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_group_policy_id", "name")
		b.ImmutableAttributes("group", "name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_group_policyHandler", bridge.NewTFHandler(p, rt, "iam_group_policy_id", "aws_iam_group_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_group_policy_attachment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_group_policy_attachment_id")
		b.ImmutableAttributes("group", "policy_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_group_policy_attachmentHandler", bridge.NewTFHandler(p, rt, "iam_group_policy_attachment_id", "aws_iam_group_policy_attachment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_instance_profile{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_instance_profile_id", "arn", "create_date", "name", "role", "roles", "unique_id")
		b.ImmutableAttributes("name", "name_prefix", "path")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_instance_profileHandler", bridge.NewTFHandler(p, rt, "iam_instance_profile_id", "aws_iam_instance_profile"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_openid_connect_provider{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_openid_connect_provider_id", "arn")
		b.ImmutableAttributes("client_id_list", "url")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_openid_connect_providerHandler", bridge.NewTFHandler(p, rt, "iam_openid_connect_provider_id", "aws_iam_openid_connect_provider"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_policy_id", "arn", "name")
		b.ImmutableAttributes("description", "name", "name_prefix", "path")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_policyHandler", bridge.NewTFHandler(p, rt, "iam_policy_id", "aws_iam_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_policy_attachment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_policy_attachment_id")
		b.ImmutableAttributes("name", "policy_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_policy_attachmentHandler", bridge.NewTFHandler(p, rt, "iam_policy_attachment_id", "aws_iam_policy_attachment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_role{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_role_id", "arn", "create_date", "name", "unique_id")
		b.ImmutableAttributes("name", "name_prefix", "path")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_roleHandler", bridge.NewTFHandler(p, rt, "iam_role_id", "aws_iam_role"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_role_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_role_policy_id", "name")
		b.ImmutableAttributes("name", "name_prefix", "role")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_role_policyHandler", bridge.NewTFHandler(p, rt, "iam_role_policy_id", "aws_iam_role_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_role_policy_attachment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_role_policy_attachment_id")
		b.ImmutableAttributes("policy_arn", "role")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_role_policy_attachmentHandler", bridge.NewTFHandler(p, rt, "iam_role_policy_attachment_id", "aws_iam_role_policy_attachment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_saml_provider{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_saml_provider_id", "arn", "valid_until")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_saml_providerHandler", bridge.NewTFHandler(p, rt, "iam_saml_provider_id", "aws_iam_saml_provider"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_server_certificate{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_server_certificate_id", "arn", "name")
		b.ImmutableAttributes("certificate_body", "certificate_chain", "name", "name_prefix", "path", "private_key")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_server_certificateHandler", bridge.NewTFHandler(p, rt, "iam_server_certificate_id", "aws_iam_server_certificate"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_service_linked_role{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_service_linked_role_id", "arn", "create_date", "name", "path", "unique_id")
		b.ImmutableAttributes("aws_service_name", "custom_suffix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_service_linked_roleHandler", bridge.NewTFHandler(p, rt, "iam_service_linked_role_id", "aws_iam_service_linked_role"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_user{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_user_id", "arn", "unique_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_userHandler", bridge.NewTFHandler(p, rt, "iam_user_id", "aws_iam_user"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_user_group_membership{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_user_group_membership_id")
		b.ImmutableAttributes("user")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_user_group_membershipHandler", bridge.NewTFHandler(p, rt, "iam_user_group_membership_id", "aws_iam_user_group_membership"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_user_login_profile{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_user_login_profile_id", "encrypted_password", "key_fingerprint")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_user_login_profileHandler", bridge.NewTFHandler(p, rt, "iam_user_login_profile_id", "aws_iam_user_login_profile"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_user_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_user_policy_id", "name")
		b.ImmutableAttributes("name", "name_prefix", "user")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_user_policyHandler", bridge.NewTFHandler(p, rt, "iam_user_policy_id", "aws_iam_user_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_user_policy_attachment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_user_policy_attachment_id")
		b.ImmutableAttributes("policy_arn", "user")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_user_policy_attachmentHandler", bridge.NewTFHandler(p, rt, "iam_user_policy_attachment_id", "aws_iam_user_policy_attachment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iam_user_ssh_key{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iam_user_ssh_key_id", "fingerprint", "ssh_public_key_id", "status")
		b.ImmutableAttributes("encoding", "public_key", "username")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iam_user_ssh_keyHandler", bridge.NewTFHandler(p, rt, "iam_user_ssh_key_id", "aws_iam_user_ssh_key"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Inspector_assessment_target{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("inspector_assessment_target_id", "arn")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Inspector_assessment_targetHandler", bridge.NewTFHandler(p, rt, "inspector_assessment_target_id", "aws_inspector_assessment_target"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Inspector_assessment_template{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("inspector_assessment_template_id", "arn")
		b.ImmutableAttributes("arn", "duration", "name", "rules_package_arns", "target_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Inspector_assessment_templateHandler", bridge.NewTFHandler(p, rt, "inspector_assessment_template_id", "aws_inspector_assessment_template"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Inspector_resource_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("inspector_resource_group_id", "arn")
		b.ImmutableAttributes("tags")
	}))[0]
	sb.RegisterHandler("TerraformAws::Inspector_resource_groupHandler", bridge.NewTFHandler(p, rt, "inspector_resource_group_id", "aws_inspector_resource_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Instance{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("instance_id", "arn", "associate_public_ip_address", "availability_zone", "cpu_core_count", "cpu_threads_per_core", "ebs_block_device", "ephemeral_block_device", "host_id", "instance_state", "ipv6_address_count", "ipv6_addresses", "key_name", "network_interface", "network_interface_id", "password_data", "placement_group", "primary_network_interface_id", "private_dns", "private_ip", "public_dns", "public_ip", "root_block_device", "security_groups", "subnet_id", "tenancy", "volume_tags", "vpc_security_group_ids")
		b.ImmutableAttributes("ami", "associate_public_ip_address", "availability_zone", "cpu_core_count", "cpu_threads_per_core", "ebs_optimized", "ephemeral_block_device", "host_id", "ipv6_address_count", "ipv6_addresses", "key_name", "placement_group", "private_ip", "security_groups", "subnet_id", "tenancy", "user_data", "user_data_base64")
	}))[0]
	sb.RegisterHandler("TerraformAws::InstanceHandler", bridge.NewTFHandler(p, rt, "instance_id", "aws_instance"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Internet_gateway{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("internet_gateway_id", "owner_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Internet_gatewayHandler", bridge.NewTFHandler(p, rt, "internet_gateway_id", "aws_internet_gateway"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iot_certificate{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iot_certificate_id", "arn")
		b.ImmutableAttributes("csr")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iot_certificateHandler", bridge.NewTFHandler(p, rt, "iot_certificate_id", "aws_iot_certificate"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iot_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iot_policy_id", "arn", "default_version_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iot_policyHandler", bridge.NewTFHandler(p, rt, "iot_policy_id", "aws_iot_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iot_policy_attachment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iot_policy_attachment_id")
		b.ImmutableAttributes("policy", "target")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iot_policy_attachmentHandler", bridge.NewTFHandler(p, rt, "iot_policy_attachment_id", "aws_iot_policy_attachment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iot_thing{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iot_thing_id", "arn", "default_client_id", "version")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iot_thingHandler", bridge.NewTFHandler(p, rt, "iot_thing_id", "aws_iot_thing"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iot_thing_principal_attachment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iot_thing_principal_attachment_id")
		b.ImmutableAttributes("principal", "thing")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iot_thing_principal_attachmentHandler", bridge.NewTFHandler(p, rt, "iot_thing_principal_attachment_id", "aws_iot_thing_principal_attachment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iot_thing_type{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iot_thing_type_id", "arn")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iot_thing_typeHandler", bridge.NewTFHandler(p, rt, "iot_thing_type_id", "aws_iot_thing_type"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Iot_topic_rule{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("iot_topic_rule_id", "arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Iot_topic_ruleHandler", bridge.NewTFHandler(p, rt, "iot_topic_rule_id", "aws_iot_topic_rule"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Key_pair{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("key_pair_id", "fingerprint", "key_name")
		b.ImmutableAttributes("key_name", "key_name_prefix", "public_key")
	}))[0]
	sb.RegisterHandler("TerraformAws::Key_pairHandler", bridge.NewTFHandler(p, rt, "key_pair_id", "aws_key_pair"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Kinesis_analytics_application{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("kinesis_analytics_application_id", "arn", "create_timestamp", "last_update_timestamp", "status", "version")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Kinesis_analytics_applicationHandler", bridge.NewTFHandler(p, rt, "kinesis_analytics_application_id", "aws_kinesis_analytics_application"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Kinesis_firehose_delivery_stream{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("kinesis_firehose_delivery_stream_id", "arn", "destination_id", "version_id")
		b.ImmutableAttributes("destination", "kinesis_source_configuration", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Kinesis_firehose_delivery_streamHandler", bridge.NewTFHandler(p, rt, "kinesis_firehose_delivery_stream_id", "aws_kinesis_firehose_delivery_stream"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Kinesis_stream{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("kinesis_stream_id", "arn")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Kinesis_streamHandler", bridge.NewTFHandler(p, rt, "kinesis_stream_id", "aws_kinesis_stream"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Kms_alias{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("kms_alias_id", "arn", "target_key_arn")
		b.ImmutableAttributes("name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Kms_aliasHandler", bridge.NewTFHandler(p, rt, "kms_alias_id", "aws_kms_alias"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Kms_grant{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("kms_grant_id", "grant_id", "grant_token")
		b.ImmutableAttributes("constraints", "grant_creation_tokens", "grantee_principal", "key_id", "name", "operations", "retire_on_delete", "retiring_principal")
	}))[0]
	sb.RegisterHandler("TerraformAws::Kms_grantHandler", bridge.NewTFHandler(p, rt, "kms_grant_id", "aws_kms_grant"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Kms_key{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("kms_key_id", "arn", "description", "key_id", "key_usage", "policy")
		b.ImmutableAttributes("key_usage")
	}))[0]
	sb.RegisterHandler("TerraformAws::Kms_keyHandler", bridge.NewTFHandler(p, rt, "kms_key_id", "aws_kms_key"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Lambda_alias{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("lambda_alias_id", "arn", "invoke_arn")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Lambda_aliasHandler", bridge.NewTFHandler(p, rt, "lambda_alias_id", "aws_lambda_alias"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Lambda_event_source_mapping{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("lambda_event_source_mapping_id", "function_arn", "last_modified", "last_processing_result", "state", "state_transition_reason", "uuid")
		b.ImmutableAttributes("event_source_arn", "starting_position", "starting_position_timestamp")
	}))[0]
	sb.RegisterHandler("TerraformAws::Lambda_event_source_mappingHandler", bridge.NewTFHandler(p, rt, "lambda_event_source_mapping_id", "aws_lambda_event_source_mapping"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Lambda_function{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("lambda_function_id", "arn", "invoke_arn", "last_modified", "qualified_arn", "source_code_hash", "source_code_size", "tracing_config", "version")
		b.ImmutableAttributes("function_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Lambda_functionHandler", bridge.NewTFHandler(p, rt, "lambda_function_id", "aws_lambda_function"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Lambda_layer_version{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("lambda_layer_version_id", "arn", "created_date", "layer_arn", "source_code_hash", "source_code_size", "version")
		b.ImmutableAttributes("compatible_runtimes", "description", "filename", "layer_name", "license_info", "s3_bucket", "s3_key", "s3_object_version", "source_code_hash")
	}))[0]
	sb.RegisterHandler("TerraformAws::Lambda_layer_versionHandler", bridge.NewTFHandler(p, rt, "lambda_layer_version_id", "aws_lambda_layer_version"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Lambda_permission{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("lambda_permission_id", "statement_id")
		b.ImmutableAttributes("action", "event_source_token", "function_name", "principal", "qualifier", "source_account", "source_arn", "statement_id", "statement_id_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Lambda_permissionHandler", bridge.NewTFHandler(p, rt, "lambda_permission_id", "aws_lambda_permission"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Launch_configuration{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("launch_configuration_id", "ebs_block_device", "ebs_optimized", "key_name", "name", "root_block_device")
		b.ImmutableAttributes("associate_public_ip_address", "ebs_optimized", "enable_monitoring", "ephemeral_block_device", "iam_instance_profile", "image_id", "instance_type", "key_name", "name", "name_prefix", "placement_tenancy", "security_groups", "spot_price", "user_data", "user_data_base64", "vpc_classic_link_id", "vpc_classic_link_security_groups")
	}))[0]
	sb.RegisterHandler("TerraformAws::Launch_configurationHandler", bridge.NewTFHandler(p, rt, "launch_configuration_id", "aws_launch_configuration"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Launch_template{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("launch_template_id", "arn", "default_version", "latest_version", "name")
		b.ImmutableAttributes("name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Launch_templateHandler", bridge.NewTFHandler(p, rt, "launch_template_id", "aws_launch_template"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Lb{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("lb_id", "access_logs", "arn", "arn_suffix", "dns_name", "internal", "ip_address_type", "name", "security_groups", "subnet_mapping", "subnets", "vpc_id", "zone_id")
		b.ImmutableAttributes("internal", "load_balancer_type", "name", "name_prefix", "subnet_mapping")
	}))[0]
	sb.RegisterHandler("TerraformAws::LbHandler", bridge.NewTFHandler(p, rt, "lb_id", "aws_lb"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Lb_cookie_stickiness_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("lb_cookie_stickiness_policy_id")
		b.ImmutableAttributes("cookie_expiration_period", "lb_port", "load_balancer", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Lb_cookie_stickiness_policyHandler", bridge.NewTFHandler(p, rt, "lb_cookie_stickiness_policy_id", "aws_lb_cookie_stickiness_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Lb_listener{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("lb_listener_id", "arn", "ssl_policy")
		b.ImmutableAttributes("load_balancer_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Lb_listenerHandler", bridge.NewTFHandler(p, rt, "lb_listener_id", "aws_lb_listener"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Lb_listener_certificate{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("lb_listener_certificate_id")
		b.ImmutableAttributes("certificate_arn", "listener_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Lb_listener_certificateHandler", bridge.NewTFHandler(p, rt, "lb_listener_certificate_id", "aws_lb_listener_certificate"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Lb_listener_rule{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("lb_listener_rule_id", "arn", "priority")
		b.ImmutableAttributes("listener_arn", "priority")
	}))[0]
	sb.RegisterHandler("TerraformAws::Lb_listener_ruleHandler", bridge.NewTFHandler(p, rt, "lb_listener_rule_id", "aws_lb_listener_rule"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Lb_ssl_negotiation_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("lb_ssl_negotiation_policy_id")
		b.ImmutableAttributes("attribute", "lb_port", "load_balancer", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Lb_ssl_negotiation_policyHandler", bridge.NewTFHandler(p, rt, "lb_ssl_negotiation_policy_id", "aws_lb_ssl_negotiation_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Lb_target_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("lb_target_group_id", "arn", "arn_suffix", "health_check", "name", "stickiness")
		b.ImmutableAttributes("name", "name_prefix", "port", "protocol", "target_type", "vpc_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Lb_target_groupHandler", bridge.NewTFHandler(p, rt, "lb_target_group_id", "aws_lb_target_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Lb_target_group_attachment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("lb_target_group_attachment_id")
		b.ImmutableAttributes("availability_zone", "port", "target_group_arn", "target_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Lb_target_group_attachmentHandler", bridge.NewTFHandler(p, rt, "lb_target_group_attachment_id", "aws_lb_target_group_attachment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Licensemanager_association{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("licensemanager_association_id")
		b.ImmutableAttributes("license_configuration_arn", "resource_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Licensemanager_associationHandler", bridge.NewTFHandler(p, rt, "licensemanager_association_id", "aws_licensemanager_association"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Licensemanager_license_configuration{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("licensemanager_license_configuration_id")
		b.ImmutableAttributes("license_counting_type", "license_rules")
	}))[0]
	sb.RegisterHandler("TerraformAws::Licensemanager_license_configurationHandler", bridge.NewTFHandler(p, rt, "licensemanager_license_configuration_id", "aws_licensemanager_license_configuration"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Lightsail_domain{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("lightsail_domain_id", "arn")
		b.ImmutableAttributes("domain_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Lightsail_domainHandler", bridge.NewTFHandler(p, rt, "lightsail_domain_id", "aws_lightsail_domain"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Lightsail_instance{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("lightsail_instance_id", "arn", "cpu_count", "created_at", "ipv6_address", "is_static_ip", "private_ip_address", "public_ip_address", "ram_size", "username")
		b.ImmutableAttributes("availability_zone", "blueprint_id", "bundle_id", "key_pair_name", "name", "user_data")
	}))[0]
	sb.RegisterHandler("TerraformAws::Lightsail_instanceHandler", bridge.NewTFHandler(p, rt, "lightsail_instance_id", "aws_lightsail_instance"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Lightsail_key_pair{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("lightsail_key_pair_id", "arn", "encrypted_fingerprint", "encrypted_private_key", "fingerprint", "name", "private_key", "public_key")
		b.ImmutableAttributes("name", "name_prefix", "pgp_key", "public_key")
	}))[0]
	sb.RegisterHandler("TerraformAws::Lightsail_key_pairHandler", bridge.NewTFHandler(p, rt, "lightsail_key_pair_id", "aws_lightsail_key_pair"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Lightsail_static_ip{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("lightsail_static_ip_id", "arn", "ip_address", "support_code")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Lightsail_static_ipHandler", bridge.NewTFHandler(p, rt, "lightsail_static_ip_id", "aws_lightsail_static_ip"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Lightsail_static_ip_attachment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("lightsail_static_ip_attachment_id")
		b.ImmutableAttributes("instance_name", "static_ip_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Lightsail_static_ip_attachmentHandler", bridge.NewTFHandler(p, rt, "lightsail_static_ip_attachment_id", "aws_lightsail_static_ip_attachment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Load_balancer_backend_server_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("load_balancer_backend_server_policy_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Load_balancer_backend_server_policyHandler", bridge.NewTFHandler(p, rt, "load_balancer_backend_server_policy_id", "aws_load_balancer_backend_server_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Load_balancer_listener_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("load_balancer_listener_policy_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Load_balancer_listener_policyHandler", bridge.NewTFHandler(p, rt, "load_balancer_listener_policy_id", "aws_load_balancer_listener_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Load_balancer_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("load_balancer_policy_id")
		b.ImmutableAttributes("load_balancer_name", "policy_name", "policy_type_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Load_balancer_policyHandler", bridge.NewTFHandler(p, rt, "load_balancer_policy_id", "aws_load_balancer_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Macie_member_account_association{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("macie_member_account_association_id")
		b.ImmutableAttributes("member_account_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Macie_member_account_associationHandler", bridge.NewTFHandler(p, rt, "macie_member_account_association_id", "aws_macie_member_account_association"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Macie_s3_bucket_association{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("macie_s3_bucket_association_id", "classification_type")
		b.ImmutableAttributes("bucket_name", "member_account_id", "prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Macie_s3_bucket_associationHandler", bridge.NewTFHandler(p, rt, "macie_s3_bucket_association_id", "aws_macie_s3_bucket_association"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Main_route_table_association{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("main_route_table_association_id", "original_route_table_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Main_route_table_associationHandler", bridge.NewTFHandler(p, rt, "main_route_table_association_id", "aws_main_route_table_association"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Media_package_channel{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("media_package_channel_id", "arn", "hls_ingest")
		b.ImmutableAttributes("channel_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Media_package_channelHandler", bridge.NewTFHandler(p, rt, "media_package_channel_id", "aws_media_package_channel"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Media_store_container{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("media_store_container_id", "arn", "endpoint")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Media_store_containerHandler", bridge.NewTFHandler(p, rt, "media_store_container_id", "aws_media_store_container"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Media_store_container_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("media_store_container_policy_id")
		b.ImmutableAttributes("container_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Media_store_container_policyHandler", bridge.NewTFHandler(p, rt, "media_store_container_policy_id", "aws_media_store_container_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Mq_broker{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("mq_broker_id", "arn", "configuration", "instances", "maintenance_window_start_time", "subnet_ids")
		b.ImmutableAttributes("auto_minor_version_upgrade", "broker_name", "deployment_mode", "engine_type", "engine_version", "host_instance_type", "maintenance_window_start_time", "publicly_accessible", "security_groups", "subnet_ids")
	}))[0]
	sb.RegisterHandler("TerraformAws::Mq_brokerHandler", bridge.NewTFHandler(p, rt, "mq_broker_id", "aws_mq_broker"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Mq_configuration{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("mq_configuration_id", "arn", "latest_revision")
		b.ImmutableAttributes("engine_type", "engine_version", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Mq_configurationHandler", bridge.NewTFHandler(p, rt, "mq_configuration_id", "aws_mq_configuration"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Nat_gateway{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("nat_gateway_id", "network_interface_id", "private_ip", "public_ip")
		b.ImmutableAttributes("allocation_id", "subnet_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Nat_gatewayHandler", bridge.NewTFHandler(p, rt, "nat_gateway_id", "aws_nat_gateway"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Neptune_cluster{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("neptune_cluster_id", "apply_immediately", "arn", "availability_zones", "cluster_identifier", "cluster_identifier_prefix", "cluster_members", "cluster_resource_id", "endpoint", "engine_version", "hosted_zone_id", "kms_key_arn", "neptune_subnet_group_name", "preferred_backup_window", "preferred_maintenance_window", "reader_endpoint", "vpc_security_group_ids")
		b.ImmutableAttributes("availability_zones", "cluster_identifier", "cluster_identifier_prefix", "engine", "engine_version", "kms_key_arn", "neptune_subnet_group_name", "port", "storage_encrypted")
	}))[0]
	sb.RegisterHandler("TerraformAws::Neptune_clusterHandler", bridge.NewTFHandler(p, rt, "neptune_cluster_id", "aws_neptune_cluster"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Neptune_cluster_instance{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("neptune_cluster_instance_id", "address", "apply_immediately", "arn", "availability_zone", "dbi_resource_id", "endpoint", "engine_version", "identifier", "identifier_prefix", "kms_key_arn", "neptune_subnet_group_name", "preferred_backup_window", "preferred_maintenance_window", "storage_encrypted", "writer")
		b.ImmutableAttributes("availability_zone", "cluster_identifier", "engine", "engine_version", "identifier", "identifier_prefix", "neptune_subnet_group_name", "port", "publicly_accessible")
	}))[0]
	sb.RegisterHandler("TerraformAws::Neptune_cluster_instanceHandler", bridge.NewTFHandler(p, rt, "neptune_cluster_instance_id", "aws_neptune_cluster_instance"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Neptune_cluster_parameter_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("neptune_cluster_parameter_group_id", "arn", "name", "name_prefix")
		b.ImmutableAttributes("description", "family", "name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Neptune_cluster_parameter_groupHandler", bridge.NewTFHandler(p, rt, "neptune_cluster_parameter_group_id", "aws_neptune_cluster_parameter_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Neptune_cluster_snapshot{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("neptune_cluster_snapshot_id", "allocated_storage", "availability_zones", "db_cluster_snapshot_arn", "engine", "engine_version", "kms_key_id", "license_model", "port", "snapshot_type", "source_db_cluster_snapshot_arn", "status", "storage_encrypted", "vpc_id")
		b.ImmutableAttributes("db_cluster_identifier", "db_cluster_snapshot_identifier")
	}))[0]
	sb.RegisterHandler("TerraformAws::Neptune_cluster_snapshotHandler", bridge.NewTFHandler(p, rt, "neptune_cluster_snapshot_id", "aws_neptune_cluster_snapshot"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Neptune_event_subscription{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("neptune_event_subscription_id", "arn", "customer_aws_id", "name", "name_prefix")
		b.ImmutableAttributes("name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Neptune_event_subscriptionHandler", bridge.NewTFHandler(p, rt, "neptune_event_subscription_id", "aws_neptune_event_subscription"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Neptune_parameter_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("neptune_parameter_group_id", "arn")
		b.ImmutableAttributes("description", "family", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Neptune_parameter_groupHandler", bridge.NewTFHandler(p, rt, "neptune_parameter_group_id", "aws_neptune_parameter_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Neptune_subnet_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("neptune_subnet_group_id", "arn", "name", "name_prefix")
		b.ImmutableAttributes("name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Neptune_subnet_groupHandler", bridge.NewTFHandler(p, rt, "neptune_subnet_group_id", "aws_neptune_subnet_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Network_acl{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("network_acl_id", "egress", "ingress", "owner_id", "subnet_ids")
		b.ImmutableAttributes("subnet_id", "vpc_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Network_aclHandler", bridge.NewTFHandler(p, rt, "network_acl_id", "aws_network_acl"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Network_acl_rule{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("network_acl_rule_id")
		b.ImmutableAttributes("cidr_block", "egress", "from_port", "icmp_code", "icmp_type", "ipv6_cidr_block", "network_acl_id", "protocol", "rule_action", "rule_number", "to_port")
	}))[0]
	sb.RegisterHandler("TerraformAws::Network_acl_ruleHandler", bridge.NewTFHandler(p, rt, "network_acl_rule_id", "aws_network_acl_rule"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Network_interface{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("network_interface_id", "attachment", "private_dns_name", "private_ip", "private_ips", "private_ips_count", "security_groups")
		b.ImmutableAttributes("subnet_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Network_interfaceHandler", bridge.NewTFHandler(p, rt, "network_interface_id", "aws_network_interface"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Network_interface_attachment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("network_interface_attachment_id", "attachment_id", "status")
		b.ImmutableAttributes("device_index", "instance_id", "network_interface_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Network_interface_attachmentHandler", bridge.NewTFHandler(p, rt, "network_interface_attachment_id", "aws_network_interface_attachment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Network_interface_sg_attachment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("network_interface_sg_attachment_id")
		b.ImmutableAttributes("network_interface_id", "security_group_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Network_interface_sg_attachmentHandler", bridge.NewTFHandler(p, rt, "network_interface_sg_attachment_id", "aws_network_interface_sg_attachment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Opsworks_application{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("opsworks_application_id", "app_source", "short_name")
		b.ImmutableAttributes("short_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Opsworks_applicationHandler", bridge.NewTFHandler(p, rt, "opsworks_application_id", "aws_opsworks_application"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Opsworks_custom_layer{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("opsworks_custom_layer_id")
		b.ImmutableAttributes("stack_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Opsworks_custom_layerHandler", bridge.NewTFHandler(p, rt, "opsworks_custom_layer_id", "aws_opsworks_custom_layer"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Opsworks_ganglia_layer{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("opsworks_ganglia_layer_id")
		b.ImmutableAttributes("stack_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Opsworks_ganglia_layerHandler", bridge.NewTFHandler(p, rt, "opsworks_ganglia_layer_id", "aws_opsworks_ganglia_layer"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Opsworks_haproxy_layer{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("opsworks_haproxy_layer_id")
		b.ImmutableAttributes("stack_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Opsworks_haproxy_layerHandler", bridge.NewTFHandler(p, rt, "opsworks_haproxy_layer_id", "aws_opsworks_haproxy_layer"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Opsworks_instance{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("opsworks_instance_id", "ami_id", "availability_zone", "created_at", "ebs_block_device", "ec2_instance_id", "ecs_cluster_arn", "elastic_ip", "ephemeral_block_device", "hostname", "infrastructure_class", "instance_profile_arn", "last_service_error_id", "os", "platform", "private_dns", "private_ip", "public_dns", "public_ip", "registered_by", "reported_agent_version", "reported_os_family", "reported_os_name", "reported_os_version", "root_block_device", "root_device_type", "root_device_volume_id", "security_group_ids", "ssh_host_dsa_key_fingerprint", "ssh_host_rsa_key_fingerprint", "ssh_key_name", "status", "subnet_id", "tenancy", "virtualization_type")
		b.ImmutableAttributes("ami_id", "availability_zone", "ebs_block_device", "ebs_optimized", "ephemeral_block_device", "hostname", "os", "root_block_device", "root_device_type", "stack_id", "subnet_id", "tenancy", "virtualization_type")
	}))[0]
	sb.RegisterHandler("TerraformAws::Opsworks_instanceHandler", bridge.NewTFHandler(p, rt, "opsworks_instance_id", "aws_opsworks_instance"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Opsworks_java_app_layer{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("opsworks_java_app_layer_id")
		b.ImmutableAttributes("stack_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Opsworks_java_app_layerHandler", bridge.NewTFHandler(p, rt, "opsworks_java_app_layer_id", "aws_opsworks_java_app_layer"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Opsworks_memcached_layer{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("opsworks_memcached_layer_id")
		b.ImmutableAttributes("stack_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Opsworks_memcached_layerHandler", bridge.NewTFHandler(p, rt, "opsworks_memcached_layer_id", "aws_opsworks_memcached_layer"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Opsworks_mysql_layer{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("opsworks_mysql_layer_id")
		b.ImmutableAttributes("stack_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Opsworks_mysql_layerHandler", bridge.NewTFHandler(p, rt, "opsworks_mysql_layer_id", "aws_opsworks_mysql_layer"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Opsworks_nodejs_app_layer{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("opsworks_nodejs_app_layer_id")
		b.ImmutableAttributes("stack_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Opsworks_nodejs_app_layerHandler", bridge.NewTFHandler(p, rt, "opsworks_nodejs_app_layer_id", "aws_opsworks_nodejs_app_layer"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Opsworks_permission{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("opsworks_permission_id", "allow_ssh", "allow_sudo", "level", "stack_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Opsworks_permissionHandler", bridge.NewTFHandler(p, rt, "opsworks_permission_id", "aws_opsworks_permission"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Opsworks_php_app_layer{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("opsworks_php_app_layer_id")
		b.ImmutableAttributes("stack_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Opsworks_php_app_layerHandler", bridge.NewTFHandler(p, rt, "opsworks_php_app_layer_id", "aws_opsworks_php_app_layer"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Opsworks_rails_app_layer{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("opsworks_rails_app_layer_id")
		b.ImmutableAttributes("stack_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Opsworks_rails_app_layerHandler", bridge.NewTFHandler(p, rt, "opsworks_rails_app_layer_id", "aws_opsworks_rails_app_layer"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Opsworks_rds_db_instance{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("opsworks_rds_db_instance_id")
		b.ImmutableAttributes("rds_db_instance_arn", "stack_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Opsworks_rds_db_instanceHandler", bridge.NewTFHandler(p, rt, "opsworks_rds_db_instance_id", "aws_opsworks_rds_db_instance"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Opsworks_stack{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("opsworks_stack_id", "agent_version", "arn", "custom_cookbooks_source", "default_availability_zone", "default_subnet_id", "stack_endpoint", "vpc_id")
		b.ImmutableAttributes("region", "service_role_arn", "vpc_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Opsworks_stackHandler", bridge.NewTFHandler(p, rt, "opsworks_stack_id", "aws_opsworks_stack"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Opsworks_static_web_layer{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("opsworks_static_web_layer_id")
		b.ImmutableAttributes("stack_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Opsworks_static_web_layerHandler", bridge.NewTFHandler(p, rt, "opsworks_static_web_layer_id", "aws_opsworks_static_web_layer"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Opsworks_user_profile{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("opsworks_user_profile_id")
		b.ImmutableAttributes("user_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Opsworks_user_profileHandler", bridge.NewTFHandler(p, rt, "opsworks_user_profile_id", "aws_opsworks_user_profile"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Organizations_account{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("organizations_account_id", "arn", "joined_method", "joined_timestamp", "status")
		b.ImmutableAttributes("email", "iam_user_access_to_billing", "name", "role_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Organizations_accountHandler", bridge.NewTFHandler(p, rt, "organizations_account_id", "aws_organizations_account"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Organizations_organization{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("organizations_organization_id", "arn", "master_account_arn", "master_account_email", "master_account_id")
		b.ImmutableAttributes("feature_set")
	}))[0]
	sb.RegisterHandler("TerraformAws::Organizations_organizationHandler", bridge.NewTFHandler(p, rt, "organizations_organization_id", "aws_organizations_organization"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Organizations_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("organizations_policy_id", "arn")
		b.ImmutableAttributes("type")
	}))[0]
	sb.RegisterHandler("TerraformAws::Organizations_policyHandler", bridge.NewTFHandler(p, rt, "organizations_policy_id", "aws_organizations_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Organizations_policy_attachment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("organizations_policy_attachment_id")
		b.ImmutableAttributes("policy_id", "target_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Organizations_policy_attachmentHandler", bridge.NewTFHandler(p, rt, "organizations_policy_attachment_id", "aws_organizations_policy_attachment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Pinpoint_adm_channel{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("pinpoint_adm_channel_id")
		b.ImmutableAttributes("application_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Pinpoint_adm_channelHandler", bridge.NewTFHandler(p, rt, "pinpoint_adm_channel_id", "aws_pinpoint_adm_channel"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Pinpoint_apns_channel{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("pinpoint_apns_channel_id")
		b.ImmutableAttributes("application_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Pinpoint_apns_channelHandler", bridge.NewTFHandler(p, rt, "pinpoint_apns_channel_id", "aws_pinpoint_apns_channel"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Pinpoint_apns_sandbox_channel{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("pinpoint_apns_sandbox_channel_id")
		b.ImmutableAttributes("application_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Pinpoint_apns_sandbox_channelHandler", bridge.NewTFHandler(p, rt, "pinpoint_apns_sandbox_channel_id", "aws_pinpoint_apns_sandbox_channel"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Pinpoint_apns_voip_channel{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("pinpoint_apns_voip_channel_id")
		b.ImmutableAttributes("application_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Pinpoint_apns_voip_channelHandler", bridge.NewTFHandler(p, rt, "pinpoint_apns_voip_channel_id", "aws_pinpoint_apns_voip_channel"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Pinpoint_apns_voip_sandbox_channel{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("pinpoint_apns_voip_sandbox_channel_id")
		b.ImmutableAttributes("application_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Pinpoint_apns_voip_sandbox_channelHandler", bridge.NewTFHandler(p, rt, "pinpoint_apns_voip_sandbox_channel_id", "aws_pinpoint_apns_voip_sandbox_channel"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Pinpoint_app{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("pinpoint_app_id", "application_id", "name")
		b.ImmutableAttributes("name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Pinpoint_appHandler", bridge.NewTFHandler(p, rt, "pinpoint_app_id", "aws_pinpoint_app"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Pinpoint_baidu_channel{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("pinpoint_baidu_channel_id")
		b.ImmutableAttributes("application_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Pinpoint_baidu_channelHandler", bridge.NewTFHandler(p, rt, "pinpoint_baidu_channel_id", "aws_pinpoint_baidu_channel"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Pinpoint_email_channel{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("pinpoint_email_channel_id", "messages_per_second")
		b.ImmutableAttributes("application_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Pinpoint_email_channelHandler", bridge.NewTFHandler(p, rt, "pinpoint_email_channel_id", "aws_pinpoint_email_channel"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Pinpoint_event_stream{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("pinpoint_event_stream_id")
		b.ImmutableAttributes("application_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Pinpoint_event_streamHandler", bridge.NewTFHandler(p, rt, "pinpoint_event_stream_id", "aws_pinpoint_event_stream"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Pinpoint_gcm_channel{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("pinpoint_gcm_channel_id")
		b.ImmutableAttributes("application_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Pinpoint_gcm_channelHandler", bridge.NewTFHandler(p, rt, "pinpoint_gcm_channel_id", "aws_pinpoint_gcm_channel"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Pinpoint_sms_channel{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("pinpoint_sms_channel_id", "promotional_messages_per_second", "transactional_messages_per_second")
		b.ImmutableAttributes("application_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Pinpoint_sms_channelHandler", bridge.NewTFHandler(p, rt, "pinpoint_sms_channel_id", "aws_pinpoint_sms_channel"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Placement_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("placement_group_id")
		b.ImmutableAttributes("name", "strategy")
	}))[0]
	sb.RegisterHandler("TerraformAws::Placement_groupHandler", bridge.NewTFHandler(p, rt, "placement_group_id", "aws_placement_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Proxy_protocol_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("proxy_protocol_policy_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Proxy_protocol_policyHandler", bridge.NewTFHandler(p, rt, "proxy_protocol_policy_id", "aws_proxy_protocol_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ram_resource_share{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ram_resource_share_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ram_resource_shareHandler", bridge.NewTFHandler(p, rt, "ram_resource_share_id", "aws_ram_resource_share"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Rds_cluster{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("rds_cluster_id", "apply_immediately", "arn", "availability_zones", "cluster_identifier", "cluster_identifier_prefix", "cluster_members", "cluster_resource_id", "database_name", "db_cluster_parameter_group_name", "db_subnet_group_name", "endpoint", "engine_version", "hosted_zone_id", "kms_key_id", "master_username", "port", "preferred_backup_window", "preferred_maintenance_window", "reader_endpoint", "vpc_security_group_ids")
		b.ImmutableAttributes("availability_zones", "cluster_identifier", "cluster_identifier_prefix", "database_name", "db_subnet_group_name", "engine", "engine_mode", "kms_key_id", "master_username", "port", "source_region", "storage_encrypted")
	}))[0]
	sb.RegisterHandler("TerraformAws::Rds_clusterHandler", bridge.NewTFHandler(p, rt, "rds_cluster_id", "aws_rds_cluster"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Rds_cluster_endpoint{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("rds_cluster_endpoint_id", "arn", "endpoint")
		b.ImmutableAttributes("cluster_endpoint_identifier", "cluster_identifier")
	}))[0]
	sb.RegisterHandler("TerraformAws::Rds_cluster_endpointHandler", bridge.NewTFHandler(p, rt, "rds_cluster_endpoint_id", "aws_rds_cluster_endpoint"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Rds_cluster_instance{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("rds_cluster_instance_id", "apply_immediately", "arn", "availability_zone", "db_parameter_group_name", "db_subnet_group_name", "dbi_resource_id", "endpoint", "engine_version", "identifier", "identifier_prefix", "kms_key_id", "monitoring_role_arn", "performance_insights_enabled", "performance_insights_kms_key_id", "port", "preferred_backup_window", "preferred_maintenance_window", "storage_encrypted", "writer")
		b.ImmutableAttributes("availability_zone", "cluster_identifier", "db_subnet_group_name", "engine", "engine_version", "identifier", "identifier_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Rds_cluster_instanceHandler", bridge.NewTFHandler(p, rt, "rds_cluster_instance_id", "aws_rds_cluster_instance"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Rds_cluster_parameter_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("rds_cluster_parameter_group_id", "arn", "name", "name_prefix")
		b.ImmutableAttributes("description", "family", "name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Rds_cluster_parameter_groupHandler", bridge.NewTFHandler(p, rt, "rds_cluster_parameter_group_id", "aws_rds_cluster_parameter_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Rds_global_cluster{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("rds_global_cluster_id", "arn", "engine_version", "global_cluster_resource_id")
		b.ImmutableAttributes("database_name", "engine", "engine_version", "global_cluster_identifier", "storage_encrypted")
	}))[0]
	sb.RegisterHandler("TerraformAws::Rds_global_clusterHandler", bridge.NewTFHandler(p, rt, "rds_global_cluster_id", "aws_rds_global_cluster"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Redshift_cluster{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("redshift_cluster_id", "availability_zone", "bucket_name", "cluster_parameter_group_name", "cluster_public_key", "cluster_revision_number", "cluster_security_groups", "cluster_subnet_group_name", "cluster_type", "database_name", "dns_name", "enable_logging", "endpoint", "enhanced_vpc_routing", "iam_roles", "kms_key_id", "preferred_maintenance_window", "s3_key_prefix", "vpc_security_group_ids")
		b.ImmutableAttributes("availability_zone", "cluster_identifier", "cluster_subnet_group_name", "master_username", "snapshot_cluster_identifier", "snapshot_identifier")
	}))[0]
	sb.RegisterHandler("TerraformAws::Redshift_clusterHandler", bridge.NewTFHandler(p, rt, "redshift_cluster_id", "aws_redshift_cluster"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Redshift_event_subscription{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("redshift_event_subscription_id", "customer_aws_id", "status")
		b.ImmutableAttributes("name", "tags")
	}))[0]
	sb.RegisterHandler("TerraformAws::Redshift_event_subscriptionHandler", bridge.NewTFHandler(p, rt, "redshift_event_subscription_id", "aws_redshift_event_subscription"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Redshift_parameter_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("redshift_parameter_group_id")
		b.ImmutableAttributes("description", "family", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Redshift_parameter_groupHandler", bridge.NewTFHandler(p, rt, "redshift_parameter_group_id", "aws_redshift_parameter_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Redshift_security_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("redshift_security_group_id")
		b.ImmutableAttributes("description", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Redshift_security_groupHandler", bridge.NewTFHandler(p, rt, "redshift_security_group_id", "aws_redshift_security_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Redshift_snapshot_copy_grant{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("redshift_snapshot_copy_grant_id", "kms_key_id")
		b.ImmutableAttributes("kms_key_id", "snapshot_copy_grant_name", "tags")
	}))[0]
	sb.RegisterHandler("TerraformAws::Redshift_snapshot_copy_grantHandler", bridge.NewTFHandler(p, rt, "redshift_snapshot_copy_grant_id", "aws_redshift_snapshot_copy_grant"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Redshift_subnet_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("redshift_subnet_group_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Redshift_subnet_groupHandler", bridge.NewTFHandler(p, rt, "redshift_subnet_group_id", "aws_redshift_subnet_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Resourcegroups_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("resourcegroups_group_id", "arn")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Resourcegroups_groupHandler", bridge.NewTFHandler(p, rt, "resourcegroups_group_id", "aws_resourcegroups_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Route{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("route_id", "destination_prefix_list_id", "egress_only_gateway_id", "gateway_id", "instance_id", "instance_owner_id", "nat_gateway_id", "network_interface_id", "origin", "state")
		b.ImmutableAttributes("destination_cidr_block", "destination_ipv6_cidr_block", "route_table_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::RouteHandler", bridge.NewTFHandler(p, rt, "route_id", "aws_route"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Route53_delegation_set{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("route53_delegation_set_id", "name_servers")
		b.ImmutableAttributes("reference_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Route53_delegation_setHandler", bridge.NewTFHandler(p, rt, "route53_delegation_set_id", "aws_route53_delegation_set"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Route53_health_check{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("route53_health_check_id", "enable_sni")
		b.ImmutableAttributes("ip_address", "measure_latency", "reference_name", "request_interval", "type")
	}))[0]
	sb.RegisterHandler("TerraformAws::Route53_health_checkHandler", bridge.NewTFHandler(p, rt, "route53_health_check_id", "aws_route53_health_check"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Route53_query_log{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("route53_query_log_id")
		b.ImmutableAttributes("cloudwatch_log_group_arn", "zone_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Route53_query_logHandler", bridge.NewTFHandler(p, rt, "route53_query_log_id", "aws_route53_query_log"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Route53_record{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("route53_record_id", "fqdn")
		b.ImmutableAttributes("name", "zone_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Route53_recordHandler", bridge.NewTFHandler(p, rt, "route53_record_id", "aws_route53_record"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Route53_zone{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("route53_zone_id", "name_servers", "vpc", "vpc_id", "vpc_region", "zone_id")
		b.ImmutableAttributes("delegation_set_id", "name", "vpc_id", "vpc_region")
	}))[0]
	sb.RegisterHandler("TerraformAws::Route53_zoneHandler", bridge.NewTFHandler(p, rt, "route53_zone_id", "aws_route53_zone"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Route53_zone_association{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("route53_zone_association_id", "vpc_region")
	}))[0]
	sb.RegisterHandler("TerraformAws::Route53_zone_associationHandler", bridge.NewTFHandler(p, rt, "route53_zone_association_id", "aws_route53_zone_association"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Route_table{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("route_table_id", "owner_id", "propagating_vgws", "route")
		b.ImmutableAttributes("vpc_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Route_tableHandler", bridge.NewTFHandler(p, rt, "route_table_id", "aws_route_table"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Route_table_association{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("route_table_association_id")
		b.ImmutableAttributes("subnet_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Route_table_associationHandler", bridge.NewTFHandler(p, rt, "route_table_association_id", "aws_route_table_association"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&S3_account_public_access_block{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("s3_account_public_access_block_id", "account_id")
		b.ImmutableAttributes("account_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::S3_account_public_access_blockHandler", bridge.NewTFHandler(p, rt, "s3_account_public_access_block_id", "aws_s3_account_public_access_block"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&S3_bucket{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("s3_bucket_id", "acceleration_status", "arn", "bucket", "bucket_domain_name", "bucket_regional_domain_name", "hosted_zone_id", "region", "request_payer", "versioning", "website_domain", "website_endpoint")
		b.ImmutableAttributes("bucket", "bucket_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::S3_bucketHandler", bridge.NewTFHandler(p, rt, "s3_bucket_id", "aws_s3_bucket"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&S3_bucket_inventory{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("s3_bucket_inventory_id")
		b.ImmutableAttributes("bucket", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::S3_bucket_inventoryHandler", bridge.NewTFHandler(p, rt, "s3_bucket_inventory_id", "aws_s3_bucket_inventory"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&S3_bucket_metric{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("s3_bucket_metric_id")
		b.ImmutableAttributes("bucket", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::S3_bucket_metricHandler", bridge.NewTFHandler(p, rt, "s3_bucket_metric_id", "aws_s3_bucket_metric"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&S3_bucket_notification{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("s3_bucket_notification_id")
		b.ImmutableAttributes("bucket")
	}))[0]
	sb.RegisterHandler("TerraformAws::S3_bucket_notificationHandler", bridge.NewTFHandler(p, rt, "s3_bucket_notification_id", "aws_s3_bucket_notification"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&S3_bucket_object{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("s3_bucket_object_id", "content_type", "etag", "server_side_encryption", "storage_class", "version_id")
		b.ImmutableAttributes("bucket", "key")
	}))[0]
	sb.RegisterHandler("TerraformAws::S3_bucket_objectHandler", bridge.NewTFHandler(p, rt, "s3_bucket_object_id", "aws_s3_bucket_object"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&S3_bucket_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("s3_bucket_policy_id")
		b.ImmutableAttributes("bucket")
	}))[0]
	sb.RegisterHandler("TerraformAws::S3_bucket_policyHandler", bridge.NewTFHandler(p, rt, "s3_bucket_policy_id", "aws_s3_bucket_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&S3_bucket_public_access_block{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("s3_bucket_public_access_block_id")
		b.ImmutableAttributes("bucket")
	}))[0]
	sb.RegisterHandler("TerraformAws::S3_bucket_public_access_blockHandler", bridge.NewTFHandler(p, rt, "s3_bucket_public_access_block_id", "aws_s3_bucket_public_access_block"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Sagemaker_notebook_instance{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("sagemaker_notebook_instance_id", "arn", "security_groups")
		b.ImmutableAttributes("kms_key_id", "name", "security_groups", "subnet_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Sagemaker_notebook_instanceHandler", bridge.NewTFHandler(p, rt, "sagemaker_notebook_instance_id", "aws_sagemaker_notebook_instance"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Secretsmanager_secret{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("secretsmanager_secret_id", "arn", "name", "name_prefix", "rotation_enabled")
		b.ImmutableAttributes("name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Secretsmanager_secretHandler", bridge.NewTFHandler(p, rt, "secretsmanager_secret_id", "aws_secretsmanager_secret"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Secretsmanager_secret_version{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("secretsmanager_secret_version_id", "arn", "version_id", "version_stages")
		b.ImmutableAttributes("secret_binary", "secret_id", "secret_string")
	}))[0]
	sb.RegisterHandler("TerraformAws::Secretsmanager_secret_versionHandler", bridge.NewTFHandler(p, rt, "secretsmanager_secret_version_id", "aws_secretsmanager_secret_version"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Security_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("security_group_id", "arn", "egress", "ingress", "name", "owner_id", "vpc_id")
		b.ImmutableAttributes("description", "name", "name_prefix", "vpc_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Security_groupHandler", bridge.NewTFHandler(p, rt, "security_group_id", "aws_security_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Security_group_rule{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("security_group_rule_id", "source_security_group_id")
		b.ImmutableAttributes("cidr_blocks", "from_port", "ipv6_cidr_blocks", "prefix_list_ids", "protocol", "security_group_id", "self", "source_security_group_id", "to_port", "type")
	}))[0]
	sb.RegisterHandler("TerraformAws::Security_group_ruleHandler", bridge.NewTFHandler(p, rt, "security_group_rule_id", "aws_security_group_rule"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Securityhub_account{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("securityhub_account_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Securityhub_accountHandler", bridge.NewTFHandler(p, rt, "securityhub_account_id", "aws_securityhub_account"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Securityhub_product_subscription{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("securityhub_product_subscription_id", "arn")
		b.ImmutableAttributes("product_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Securityhub_product_subscriptionHandler", bridge.NewTFHandler(p, rt, "securityhub_product_subscription_id", "aws_securityhub_product_subscription"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Securityhub_standards_subscription{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("securityhub_standards_subscription_id")
		b.ImmutableAttributes("standards_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Securityhub_standards_subscriptionHandler", bridge.NewTFHandler(p, rt, "securityhub_standards_subscription_id", "aws_securityhub_standards_subscription"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Service_discovery_http_namespace{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("service_discovery_http_namespace_id", "arn")
		b.ImmutableAttributes("description", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Service_discovery_http_namespaceHandler", bridge.NewTFHandler(p, rt, "service_discovery_http_namespace_id", "aws_service_discovery_http_namespace"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Service_discovery_private_dns_namespace{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("service_discovery_private_dns_namespace_id", "arn", "hosted_zone")
		b.ImmutableAttributes("description", "name", "vpc")
	}))[0]
	sb.RegisterHandler("TerraformAws::Service_discovery_private_dns_namespaceHandler", bridge.NewTFHandler(p, rt, "service_discovery_private_dns_namespace_id", "aws_service_discovery_private_dns_namespace"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Service_discovery_public_dns_namespace{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("service_discovery_public_dns_namespace_id", "arn", "hosted_zone")
		b.ImmutableAttributes("description", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Service_discovery_public_dns_namespaceHandler", bridge.NewTFHandler(p, rt, "service_discovery_public_dns_namespace_id", "aws_service_discovery_public_dns_namespace"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Service_discovery_service{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("service_discovery_service_id", "arn")
		b.ImmutableAttributes("health_check_custom_config", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Service_discovery_serviceHandler", bridge.NewTFHandler(p, rt, "service_discovery_service_id", "aws_service_discovery_service"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Servicecatalog_portfolio{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("servicecatalog_portfolio_id", "arn", "created_time", "description")
	}))[0]
	sb.RegisterHandler("TerraformAws::Servicecatalog_portfolioHandler", bridge.NewTFHandler(p, rt, "servicecatalog_portfolio_id", "aws_servicecatalog_portfolio"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ses_active_receipt_rule_set{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ses_active_receipt_rule_set_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ses_active_receipt_rule_setHandler", bridge.NewTFHandler(p, rt, "ses_active_receipt_rule_set_id", "aws_ses_active_receipt_rule_set"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ses_configuration_set{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ses_configuration_set_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ses_configuration_setHandler", bridge.NewTFHandler(p, rt, "ses_configuration_set_id", "aws_ses_configuration_set"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ses_domain_dkim{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ses_domain_dkim_id", "dkim_tokens")
		b.ImmutableAttributes("domain")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ses_domain_dkimHandler", bridge.NewTFHandler(p, rt, "ses_domain_dkim_id", "aws_ses_domain_dkim"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ses_domain_identity{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ses_domain_identity_id", "arn", "verification_token")
		b.ImmutableAttributes("domain")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ses_domain_identityHandler", bridge.NewTFHandler(p, rt, "ses_domain_identity_id", "aws_ses_domain_identity"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ses_domain_identity_verification{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ses_domain_identity_verification_id", "arn")
		b.ImmutableAttributes("domain")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ses_domain_identity_verificationHandler", bridge.NewTFHandler(p, rt, "ses_domain_identity_verification_id", "aws_ses_domain_identity_verification"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ses_domain_mail_from{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ses_domain_mail_from_id")
		b.ImmutableAttributes("domain")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ses_domain_mail_fromHandler", bridge.NewTFHandler(p, rt, "ses_domain_mail_from_id", "aws_ses_domain_mail_from"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ses_event_destination{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ses_event_destination_id")
		b.ImmutableAttributes("cloudwatch_destination", "configuration_set_name", "enabled", "kinesis_destination", "matching_types", "name", "sns_destination")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ses_event_destinationHandler", bridge.NewTFHandler(p, rt, "ses_event_destination_id", "aws_ses_event_destination"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ses_identity_notification_topic{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ses_identity_notification_topic_id")
		b.ImmutableAttributes("identity", "notification_type")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ses_identity_notification_topicHandler", bridge.NewTFHandler(p, rt, "ses_identity_notification_topic_id", "aws_ses_identity_notification_topic"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ses_receipt_filter{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ses_receipt_filter_id")
		b.ImmutableAttributes("cidr", "name", "policy")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ses_receipt_filterHandler", bridge.NewTFHandler(p, rt, "ses_receipt_filter_id", "aws_ses_receipt_filter"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ses_receipt_rule{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ses_receipt_rule_id", "enabled", "scan_enabled", "tls_policy")
		b.ImmutableAttributes("name", "rule_set_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ses_receipt_ruleHandler", bridge.NewTFHandler(p, rt, "ses_receipt_rule_id", "aws_ses_receipt_rule"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ses_receipt_rule_set{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ses_receipt_rule_set_id")
		b.ImmutableAttributes("rule_set_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ses_receipt_rule_setHandler", bridge.NewTFHandler(p, rt, "ses_receipt_rule_set_id", "aws_ses_receipt_rule_set"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ses_template{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ses_template_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ses_templateHandler", bridge.NewTFHandler(p, rt, "ses_template_id", "aws_ses_template"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Sfn_activity{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("sfn_activity_id", "creation_date")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Sfn_activityHandler", bridge.NewTFHandler(p, rt, "sfn_activity_id", "aws_sfn_activity"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Sfn_state_machine{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("sfn_state_machine_id", "creation_date", "status")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Sfn_state_machineHandler", bridge.NewTFHandler(p, rt, "sfn_state_machine_id", "aws_sfn_state_machine"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Simpledb_domain{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("simpledb_domain_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Simpledb_domainHandler", bridge.NewTFHandler(p, rt, "simpledb_domain_id", "aws_simpledb_domain"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Snapshot_create_volume_permission{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("snapshot_create_volume_permission_id")
		b.ImmutableAttributes("account_id", "snapshot_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Snapshot_create_volume_permissionHandler", bridge.NewTFHandler(p, rt, "snapshot_create_volume_permission_id", "aws_snapshot_create_volume_permission"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Sns_platform_application{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("sns_platform_application_id", "arn")
		b.ImmutableAttributes("name", "platform")
	}))[0]
	sb.RegisterHandler("TerraformAws::Sns_platform_applicationHandler", bridge.NewTFHandler(p, rt, "sns_platform_application_id", "aws_sns_platform_application"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Sns_sms_preferences{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("sns_sms_preferences_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Sns_sms_preferencesHandler", bridge.NewTFHandler(p, rt, "sns_sms_preferences_id", "aws_sns_sms_preferences"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Sns_topic{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("sns_topic_id", "arn", "name", "policy")
		b.ImmutableAttributes("name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Sns_topicHandler", bridge.NewTFHandler(p, rt, "sns_topic_id", "aws_sns_topic"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Sns_topic_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("sns_topic_policy_id")
		b.ImmutableAttributes("arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Sns_topic_policyHandler", bridge.NewTFHandler(p, rt, "sns_topic_policy_id", "aws_sns_topic_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Sns_topic_subscription{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("sns_topic_subscription_id", "arn")
		b.ImmutableAttributes("endpoint", "protocol", "topic_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Sns_topic_subscriptionHandler", bridge.NewTFHandler(p, rt, "sns_topic_subscription_id", "aws_sns_topic_subscription"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Spot_datafeed_subscription{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("spot_datafeed_subscription_id")
		b.ImmutableAttributes("bucket", "prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Spot_datafeed_subscriptionHandler", bridge.NewTFHandler(p, rt, "spot_datafeed_subscription_id", "aws_spot_datafeed_subscription"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Spot_fleet_request{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("spot_fleet_request_id", "client_token", "load_balancers", "spot_request_state", "target_group_arns")
		b.ImmutableAttributes("allocation_strategy", "fleet_type", "iam_fleet_role", "instance_interruption_behaviour", "instance_pools_to_use_count", "launch_specification", "load_balancers", "replace_unhealthy_instances", "spot_price", "target_group_arns", "terminate_instances_with_expiration", "valid_from", "valid_until")
	}))[0]
	sb.RegisterHandler("TerraformAws::Spot_fleet_requestHandler", bridge.NewTFHandler(p, rt, "spot_fleet_request_id", "aws_spot_fleet_request"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Spot_instance_request{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("spot_instance_request_id", "arn", "associate_public_ip_address", "availability_zone", "cpu_core_count", "cpu_threads_per_core", "ebs_block_device", "ephemeral_block_device", "host_id", "instance_state", "ipv6_address_count", "ipv6_addresses", "key_name", "network_interface", "network_interface_id", "password_data", "placement_group", "primary_network_interface_id", "private_dns", "private_ip", "public_dns", "public_ip", "root_block_device", "security_groups", "spot_bid_status", "spot_instance_id", "spot_request_state", "subnet_id", "tenancy", "valid_from", "valid_until", "vpc_security_group_ids")
		b.ImmutableAttributes("ami", "arn", "associate_public_ip_address", "availability_zone", "block_device", "block_duration_minutes", "cpu_core_count", "cpu_threads_per_core", "credit_specification", "disable_api_termination", "ebs_block_device", "ebs_optimized", "ephemeral_block_device", "get_password_data", "host_id", "iam_instance_profile", "instance_initiated_shutdown_behavior", "instance_interruption_behaviour", "instance_state", "instance_type", "ipv6_address_count", "ipv6_addresses", "key_name", "launch_group", "monitoring", "network_interface", "network_interface_id", "password_data", "placement_group", "primary_network_interface_id", "private_dns", "private_ip", "public_dns", "public_ip", "root_block_device", "security_groups", "source_dest_check", "spot_price", "subnet_id", "tenancy", "user_data", "user_data_base64", "valid_from", "valid_until", "vpc_security_group_ids")
	}))[0]
	sb.RegisterHandler("TerraformAws::Spot_instance_requestHandler", bridge.NewTFHandler(p, rt, "spot_instance_request_id", "aws_spot_instance_request"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Sqs_queue{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("sqs_queue_id", "arn", "kms_data_key_reuse_period_seconds", "name", "policy")
		b.ImmutableAttributes("fifo_queue", "name", "name_prefix")
	}))[0]
	sb.RegisterHandler("TerraformAws::Sqs_queueHandler", bridge.NewTFHandler(p, rt, "sqs_queue_id", "aws_sqs_queue"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Sqs_queue_policy{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("sqs_queue_policy_id")
		b.ImmutableAttributes("queue_url")
	}))[0]
	sb.RegisterHandler("TerraformAws::Sqs_queue_policyHandler", bridge.NewTFHandler(p, rt, "sqs_queue_policy_id", "aws_sqs_queue_policy"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ssm_activation{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ssm_activation_id", "activation_code", "expired", "registration_count")
		b.ImmutableAttributes("description", "expiration_date", "iam_role", "name", "registration_limit")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ssm_activationHandler", bridge.NewTFHandler(p, rt, "ssm_activation_id", "aws_ssm_activation"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ssm_association{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ssm_association_id", "association_id", "document_version", "parameters", "targets")
		b.ImmutableAttributes("instance_id", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ssm_associationHandler", bridge.NewTFHandler(p, rt, "ssm_association_id", "aws_ssm_association"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ssm_document{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ssm_document_id", "arn", "created_date", "default_version", "description", "hash", "hash_type", "latest_version", "owner", "parameter", "platform_types", "schema_version", "status")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ssm_documentHandler", bridge.NewTFHandler(p, rt, "ssm_document_id", "aws_ssm_document"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ssm_maintenance_window{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ssm_maintenance_window_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ssm_maintenance_windowHandler", bridge.NewTFHandler(p, rt, "ssm_maintenance_window_id", "aws_ssm_maintenance_window"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ssm_maintenance_window_target{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ssm_maintenance_window_target_id")
		b.ImmutableAttributes("resource_type", "window_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ssm_maintenance_window_targetHandler", bridge.NewTFHandler(p, rt, "ssm_maintenance_window_target_id", "aws_ssm_maintenance_window_target"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ssm_maintenance_window_task{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ssm_maintenance_window_task_id")
		b.ImmutableAttributes("description", "logging_info", "max_concurrency", "max_errors", "name", "priority", "service_role_arn", "targets", "task_arn", "task_parameters", "task_type", "window_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ssm_maintenance_window_taskHandler", bridge.NewTFHandler(p, rt, "ssm_maintenance_window_task_id", "aws_ssm_maintenance_window_task"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ssm_parameter{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ssm_parameter_id", "arn", "key_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ssm_parameterHandler", bridge.NewTFHandler(p, rt, "ssm_parameter_id", "aws_ssm_parameter"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ssm_patch_baseline{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ssm_patch_baseline_id")
		b.ImmutableAttributes("operating_system")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ssm_patch_baselineHandler", bridge.NewTFHandler(p, rt, "ssm_patch_baseline_id", "aws_ssm_patch_baseline"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ssm_patch_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ssm_patch_group_id")
		b.ImmutableAttributes("baseline_id", "patch_group")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ssm_patch_groupHandler", bridge.NewTFHandler(p, rt, "ssm_patch_group_id", "aws_ssm_patch_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Ssm_resource_data_sync{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("ssm_resource_data_sync_id")
		b.ImmutableAttributes("name", "s3_destination")
	}))[0]
	sb.RegisterHandler("TerraformAws::Ssm_resource_data_syncHandler", bridge.NewTFHandler(p, rt, "ssm_resource_data_sync_id", "aws_ssm_resource_data_sync"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Storagegateway_cache{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("storagegateway_cache_id")
		b.ImmutableAttributes("disk_id", "gateway_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Storagegateway_cacheHandler", bridge.NewTFHandler(p, rt, "storagegateway_cache_id", "aws_storagegateway_cache"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Storagegateway_cached_iscsi_volume{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("storagegateway_cached_iscsi_volume_id", "arn", "chap_enabled", "lun_number", "network_interface_port", "target_arn", "volume_arn", "volume_id")
		b.ImmutableAttributes("gateway_arn", "network_interface_id", "snapshot_id", "source_volume_arn", "target_name", "volume_size_in_bytes")
	}))[0]
	sb.RegisterHandler("TerraformAws::Storagegateway_cached_iscsi_volumeHandler", bridge.NewTFHandler(p, rt, "storagegateway_cached_iscsi_volume_id", "aws_storagegateway_cached_iscsi_volume"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Storagegateway_gateway{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("storagegateway_gateway_id", "activation_key", "arn", "gateway_id", "gateway_ip_address")
		b.ImmutableAttributes("activation_key", "gateway_ip_address", "gateway_type", "medium_changer_type", "tape_drive_type")
	}))[0]
	sb.RegisterHandler("TerraformAws::Storagegateway_gatewayHandler", bridge.NewTFHandler(p, rt, "storagegateway_gateway_id", "aws_storagegateway_gateway"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Storagegateway_nfs_file_share{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("storagegateway_nfs_file_share_id", "arn", "fileshare_id")
		b.ImmutableAttributes("gateway_arn", "location_arn", "role_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Storagegateway_nfs_file_shareHandler", bridge.NewTFHandler(p, rt, "storagegateway_nfs_file_share_id", "aws_storagegateway_nfs_file_share"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Storagegateway_smb_file_share{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("storagegateway_smb_file_share_id", "arn", "fileshare_id")
		b.ImmutableAttributes("authentication", "gateway_arn", "location_arn", "role_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Storagegateway_smb_file_shareHandler", bridge.NewTFHandler(p, rt, "storagegateway_smb_file_share_id", "aws_storagegateway_smb_file_share"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Storagegateway_upload_buffer{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("storagegateway_upload_buffer_id")
		b.ImmutableAttributes("disk_id", "gateway_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Storagegateway_upload_bufferHandler", bridge.NewTFHandler(p, rt, "storagegateway_upload_buffer_id", "aws_storagegateway_upload_buffer"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Storagegateway_working_storage{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("storagegateway_working_storage_id")
		b.ImmutableAttributes("disk_id", "gateway_arn")
	}))[0]
	sb.RegisterHandler("TerraformAws::Storagegateway_working_storageHandler", bridge.NewTFHandler(p, rt, "storagegateway_working_storage_id", "aws_storagegateway_working_storage"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Subnet{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("subnet_id", "arn", "availability_zone", "availability_zone_id", "ipv6_cidr_block", "ipv6_cidr_block_association_id", "owner_id")
		b.ImmutableAttributes("availability_zone", "availability_zone_id", "cidr_block", "vpc_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::SubnetHandler", bridge.NewTFHandler(p, rt, "subnet_id", "aws_subnet"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Swf_domain{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("swf_domain_id", "name")
		b.ImmutableAttributes("description", "name", "name_prefix", "workflow_execution_retention_period_in_days")
	}))[0]
	sb.RegisterHandler("TerraformAws::Swf_domainHandler", bridge.NewTFHandler(p, rt, "swf_domain_id", "aws_swf_domain"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Transfer_server{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("transfer_server_id", "arn", "endpoint")
		b.ImmutableAttributes("identity_provider_type")
	}))[0]
	sb.RegisterHandler("TerraformAws::Transfer_serverHandler", bridge.NewTFHandler(p, rt, "transfer_server_id", "aws_transfer_server"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Transfer_ssh_key{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("transfer_ssh_key_id")
		b.ImmutableAttributes("body", "server_id", "user_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Transfer_ssh_keyHandler", bridge.NewTFHandler(p, rt, "transfer_ssh_key_id", "aws_transfer_ssh_key"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Transfer_user{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("transfer_user_id", "arn")
		b.ImmutableAttributes("server_id", "user_name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Transfer_userHandler", bridge.NewTFHandler(p, rt, "transfer_user_id", "aws_transfer_user"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Volume_attachment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("volume_attachment_id")
		b.ImmutableAttributes("device_name", "instance_id", "volume_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Volume_attachmentHandler", bridge.NewTFHandler(p, rt, "volume_attachment_id", "aws_volume_attachment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Vpc{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("vpc_id", "arn", "default_network_acl_id", "default_route_table_id", "default_security_group_id", "dhcp_options_id", "enable_classiclink", "enable_classiclink_dns_support", "enable_dns_hostnames", "ipv6_association_id", "ipv6_cidr_block", "main_route_table_id", "owner_id")
		b.ImmutableAttributes("cidr_block")
	}))[0]
	sb.RegisterHandler("TerraformAws::VpcHandler", bridge.NewTFHandler(p, rt, "vpc_id", "aws_vpc"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Vpc_dhcp_options{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("vpc_dhcp_options_id", "owner_id")
		b.ImmutableAttributes("domain_name", "domain_name_servers", "netbios_name_servers", "netbios_node_type", "ntp_servers")
	}))[0]
	sb.RegisterHandler("TerraformAws::Vpc_dhcp_optionsHandler", bridge.NewTFHandler(p, rt, "vpc_dhcp_options_id", "aws_vpc_dhcp_options"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Vpc_dhcp_options_association{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("vpc_dhcp_options_association_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Vpc_dhcp_options_associationHandler", bridge.NewTFHandler(p, rt, "vpc_dhcp_options_association_id", "aws_vpc_dhcp_options_association"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Vpc_endpoint{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("vpc_endpoint_id", "cidr_blocks", "dns_entry", "network_interface_ids", "policy", "prefix_list_id", "route_table_ids", "security_group_ids", "state", "subnet_ids")
		b.ImmutableAttributes("service_name", "vpc_endpoint_type", "vpc_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Vpc_endpointHandler", bridge.NewTFHandler(p, rt, "vpc_endpoint_id", "aws_vpc_endpoint"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Vpc_endpoint_connection_notification{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("vpc_endpoint_connection_notification_id", "notification_type", "state")
		b.ImmutableAttributes("vpc_endpoint_id", "vpc_endpoint_service_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Vpc_endpoint_connection_notificationHandler", bridge.NewTFHandler(p, rt, "vpc_endpoint_connection_notification_id", "aws_vpc_endpoint_connection_notification"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Vpc_endpoint_route_table_association{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("vpc_endpoint_route_table_association_id")
		b.ImmutableAttributes("route_table_id", "vpc_endpoint_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Vpc_endpoint_route_table_associationHandler", bridge.NewTFHandler(p, rt, "vpc_endpoint_route_table_association_id", "aws_vpc_endpoint_route_table_association"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Vpc_endpoint_service{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("vpc_endpoint_service_id", "allowed_principals", "availability_zones", "base_endpoint_dns_names", "private_dns_name", "service_name", "service_type", "state")
	}))[0]
	sb.RegisterHandler("TerraformAws::Vpc_endpoint_serviceHandler", bridge.NewTFHandler(p, rt, "vpc_endpoint_service_id", "aws_vpc_endpoint_service"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Vpc_endpoint_service_allowed_principal{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("vpc_endpoint_service_allowed_principal_id")
		b.ImmutableAttributes("principal_arn", "vpc_endpoint_service_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Vpc_endpoint_service_allowed_principalHandler", bridge.NewTFHandler(p, rt, "vpc_endpoint_service_allowed_principal_id", "aws_vpc_endpoint_service_allowed_principal"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Vpc_endpoint_subnet_association{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("vpc_endpoint_subnet_association_id")
		b.ImmutableAttributes("subnet_id", "vpc_endpoint_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Vpc_endpoint_subnet_associationHandler", bridge.NewTFHandler(p, rt, "vpc_endpoint_subnet_association_id", "aws_vpc_endpoint_subnet_association"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Vpc_ipv4_cidr_block_association{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("vpc_ipv4_cidr_block_association_id")
		b.ImmutableAttributes("cidr_block", "vpc_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Vpc_ipv4_cidr_block_associationHandler", bridge.NewTFHandler(p, rt, "vpc_ipv4_cidr_block_association_id", "aws_vpc_ipv4_cidr_block_association"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Vpc_peering_connection{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("vpc_peering_connection_id", "accept_status", "accepter", "peer_owner_id", "peer_region", "requester")
		b.ImmutableAttributes("peer_owner_id", "peer_region", "peer_vpc_id", "vpc_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Vpc_peering_connectionHandler", bridge.NewTFHandler(p, rt, "vpc_peering_connection_id", "aws_vpc_peering_connection"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Vpc_peering_connection_accepter{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("vpc_peering_connection_accepter_id", "accept_status", "accepter", "peer_owner_id", "peer_region", "peer_vpc_id", "requester", "vpc_id")
		b.ImmutableAttributes("vpc_peering_connection_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Vpc_peering_connection_accepterHandler", bridge.NewTFHandler(p, rt, "vpc_peering_connection_accepter_id", "aws_vpc_peering_connection_accepter"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Vpc_peering_connection_options{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("vpc_peering_connection_options_id", "accepter", "requester")
		b.ImmutableAttributes("vpc_peering_connection_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Vpc_peering_connection_optionsHandler", bridge.NewTFHandler(p, rt, "vpc_peering_connection_options_id", "aws_vpc_peering_connection_options"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Vpn_connection{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("vpn_connection_id", "customer_gateway_configuration", "routes", "static_routes_only", "tunnel1_address", "tunnel1_bgp_asn", "tunnel1_bgp_holdtime", "tunnel1_cgw_inside_address", "tunnel1_inside_cidr", "tunnel1_preshared_key", "tunnel1_vgw_inside_address", "tunnel2_address", "tunnel2_bgp_asn", "tunnel2_bgp_holdtime", "tunnel2_cgw_inside_address", "tunnel2_inside_cidr", "tunnel2_preshared_key", "tunnel2_vgw_inside_address", "vgw_telemetry")
		b.ImmutableAttributes("customer_gateway_id", "static_routes_only", "transit_gateway_id", "tunnel1_inside_cidr", "tunnel1_preshared_key", "tunnel2_inside_cidr", "tunnel2_preshared_key", "type", "vpn_gateway_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Vpn_connectionHandler", bridge.NewTFHandler(p, rt, "vpn_connection_id", "aws_vpn_connection"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Vpn_connection_route{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("vpn_connection_route_id")
		b.ImmutableAttributes("destination_cidr_block", "vpn_connection_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Vpn_connection_routeHandler", bridge.NewTFHandler(p, rt, "vpn_connection_route_id", "aws_vpn_connection_route"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Vpn_gateway{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("vpn_gateway_id", "amazon_side_asn", "vpc_id")
		b.ImmutableAttributes("amazon_side_asn", "availability_zone")
	}))[0]
	sb.RegisterHandler("TerraformAws::Vpn_gatewayHandler", bridge.NewTFHandler(p, rt, "vpn_gateway_id", "aws_vpn_gateway"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Vpn_gateway_attachment{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("vpn_gateway_attachment_id")
		b.ImmutableAttributes("vpc_id", "vpn_gateway_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Vpn_gateway_attachmentHandler", bridge.NewTFHandler(p, rt, "vpn_gateway_attachment_id", "aws_vpn_gateway_attachment"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Vpn_gateway_route_propagation{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("vpn_gateway_route_propagation_id")
		b.ImmutableAttributes("route_table_id", "vpn_gateway_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Vpn_gateway_route_propagationHandler", bridge.NewTFHandler(p, rt, "vpn_gateway_route_propagation_id", "aws_vpn_gateway_route_propagation"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Waf_byte_match_set{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("waf_byte_match_set_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Waf_byte_match_setHandler", bridge.NewTFHandler(p, rt, "waf_byte_match_set_id", "aws_waf_byte_match_set"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Waf_geo_match_set{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("waf_geo_match_set_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Waf_geo_match_setHandler", bridge.NewTFHandler(p, rt, "waf_geo_match_set_id", "aws_waf_geo_match_set"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Waf_ipset{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("waf_ipset_id", "arn")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Waf_ipsetHandler", bridge.NewTFHandler(p, rt, "waf_ipset_id", "aws_waf_ipset"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Waf_rate_based_rule{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("waf_rate_based_rule_id")
		b.ImmutableAttributes("metric_name", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Waf_rate_based_ruleHandler", bridge.NewTFHandler(p, rt, "waf_rate_based_rule_id", "aws_waf_rate_based_rule"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Waf_regex_match_set{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("waf_regex_match_set_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Waf_regex_match_setHandler", bridge.NewTFHandler(p, rt, "waf_regex_match_set_id", "aws_waf_regex_match_set"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Waf_regex_pattern_set{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("waf_regex_pattern_set_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Waf_regex_pattern_setHandler", bridge.NewTFHandler(p, rt, "waf_regex_pattern_set_id", "aws_waf_regex_pattern_set"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Waf_rule{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("waf_rule_id")
		b.ImmutableAttributes("metric_name", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Waf_ruleHandler", bridge.NewTFHandler(p, rt, "waf_rule_id", "aws_waf_rule"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Waf_rule_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("waf_rule_group_id")
		b.ImmutableAttributes("metric_name", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Waf_rule_groupHandler", bridge.NewTFHandler(p, rt, "waf_rule_group_id", "aws_waf_rule_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Waf_size_constraint_set{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("waf_size_constraint_set_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Waf_size_constraint_setHandler", bridge.NewTFHandler(p, rt, "waf_size_constraint_set_id", "aws_waf_size_constraint_set"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Waf_sql_injection_match_set{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("waf_sql_injection_match_set_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Waf_sql_injection_match_setHandler", bridge.NewTFHandler(p, rt, "waf_sql_injection_match_set_id", "aws_waf_sql_injection_match_set"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Waf_web_acl{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("waf_web_acl_id")
		b.ImmutableAttributes("metric_name", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Waf_web_aclHandler", bridge.NewTFHandler(p, rt, "waf_web_acl_id", "aws_waf_web_acl"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Waf_xss_match_set{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("waf_xss_match_set_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Waf_xss_match_setHandler", bridge.NewTFHandler(p, rt, "waf_xss_match_set_id", "aws_waf_xss_match_set"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Wafregional_byte_match_set{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("wafregional_byte_match_set_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Wafregional_byte_match_setHandler", bridge.NewTFHandler(p, rt, "wafregional_byte_match_set_id", "aws_wafregional_byte_match_set"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Wafregional_geo_match_set{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("wafregional_geo_match_set_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Wafregional_geo_match_setHandler", bridge.NewTFHandler(p, rt, "wafregional_geo_match_set_id", "aws_wafregional_geo_match_set"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Wafregional_ipset{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("wafregional_ipset_id", "arn")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Wafregional_ipsetHandler", bridge.NewTFHandler(p, rt, "wafregional_ipset_id", "aws_wafregional_ipset"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Wafregional_rate_based_rule{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("wafregional_rate_based_rule_id")
		b.ImmutableAttributes("metric_name", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Wafregional_rate_based_ruleHandler", bridge.NewTFHandler(p, rt, "wafregional_rate_based_rule_id", "aws_wafregional_rate_based_rule"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Wafregional_regex_match_set{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("wafregional_regex_match_set_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Wafregional_regex_match_setHandler", bridge.NewTFHandler(p, rt, "wafregional_regex_match_set_id", "aws_wafregional_regex_match_set"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Wafregional_regex_pattern_set{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("wafregional_regex_pattern_set_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Wafregional_regex_pattern_setHandler", bridge.NewTFHandler(p, rt, "wafregional_regex_pattern_set_id", "aws_wafregional_regex_pattern_set"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Wafregional_rule{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("wafregional_rule_id")
		b.ImmutableAttributes("metric_name", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Wafregional_ruleHandler", bridge.NewTFHandler(p, rt, "wafregional_rule_id", "aws_wafregional_rule"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Wafregional_rule_group{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("wafregional_rule_group_id")
		b.ImmutableAttributes("metric_name", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Wafregional_rule_groupHandler", bridge.NewTFHandler(p, rt, "wafregional_rule_group_id", "aws_wafregional_rule_group"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Wafregional_size_constraint_set{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("wafregional_size_constraint_set_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Wafregional_size_constraint_setHandler", bridge.NewTFHandler(p, rt, "wafregional_size_constraint_set_id", "aws_wafregional_size_constraint_set"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Wafregional_sql_injection_match_set{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("wafregional_sql_injection_match_set_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Wafregional_sql_injection_match_setHandler", bridge.NewTFHandler(p, rt, "wafregional_sql_injection_match_set_id", "aws_wafregional_sql_injection_match_set"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Wafregional_web_acl{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("wafregional_web_acl_id")
		b.ImmutableAttributes("metric_name", "name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Wafregional_web_aclHandler", bridge.NewTFHandler(p, rt, "wafregional_web_acl_id", "aws_wafregional_web_acl"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Wafregional_web_acl_association{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("wafregional_web_acl_association_id")
		b.ImmutableAttributes("resource_arn", "web_acl_id")
	}))[0]
	sb.RegisterHandler("TerraformAws::Wafregional_web_acl_associationHandler", bridge.NewTFHandler(p, rt, "wafregional_web_acl_association_id", "aws_wafregional_web_acl_association"), rt)

	rt = sb.RegisterTypes("TerraformAws", sb.BuildResource(&Wafregional_xss_match_set{}, func(b service.ResourceTypeBuilder) {
		b.ProvidedAttributes("wafregional_xss_match_set_id")
		b.ImmutableAttributes("name")
	}))[0]
	sb.RegisterHandler("TerraformAws::Wafregional_xss_match_setHandler", bridge.NewTFHandler(p, rt, "wafregional_xss_match_set_id", "aws_wafregional_xss_match_set"), rt)

}
