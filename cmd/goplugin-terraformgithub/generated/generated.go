// Code generated by Lyra DO NOT EDIT.

// This code is generated on a per-provider basis using "tf-gen"
// Long term our hope is to remove this generation step and adopt dynamic approach

package generated

import (
	"sync"

	"github.com/davecgh/go-spew/spew"
	"github.com/hashicorp/go-hclog"
	"github.com/hashicorp/terraform/helper/schema"
	"github.com/hashicorp/terraform/terraform"
	"github.com/lyraproj/terraform-bridge/pkg/bridge"
	"github.com/lyraproj/pcore/px"
	"github.com/lyraproj/servicesdk/service"
)

var once sync.Once
var Config *terraform.ResourceConfig

func configureProvider(p *schema.Provider) {
	once.Do(func() {
		if Config == nil {
			Config = &terraform.ResourceConfig{
				Config: map[string]interface{}{},
			}
		}
		err := p.Configure(Config)
		if err != nil {
			panic(err)
		}
	})
}

func Initialize(sb *service.Builder, p *schema.Provider) {
	var evs []px.Type

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_branch_protection{}, Github_branch_protection_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_branch_protectionHandler", &Github_branch_protectionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_issue_label{}, Github_issue_label_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_issue_labelHandler", &Github_issue_labelHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_membership{}, Github_membership_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_membershipHandler", &Github_membershipHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_organization_project{}, Github_organization_project_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_organization_projectHandler", &Github_organization_projectHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_organization_webhook{}, Github_organization_webhook_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_organization_webhookHandler", &Github_organization_webhookHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_project_column{}, Github_project_column_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_project_columnHandler", &Github_project_columnHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_repository{}, Github_repository_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_repositoryHandler", &Github_repositoryHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_repository_collaborator{}, Github_repository_collaborator_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_repository_collaboratorHandler", &Github_repository_collaboratorHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_repository_deploy_key{}, Github_repository_deploy_key_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_repository_deploy_keyHandler", &Github_repository_deploy_keyHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_repository_project{}, Github_repository_project_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_repository_projectHandler", &Github_repository_projectHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_repository_webhook{}, Github_repository_webhook_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_repository_webhookHandler", &Github_repository_webhookHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_team{}, Github_team_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_teamHandler", &Github_teamHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_team_membership{}, Github_team_membership_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_team_membershipHandler", &Github_team_membershipHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_team_repository{}, Github_team_repository_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_team_repositoryHandler", &Github_team_repositoryHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_user_gpg_key{}, Github_user_gpg_key_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_user_gpg_keyHandler", &Github_user_gpg_keyHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformGitHub", sb.BuildResource(&Github_user_ssh_key{}, Github_user_ssh_key_rtb))
	sb.RegisterHandler("TerraformGitHub::Github_user_ssh_keyHandler", &Github_user_ssh_keyHandler{provider: p}, evs[0])

}

type Github_branch_protection_required_pull_request_reviews_1 struct {
	Dismiss_stale_reviews *bool

	Dismissal_teams *[]string

	Dismissal_users *[]string

	Include_admins *bool

	Require_code_owner_reviews *bool
}

type Github_branch_protection_required_status_checks_2 struct {
	Contexts *[]string

	Include_admins *bool

	Strict *bool
}

type Github_branch_protection_restrictions_3 struct {
	Teams *[]string

	Users *[]string
}

type Github_branch_protection struct {
	Github_branch_protection_id *string `lyra:"ignore"`

	Branch string

	Enforce_admins *bool

	Etag *string

	Repository string

	Required_pull_request_reviews *[]Github_branch_protection_required_pull_request_reviews_1

	Required_status_checks *[]Github_branch_protection_required_status_checks_2

	Restrictions *[]Github_branch_protection_restrictions_3
}

var Github_branch_protection_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_branch_protection_id",

		"enforce_admins",

		"etag",

		"required_pull_request_reviews",

		"required_status_checks",

		"restrictions",
	)
	rtb.ImmutableAttributes(

		"branch",

		"repository",
	)
}

// Github_branch_protectionHandler ...
type Github_branch_protectionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_branch_protectionHandler) Create(desired *Github_branch_protection) (*Github_branch_protection, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_branch_protection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_branch_protection", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_branch_protectionHandler) Update(externalID string, desired *Github_branch_protection) (*Github_branch_protection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_branch_protection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_branch_protection", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Github_branch_protection{Github_branch_protection_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_branch_protection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_branch_protectionHandler) Read(externalID string) (*Github_branch_protection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_branch_protection", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_branch_protection", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_branch_protection{Github_branch_protection_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_branch_protection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_branch_protectionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_branch_protection", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_branch_protection", externalID)
}

type Github_issue_label struct {
	Github_issue_label_id *string `lyra:"ignore"`

	Color string

	Description *string

	Etag *string

	Name string

	Repository string

	Url *string
}

var Github_issue_label_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_issue_label_id",

		"description",

		"etag",

		"url",
	)
	rtb.ImmutableAttributes(

		"repository",
	)
}

// Github_issue_labelHandler ...
type Github_issue_labelHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_issue_labelHandler) Create(desired *Github_issue_label) (*Github_issue_label, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_issue_label", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_issue_label", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_issue_labelHandler) Update(externalID string, desired *Github_issue_label) (*Github_issue_label, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_issue_label", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_issue_label", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Github_issue_label{Github_issue_label_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_issue_label", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_issue_labelHandler) Read(externalID string) (*Github_issue_label, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_issue_label", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_issue_label", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_issue_label{Github_issue_label_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_issue_label", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_issue_labelHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_issue_label", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_issue_label", externalID)
}

type Github_membership struct {
	Github_membership_id *string `lyra:"ignore"`

	Etag *string

	Role *string

	Username string
}

var Github_membership_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_membership_id",

		"etag",

		"role",
	)
	rtb.ImmutableAttributes(

		"username",
	)
}

// Github_membershipHandler ...
type Github_membershipHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_membershipHandler) Create(desired *Github_membership) (*Github_membership, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_membership", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_membership", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_membershipHandler) Update(externalID string, desired *Github_membership) (*Github_membership, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_membership", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_membership", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Github_membership{Github_membership_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_membership", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_membershipHandler) Read(externalID string) (*Github_membership, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_membership", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_membership", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_membership{Github_membership_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_membership", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_membershipHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_membership", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_membership", externalID)
}

type Github_organization_project struct {
	Github_organization_project_id *string `lyra:"ignore"`

	Body *string

	Etag *string

	Name string

	Url *string
}

var Github_organization_project_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_organization_project_id",

		"body",

		"etag",

		"url",
	)
	rtb.ImmutableAttributes()
}

// Github_organization_projectHandler ...
type Github_organization_projectHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_organization_projectHandler) Create(desired *Github_organization_project) (*Github_organization_project, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_organization_project", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_organization_project", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_organization_projectHandler) Update(externalID string, desired *Github_organization_project) (*Github_organization_project, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_organization_project", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_organization_project", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Github_organization_project{Github_organization_project_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_organization_project", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_organization_projectHandler) Read(externalID string) (*Github_organization_project, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_organization_project", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_organization_project", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_organization_project{Github_organization_project_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_organization_project", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_organization_projectHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_organization_project", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_organization_project", externalID)
}

type Github_organization_webhook_configuration_4 struct {
	Content_type *string

	Insecure_ssl *string

	Secret *string

	Url string
}

type Github_organization_webhook struct {
	Github_organization_webhook_id *string `lyra:"ignore"`

	Active *bool

	Configuration *[]Github_organization_webhook_configuration_4

	Etag *string

	Events []string

	Name string

	Url *string
}

var Github_organization_webhook_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_organization_webhook_id",

		"active",

		"configuration",

		"etag",

		"url",
	)
	rtb.ImmutableAttributes(

		"name",
	)
}

// Github_organization_webhookHandler ...
type Github_organization_webhookHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_organization_webhookHandler) Create(desired *Github_organization_webhook) (*Github_organization_webhook, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_organization_webhook", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_organization_webhook", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_organization_webhookHandler) Update(externalID string, desired *Github_organization_webhook) (*Github_organization_webhook, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_organization_webhook", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_organization_webhook", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Github_organization_webhook{Github_organization_webhook_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_organization_webhook", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_organization_webhookHandler) Read(externalID string) (*Github_organization_webhook, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_organization_webhook", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_organization_webhook", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_organization_webhook{Github_organization_webhook_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_organization_webhook", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_organization_webhookHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_organization_webhook", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_organization_webhook", externalID)
}

type Github_project_column struct {
	Github_project_column_id *string `lyra:"ignore"`

	Etag *string

	Name string

	Project_id string
}

var Github_project_column_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_project_column_id",

		"etag",
	)
	rtb.ImmutableAttributes(

		"project_id",
	)
}

// Github_project_columnHandler ...
type Github_project_columnHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_project_columnHandler) Create(desired *Github_project_column) (*Github_project_column, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_project_column", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_project_column", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_project_columnHandler) Update(externalID string, desired *Github_project_column) (*Github_project_column, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_project_column", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_project_column", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Github_project_column{Github_project_column_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_project_column", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_project_columnHandler) Read(externalID string) (*Github_project_column, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_project_column", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_project_column", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_project_column{Github_project_column_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_project_column", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_project_columnHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_project_column", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_project_column", externalID)
}

type Github_repository struct {
	Github_repository_id *string `lyra:"ignore"`

	Allow_merge_commit *bool

	Allow_rebase_merge *bool

	Allow_squash_merge *bool

	Archived *bool

	Auto_init *bool

	Default_branch *string

	Description *string

	Etag *string

	Full_name *string

	Git_clone_url *string

	Gitignore_template *string

	Has_downloads *bool

	Has_issues *bool

	Has_projects *bool

	Has_wiki *bool

	Homepage_url *string

	Html_url *string

	Http_clone_url *string

	License_template *string

	Name string

	Private *bool

	Ssh_clone_url *string

	Svn_url *string

	Topics *[]string
}

var Github_repository_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_repository_id",

		"allow_merge_commit",

		"allow_rebase_merge",

		"allow_squash_merge",

		"archived",

		"auto_init",

		"default_branch",

		"description",

		"etag",

		"full_name",

		"git_clone_url",

		"gitignore_template",

		"has_downloads",

		"has_issues",

		"has_projects",

		"has_wiki",

		"homepage_url",

		"html_url",

		"http_clone_url",

		"license_template",

		"private",

		"ssh_clone_url",

		"svn_url",

		"topics",
	)
	rtb.ImmutableAttributes(

		"auto_init",

		"gitignore_template",

		"license_template",

		"name",
	)
}

// Github_repositoryHandler ...
type Github_repositoryHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_repositoryHandler) Create(desired *Github_repository) (*Github_repository, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_repository", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_repository", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_repositoryHandler) Update(externalID string, desired *Github_repository) (*Github_repository, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_repository", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_repository", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Github_repository{Github_repository_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_repository", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_repositoryHandler) Read(externalID string) (*Github_repository, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_repository", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_repository", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_repository{Github_repository_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_repository", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_repositoryHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_repository", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_repository", externalID)
}

type Github_repository_collaborator struct {
	Github_repository_collaborator_id *string `lyra:"ignore"`

	Permission *string

	Repository string

	Username string
}

var Github_repository_collaborator_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_repository_collaborator_id",

		"permission",
	)
	rtb.ImmutableAttributes(

		"permission",

		"repository",

		"username",
	)
}

// Github_repository_collaboratorHandler ...
type Github_repository_collaboratorHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_repository_collaboratorHandler) Create(desired *Github_repository_collaborator) (*Github_repository_collaborator, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_repository_collaborator", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_repository_collaborator", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_repository_collaboratorHandler) Update(externalID string, desired *Github_repository_collaborator) (*Github_repository_collaborator, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_repository_collaborator", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_repository_collaborator", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_collaborator{Github_repository_collaborator_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_repository_collaborator", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_repository_collaboratorHandler) Read(externalID string) (*Github_repository_collaborator, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_repository_collaborator", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_repository_collaborator", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_collaborator{Github_repository_collaborator_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_repository_collaborator", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_repository_collaboratorHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_repository_collaborator", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_repository_collaborator", externalID)
}

type Github_repository_deploy_key struct {
	Github_repository_deploy_key_id *string `lyra:"ignore"`

	Etag *string

	Key string

	Read_only *bool

	Repository string

	Title string
}

var Github_repository_deploy_key_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_repository_deploy_key_id",

		"etag",

		"read_only",
	)
	rtb.ImmutableAttributes(

		"key",

		"read_only",

		"repository",

		"title",
	)
}

// Github_repository_deploy_keyHandler ...
type Github_repository_deploy_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_repository_deploy_keyHandler) Create(desired *Github_repository_deploy_key) (*Github_repository_deploy_key, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_repository_deploy_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_repository_deploy_key", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_repository_deploy_keyHandler) Update(externalID string, desired *Github_repository_deploy_key) (*Github_repository_deploy_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_repository_deploy_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_repository_deploy_key", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_deploy_key{Github_repository_deploy_key_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_repository_deploy_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_repository_deploy_keyHandler) Read(externalID string) (*Github_repository_deploy_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_repository_deploy_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_repository_deploy_key", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_deploy_key{Github_repository_deploy_key_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_repository_deploy_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_repository_deploy_keyHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_repository_deploy_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_repository_deploy_key", externalID)
}

type Github_repository_project struct {
	Github_repository_project_id *string `lyra:"ignore"`

	Body *string

	Etag *string

	Name string

	Repository string

	Url *string
}

var Github_repository_project_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_repository_project_id",

		"body",

		"etag",

		"url",
	)
	rtb.ImmutableAttributes(

		"repository",
	)
}

// Github_repository_projectHandler ...
type Github_repository_projectHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_repository_projectHandler) Create(desired *Github_repository_project) (*Github_repository_project, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_repository_project", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_repository_project", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_repository_projectHandler) Update(externalID string, desired *Github_repository_project) (*Github_repository_project, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_repository_project", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_repository_project", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_project{Github_repository_project_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_repository_project", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_repository_projectHandler) Read(externalID string) (*Github_repository_project, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_repository_project", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_repository_project", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_project{Github_repository_project_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_repository_project", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_repository_projectHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_repository_project", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_repository_project", externalID)
}

type Github_repository_webhook_configuration_5 struct {
	Content_type *string

	Insecure_ssl *string

	Secret *string

	Url string
}

type Github_repository_webhook struct {
	Github_repository_webhook_id *string `lyra:"ignore"`

	Active *bool

	Configuration *[]Github_repository_webhook_configuration_5

	Etag *string

	Events []string

	Name string

	Repository string

	Url *string
}

var Github_repository_webhook_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_repository_webhook_id",

		"active",

		"configuration",

		"etag",

		"url",
	)
	rtb.ImmutableAttributes(

		"name",

		"repository",
	)
}

// Github_repository_webhookHandler ...
type Github_repository_webhookHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_repository_webhookHandler) Create(desired *Github_repository_webhook) (*Github_repository_webhook, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_repository_webhook", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_repository_webhook", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_repository_webhookHandler) Update(externalID string, desired *Github_repository_webhook) (*Github_repository_webhook, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_repository_webhook", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_repository_webhook", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_webhook{Github_repository_webhook_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_repository_webhook", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_repository_webhookHandler) Read(externalID string) (*Github_repository_webhook, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_repository_webhook", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_repository_webhook", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_repository_webhook{Github_repository_webhook_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_repository_webhook", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_repository_webhookHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_repository_webhook", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_repository_webhook", externalID)
}

type Github_team struct {
	Github_team_id *string `lyra:"ignore"`

	Description *string

	Etag *string

	Ldap_dn *string

	Name string

	Parent_team_id *int

	Privacy *string

	Slug *string
}

var Github_team_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_team_id",

		"description",

		"etag",

		"ldap_dn",

		"parent_team_id",

		"privacy",

		"slug",
	)
	rtb.ImmutableAttributes()
}

// Github_teamHandler ...
type Github_teamHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_teamHandler) Create(desired *Github_team) (*Github_team, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_team", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_team", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_teamHandler) Update(externalID string, desired *Github_team) (*Github_team, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_team", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_team", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Github_team{Github_team_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_team", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_teamHandler) Read(externalID string) (*Github_team, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_team", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_team", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_team{Github_team_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_team", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_teamHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_team", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_team", externalID)
}

type Github_team_membership struct {
	Github_team_membership_id *string `lyra:"ignore"`

	Etag *string

	Role *string

	Team_id string

	Username string
}

var Github_team_membership_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_team_membership_id",

		"etag",

		"role",
	)
	rtb.ImmutableAttributes(

		"team_id",

		"username",
	)
}

// Github_team_membershipHandler ...
type Github_team_membershipHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_team_membershipHandler) Create(desired *Github_team_membership) (*Github_team_membership, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_team_membership", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_team_membership", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_team_membershipHandler) Update(externalID string, desired *Github_team_membership) (*Github_team_membership, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_team_membership", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_team_membership", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Github_team_membership{Github_team_membership_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_team_membership", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_team_membershipHandler) Read(externalID string) (*Github_team_membership, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_team_membership", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_team_membership", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_team_membership{Github_team_membership_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_team_membership", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_team_membershipHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_team_membership", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_team_membership", externalID)
}

type Github_team_repository struct {
	Github_team_repository_id *string `lyra:"ignore"`

	Etag *string

	Permission *string

	Repository string

	Team_id string
}

var Github_team_repository_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_team_repository_id",

		"etag",

		"permission",
	)
	rtb.ImmutableAttributes(

		"repository",

		"team_id",
	)
}

// Github_team_repositoryHandler ...
type Github_team_repositoryHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_team_repositoryHandler) Create(desired *Github_team_repository) (*Github_team_repository, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_team_repository", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_team_repository", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_team_repositoryHandler) Update(externalID string, desired *Github_team_repository) (*Github_team_repository, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_team_repository", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_team_repository", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Github_team_repository{Github_team_repository_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_team_repository", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_team_repositoryHandler) Read(externalID string) (*Github_team_repository, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_team_repository", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_team_repository", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_team_repository{Github_team_repository_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_team_repository", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_team_repositoryHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_team_repository", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_team_repository", externalID)
}

type Github_user_gpg_key struct {
	Github_user_gpg_key_id *string `lyra:"ignore"`

	Armored_public_key string

	Etag *string

	Key_id *string
}

var Github_user_gpg_key_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_user_gpg_key_id",

		"etag",

		"key_id",
	)
	rtb.ImmutableAttributes(

		"armored_public_key",
	)
}

// Github_user_gpg_keyHandler ...
type Github_user_gpg_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_user_gpg_keyHandler) Create(desired *Github_user_gpg_key) (*Github_user_gpg_key, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_user_gpg_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_user_gpg_key", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_user_gpg_keyHandler) Update(externalID string, desired *Github_user_gpg_key) (*Github_user_gpg_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_user_gpg_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_user_gpg_key", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Github_user_gpg_key{Github_user_gpg_key_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_user_gpg_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_user_gpg_keyHandler) Read(externalID string) (*Github_user_gpg_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_user_gpg_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_user_gpg_key", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_user_gpg_key{Github_user_gpg_key_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_user_gpg_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_user_gpg_keyHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_user_gpg_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_user_gpg_key", externalID)
}

type Github_user_ssh_key struct {
	Github_user_ssh_key_id *string `lyra:"ignore"`

	Etag *string

	Key string

	Title string

	Url *string
}

var Github_user_ssh_key_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"github_user_ssh_key_id",

		"etag",

		"url",
	)
	rtb.ImmutableAttributes(

		"key",

		"title",
	)
}

// Github_user_ssh_keyHandler ...
type Github_user_ssh_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Github_user_ssh_keyHandler) Create(desired *Github_user_ssh_key) (*Github_user_ssh_key, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Github_user_ssh_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "github_user_ssh_key", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Github_user_ssh_keyHandler) Update(externalID string, desired *Github_user_ssh_key) (*Github_user_ssh_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Github_user_ssh_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "github_user_ssh_key", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Github_user_ssh_key{Github_user_ssh_key_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Github_user_ssh_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Github_user_ssh_keyHandler) Read(externalID string) (*Github_user_ssh_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Github_user_ssh_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "github_user_ssh_key", externalID)
	if err != nil {
		return nil, err
	}
	x := &Github_user_ssh_key{Github_user_ssh_key_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Github_user_ssh_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Github_user_ssh_keyHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Github_user_ssh_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "github_user_ssh_key", externalID)
}
