// Code generated by Lyra DO NOT EDIT.

// This code is generated on a per-provider basis using "tf-gen"
// Long term our hope is to remove this generation step and adopt dynamic approach

package generated

import (
	"sync"

	"github.com/davecgh/go-spew/spew"
	"github.com/hashicorp/go-hclog"
	"github.com/hashicorp/terraform/helper/schema"
	"github.com/hashicorp/terraform/terraform"
	"github.com/lyraproj/terraform-bridge/pkg/bridge"
	"github.com/lyraproj/pcore/px"
	"github.com/lyraproj/servicesdk/service"
)

var once sync.Once
var Config *terraform.ResourceConfig

func configureProvider(p *schema.Provider) {
	once.Do(func() {
		if Config == nil {
			Config = &terraform.ResourceConfig{
				Config: map[string]interface{}{},
			}
		}
		err := p.Configure(Config)
		if err != nil {
			panic(err)
		}
	})
}

func Initialize(sb *service.Builder, p *schema.Provider) {
	var evs []px.Type

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_api_management{}, Azurerm_api_management_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_api_managementHandler", &Azurerm_api_managementHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_app_service{}, Azurerm_app_service_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_app_serviceHandler", &Azurerm_app_serviceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_app_service_active_slot{}, Azurerm_app_service_active_slot_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_app_service_active_slotHandler", &Azurerm_app_service_active_slotHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_app_service_custom_hostname_binding{}, Azurerm_app_service_custom_hostname_binding_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_app_service_custom_hostname_bindingHandler", &Azurerm_app_service_custom_hostname_bindingHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_app_service_plan{}, Azurerm_app_service_plan_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_app_service_planHandler", &Azurerm_app_service_planHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_app_service_slot{}, Azurerm_app_service_slot_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_app_service_slotHandler", &Azurerm_app_service_slotHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_application_gateway{}, Azurerm_application_gateway_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_application_gatewayHandler", &Azurerm_application_gatewayHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_application_insights{}, Azurerm_application_insights_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_application_insightsHandler", &Azurerm_application_insightsHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_application_insights_api_key{}, Azurerm_application_insights_api_key_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_application_insights_api_keyHandler", &Azurerm_application_insights_api_keyHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_application_security_group{}, Azurerm_application_security_group_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_application_security_groupHandler", &Azurerm_application_security_groupHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_automation_account{}, Azurerm_automation_account_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_automation_accountHandler", &Azurerm_automation_accountHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_automation_credential{}, Azurerm_automation_credential_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_automation_credentialHandler", &Azurerm_automation_credentialHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_automation_dsc_configuration{}, Azurerm_automation_dsc_configuration_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_automation_dsc_configurationHandler", &Azurerm_automation_dsc_configurationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_automation_dsc_nodeconfiguration{}, Azurerm_automation_dsc_nodeconfiguration_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_automation_dsc_nodeconfigurationHandler", &Azurerm_automation_dsc_nodeconfigurationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_automation_module{}, Azurerm_automation_module_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_automation_moduleHandler", &Azurerm_automation_moduleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_automation_runbook{}, Azurerm_automation_runbook_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_automation_runbookHandler", &Azurerm_automation_runbookHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_automation_schedule{}, Azurerm_automation_schedule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_automation_scheduleHandler", &Azurerm_automation_scheduleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_autoscale_setting{}, Azurerm_autoscale_setting_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_autoscale_settingHandler", &Azurerm_autoscale_settingHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_availability_set{}, Azurerm_availability_set_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_availability_setHandler", &Azurerm_availability_setHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_azuread_application{}, Azurerm_azuread_application_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_azuread_applicationHandler", &Azurerm_azuread_applicationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_azuread_service_principal{}, Azurerm_azuread_service_principal_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_azuread_service_principalHandler", &Azurerm_azuread_service_principalHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_azuread_service_principal_password{}, Azurerm_azuread_service_principal_password_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_azuread_service_principal_passwordHandler", &Azurerm_azuread_service_principal_passwordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_batch_account{}, Azurerm_batch_account_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_batch_accountHandler", &Azurerm_batch_accountHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_batch_pool{}, Azurerm_batch_pool_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_batch_poolHandler", &Azurerm_batch_poolHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_cdn_endpoint{}, Azurerm_cdn_endpoint_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_cdn_endpointHandler", &Azurerm_cdn_endpointHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_cdn_profile{}, Azurerm_cdn_profile_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_cdn_profileHandler", &Azurerm_cdn_profileHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_cognitive_account{}, Azurerm_cognitive_account_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_cognitive_accountHandler", &Azurerm_cognitive_accountHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_container_group{}, Azurerm_container_group_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_container_groupHandler", &Azurerm_container_groupHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_container_registry{}, Azurerm_container_registry_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_container_registryHandler", &Azurerm_container_registryHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_container_service{}, Azurerm_container_service_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_container_serviceHandler", &Azurerm_container_serviceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_cosmosdb_account{}, Azurerm_cosmosdb_account_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_cosmosdb_accountHandler", &Azurerm_cosmosdb_accountHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_data_lake_analytics_account{}, Azurerm_data_lake_analytics_account_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_data_lake_analytics_accountHandler", &Azurerm_data_lake_analytics_accountHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_data_lake_analytics_firewall_rule{}, Azurerm_data_lake_analytics_firewall_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_data_lake_analytics_firewall_ruleHandler", &Azurerm_data_lake_analytics_firewall_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_data_lake_store{}, Azurerm_data_lake_store_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_data_lake_storeHandler", &Azurerm_data_lake_storeHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_data_lake_store_file{}, Azurerm_data_lake_store_file_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_data_lake_store_fileHandler", &Azurerm_data_lake_store_fileHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_data_lake_store_firewall_rule{}, Azurerm_data_lake_store_firewall_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_data_lake_store_firewall_ruleHandler", &Azurerm_data_lake_store_firewall_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_databricks_workspace{}, Azurerm_databricks_workspace_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_databricks_workspaceHandler", &Azurerm_databricks_workspaceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dev_test_lab{}, Azurerm_dev_test_lab_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dev_test_labHandler", &Azurerm_dev_test_labHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dev_test_linux_virtual_machine{}, Azurerm_dev_test_linux_virtual_machine_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dev_test_linux_virtual_machineHandler", &Azurerm_dev_test_linux_virtual_machineHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dev_test_policy{}, Azurerm_dev_test_policy_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dev_test_policyHandler", &Azurerm_dev_test_policyHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dev_test_virtual_network{}, Azurerm_dev_test_virtual_network_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dev_test_virtual_networkHandler", &Azurerm_dev_test_virtual_networkHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dev_test_windows_virtual_machine{}, Azurerm_dev_test_windows_virtual_machine_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dev_test_windows_virtual_machineHandler", &Azurerm_dev_test_windows_virtual_machineHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_devspace_controller{}, Azurerm_devspace_controller_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_devspace_controllerHandler", &Azurerm_devspace_controllerHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_a_record{}, Azurerm_dns_a_record_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_a_recordHandler", &Azurerm_dns_a_recordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_aaaa_record{}, Azurerm_dns_aaaa_record_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_aaaa_recordHandler", &Azurerm_dns_aaaa_recordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_caa_record{}, Azurerm_dns_caa_record_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_caa_recordHandler", &Azurerm_dns_caa_recordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_cname_record{}, Azurerm_dns_cname_record_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_cname_recordHandler", &Azurerm_dns_cname_recordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_mx_record{}, Azurerm_dns_mx_record_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_mx_recordHandler", &Azurerm_dns_mx_recordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_ns_record{}, Azurerm_dns_ns_record_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_ns_recordHandler", &Azurerm_dns_ns_recordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_ptr_record{}, Azurerm_dns_ptr_record_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_ptr_recordHandler", &Azurerm_dns_ptr_recordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_srv_record{}, Azurerm_dns_srv_record_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_srv_recordHandler", &Azurerm_dns_srv_recordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_txt_record{}, Azurerm_dns_txt_record_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_txt_recordHandler", &Azurerm_dns_txt_recordHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_dns_zone{}, Azurerm_dns_zone_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_dns_zoneHandler", &Azurerm_dns_zoneHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_eventgrid_topic{}, Azurerm_eventgrid_topic_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_eventgrid_topicHandler", &Azurerm_eventgrid_topicHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_eventhub{}, Azurerm_eventhub_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_eventhubHandler", &Azurerm_eventhubHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_eventhub_authorization_rule{}, Azurerm_eventhub_authorization_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_eventhub_authorization_ruleHandler", &Azurerm_eventhub_authorization_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_eventhub_consumer_group{}, Azurerm_eventhub_consumer_group_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_eventhub_consumer_groupHandler", &Azurerm_eventhub_consumer_groupHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_eventhub_namespace{}, Azurerm_eventhub_namespace_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_eventhub_namespaceHandler", &Azurerm_eventhub_namespaceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_eventhub_namespace_authorization_rule{}, Azurerm_eventhub_namespace_authorization_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_eventhub_namespace_authorization_ruleHandler", &Azurerm_eventhub_namespace_authorization_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_express_route_circuit{}, Azurerm_express_route_circuit_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_express_route_circuitHandler", &Azurerm_express_route_circuitHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_express_route_circuit_authorization{}, Azurerm_express_route_circuit_authorization_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_express_route_circuit_authorizationHandler", &Azurerm_express_route_circuit_authorizationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_express_route_circuit_peering{}, Azurerm_express_route_circuit_peering_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_express_route_circuit_peeringHandler", &Azurerm_express_route_circuit_peeringHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_firewall{}, Azurerm_firewall_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_firewallHandler", &Azurerm_firewallHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_firewall_application_rule_collection{}, Azurerm_firewall_application_rule_collection_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_firewall_application_rule_collectionHandler", &Azurerm_firewall_application_rule_collectionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_firewall_network_rule_collection{}, Azurerm_firewall_network_rule_collection_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_firewall_network_rule_collectionHandler", &Azurerm_firewall_network_rule_collectionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_function_app{}, Azurerm_function_app_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_function_appHandler", &Azurerm_function_appHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_image{}, Azurerm_image_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_imageHandler", &Azurerm_imageHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_iothub{}, Azurerm_iothub_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_iothubHandler", &Azurerm_iothubHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_iothub_consumer_group{}, Azurerm_iothub_consumer_group_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_iothub_consumer_groupHandler", &Azurerm_iothub_consumer_groupHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_key_vault{}, Azurerm_key_vault_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_key_vaultHandler", &Azurerm_key_vaultHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_key_vault_access_policy{}, Azurerm_key_vault_access_policy_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_key_vault_access_policyHandler", &Azurerm_key_vault_access_policyHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_key_vault_certificate{}, Azurerm_key_vault_certificate_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_key_vault_certificateHandler", &Azurerm_key_vault_certificateHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_key_vault_key{}, Azurerm_key_vault_key_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_key_vault_keyHandler", &Azurerm_key_vault_keyHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_key_vault_secret{}, Azurerm_key_vault_secret_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_key_vault_secretHandler", &Azurerm_key_vault_secretHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_kubernetes_cluster{}, Azurerm_kubernetes_cluster_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_kubernetes_clusterHandler", &Azurerm_kubernetes_clusterHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_lb{}, Azurerm_lb_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_lbHandler", &Azurerm_lbHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_lb_backend_address_pool{}, Azurerm_lb_backend_address_pool_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_lb_backend_address_poolHandler", &Azurerm_lb_backend_address_poolHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_lb_nat_pool{}, Azurerm_lb_nat_pool_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_lb_nat_poolHandler", &Azurerm_lb_nat_poolHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_lb_nat_rule{}, Azurerm_lb_nat_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_lb_nat_ruleHandler", &Azurerm_lb_nat_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_lb_probe{}, Azurerm_lb_probe_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_lb_probeHandler", &Azurerm_lb_probeHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_lb_rule{}, Azurerm_lb_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_lb_ruleHandler", &Azurerm_lb_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_local_network_gateway{}, Azurerm_local_network_gateway_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_local_network_gatewayHandler", &Azurerm_local_network_gatewayHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_log_analytics_solution{}, Azurerm_log_analytics_solution_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_log_analytics_solutionHandler", &Azurerm_log_analytics_solutionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_log_analytics_workspace{}, Azurerm_log_analytics_workspace_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_log_analytics_workspaceHandler", &Azurerm_log_analytics_workspaceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_log_analytics_workspace_linked_service{}, Azurerm_log_analytics_workspace_linked_service_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_log_analytics_workspace_linked_serviceHandler", &Azurerm_log_analytics_workspace_linked_serviceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_logic_app_action_custom{}, Azurerm_logic_app_action_custom_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_logic_app_action_customHandler", &Azurerm_logic_app_action_customHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_logic_app_action_http{}, Azurerm_logic_app_action_http_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_logic_app_action_httpHandler", &Azurerm_logic_app_action_httpHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_logic_app_trigger_custom{}, Azurerm_logic_app_trigger_custom_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_logic_app_trigger_customHandler", &Azurerm_logic_app_trigger_customHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_logic_app_trigger_http_request{}, Azurerm_logic_app_trigger_http_request_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_logic_app_trigger_http_requestHandler", &Azurerm_logic_app_trigger_http_requestHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_logic_app_trigger_recurrence{}, Azurerm_logic_app_trigger_recurrence_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_logic_app_trigger_recurrenceHandler", &Azurerm_logic_app_trigger_recurrenceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_logic_app_workflow{}, Azurerm_logic_app_workflow_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_logic_app_workflowHandler", &Azurerm_logic_app_workflowHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_managed_disk{}, Azurerm_managed_disk_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_managed_diskHandler", &Azurerm_managed_diskHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_management_group{}, Azurerm_management_group_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_management_groupHandler", &Azurerm_management_groupHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_management_lock{}, Azurerm_management_lock_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_management_lockHandler", &Azurerm_management_lockHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_mariadb_database{}, Azurerm_mariadb_database_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_mariadb_databaseHandler", &Azurerm_mariadb_databaseHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_mariadb_server{}, Azurerm_mariadb_server_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_mariadb_serverHandler", &Azurerm_mariadb_serverHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_metric_alertrule{}, Azurerm_metric_alertrule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_metric_alertruleHandler", &Azurerm_metric_alertruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_monitor_action_group{}, Azurerm_monitor_action_group_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_monitor_action_groupHandler", &Azurerm_monitor_action_groupHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_monitor_activity_log_alert{}, Azurerm_monitor_activity_log_alert_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_monitor_activity_log_alertHandler", &Azurerm_monitor_activity_log_alertHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_monitor_diagnostic_setting{}, Azurerm_monitor_diagnostic_setting_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_monitor_diagnostic_settingHandler", &Azurerm_monitor_diagnostic_settingHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_monitor_log_profile{}, Azurerm_monitor_log_profile_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_monitor_log_profileHandler", &Azurerm_monitor_log_profileHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_monitor_metric_alert{}, Azurerm_monitor_metric_alert_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_monitor_metric_alertHandler", &Azurerm_monitor_metric_alertHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_mssql_elasticpool{}, Azurerm_mssql_elasticpool_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_mssql_elasticpoolHandler", &Azurerm_mssql_elasticpoolHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_mysql_configuration{}, Azurerm_mysql_configuration_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_mysql_configurationHandler", &Azurerm_mysql_configurationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_mysql_database{}, Azurerm_mysql_database_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_mysql_databaseHandler", &Azurerm_mysql_databaseHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_mysql_firewall_rule{}, Azurerm_mysql_firewall_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_mysql_firewall_ruleHandler", &Azurerm_mysql_firewall_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_mysql_server{}, Azurerm_mysql_server_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_mysql_serverHandler", &Azurerm_mysql_serverHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_mysql_virtual_network_rule{}, Azurerm_mysql_virtual_network_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_mysql_virtual_network_ruleHandler", &Azurerm_mysql_virtual_network_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_network_interface{}, Azurerm_network_interface_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_network_interfaceHandler", &Azurerm_network_interfaceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_network_interface_application_gateway_backend_address_pool_association{}, Azurerm_network_interface_application_gateway_backend_address_pool_association_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_network_interface_application_gateway_backend_address_pool_associationHandler", &Azurerm_network_interface_application_gateway_backend_address_pool_associationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_network_interface_backend_address_pool_association{}, Azurerm_network_interface_backend_address_pool_association_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_network_interface_backend_address_pool_associationHandler", &Azurerm_network_interface_backend_address_pool_associationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_network_interface_nat_rule_association{}, Azurerm_network_interface_nat_rule_association_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_network_interface_nat_rule_associationHandler", &Azurerm_network_interface_nat_rule_associationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_network_security_group{}, Azurerm_network_security_group_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_network_security_groupHandler", &Azurerm_network_security_groupHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_network_security_rule{}, Azurerm_network_security_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_network_security_ruleHandler", &Azurerm_network_security_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_network_watcher{}, Azurerm_network_watcher_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_network_watcherHandler", &Azurerm_network_watcherHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_notification_hub{}, Azurerm_notification_hub_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_notification_hubHandler", &Azurerm_notification_hubHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_notification_hub_authorization_rule{}, Azurerm_notification_hub_authorization_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_notification_hub_authorization_ruleHandler", &Azurerm_notification_hub_authorization_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_notification_hub_namespace{}, Azurerm_notification_hub_namespace_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_notification_hub_namespaceHandler", &Azurerm_notification_hub_namespaceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_packet_capture{}, Azurerm_packet_capture_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_packet_captureHandler", &Azurerm_packet_captureHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_policy_assignment{}, Azurerm_policy_assignment_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_policy_assignmentHandler", &Azurerm_policy_assignmentHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_policy_definition{}, Azurerm_policy_definition_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_policy_definitionHandler", &Azurerm_policy_definitionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_policy_set_definition{}, Azurerm_policy_set_definition_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_policy_set_definitionHandler", &Azurerm_policy_set_definitionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_postgresql_configuration{}, Azurerm_postgresql_configuration_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_postgresql_configurationHandler", &Azurerm_postgresql_configurationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_postgresql_database{}, Azurerm_postgresql_database_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_postgresql_databaseHandler", &Azurerm_postgresql_databaseHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_postgresql_firewall_rule{}, Azurerm_postgresql_firewall_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_postgresql_firewall_ruleHandler", &Azurerm_postgresql_firewall_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_postgresql_server{}, Azurerm_postgresql_server_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_postgresql_serverHandler", &Azurerm_postgresql_serverHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_postgresql_virtual_network_rule{}, Azurerm_postgresql_virtual_network_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_postgresql_virtual_network_ruleHandler", &Azurerm_postgresql_virtual_network_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_public_ip{}, Azurerm_public_ip_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_public_ipHandler", &Azurerm_public_ipHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_recovery_services_protected_vm{}, Azurerm_recovery_services_protected_vm_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_recovery_services_protected_vmHandler", &Azurerm_recovery_services_protected_vmHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_recovery_services_protection_policy_vm{}, Azurerm_recovery_services_protection_policy_vm_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_recovery_services_protection_policy_vmHandler", &Azurerm_recovery_services_protection_policy_vmHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_recovery_services_vault{}, Azurerm_recovery_services_vault_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_recovery_services_vaultHandler", &Azurerm_recovery_services_vaultHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_redis_cache{}, Azurerm_redis_cache_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_redis_cacheHandler", &Azurerm_redis_cacheHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_redis_firewall_rule{}, Azurerm_redis_firewall_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_redis_firewall_ruleHandler", &Azurerm_redis_firewall_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_relay_namespace{}, Azurerm_relay_namespace_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_relay_namespaceHandler", &Azurerm_relay_namespaceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_resource_group{}, Azurerm_resource_group_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_resource_groupHandler", &Azurerm_resource_groupHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_role_assignment{}, Azurerm_role_assignment_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_role_assignmentHandler", &Azurerm_role_assignmentHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_role_definition{}, Azurerm_role_definition_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_role_definitionHandler", &Azurerm_role_definitionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_route{}, Azurerm_route_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_routeHandler", &Azurerm_routeHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_route_table{}, Azurerm_route_table_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_route_tableHandler", &Azurerm_route_tableHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_scheduler_job{}, Azurerm_scheduler_job_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_scheduler_jobHandler", &Azurerm_scheduler_jobHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_scheduler_job_collection{}, Azurerm_scheduler_job_collection_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_scheduler_job_collectionHandler", &Azurerm_scheduler_job_collectionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_search_service{}, Azurerm_search_service_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_search_serviceHandler", &Azurerm_search_serviceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_security_center_contact{}, Azurerm_security_center_contact_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_security_center_contactHandler", &Azurerm_security_center_contactHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_security_center_subscription_pricing{}, Azurerm_security_center_subscription_pricing_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_security_center_subscription_pricingHandler", &Azurerm_security_center_subscription_pricingHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_security_center_workspace{}, Azurerm_security_center_workspace_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_security_center_workspaceHandler", &Azurerm_security_center_workspaceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_service_fabric_cluster{}, Azurerm_service_fabric_cluster_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_service_fabric_clusterHandler", &Azurerm_service_fabric_clusterHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_servicebus_namespace{}, Azurerm_servicebus_namespace_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_servicebus_namespaceHandler", &Azurerm_servicebus_namespaceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_servicebus_namespace_authorization_rule{}, Azurerm_servicebus_namespace_authorization_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_servicebus_namespace_authorization_ruleHandler", &Azurerm_servicebus_namespace_authorization_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_servicebus_queue{}, Azurerm_servicebus_queue_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_servicebus_queueHandler", &Azurerm_servicebus_queueHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_servicebus_queue_authorization_rule{}, Azurerm_servicebus_queue_authorization_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_servicebus_queue_authorization_ruleHandler", &Azurerm_servicebus_queue_authorization_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_servicebus_subscription{}, Azurerm_servicebus_subscription_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_servicebus_subscriptionHandler", &Azurerm_servicebus_subscriptionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_servicebus_subscription_rule{}, Azurerm_servicebus_subscription_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_servicebus_subscription_ruleHandler", &Azurerm_servicebus_subscription_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_servicebus_topic{}, Azurerm_servicebus_topic_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_servicebus_topicHandler", &Azurerm_servicebus_topicHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_servicebus_topic_authorization_rule{}, Azurerm_servicebus_topic_authorization_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_servicebus_topic_authorization_ruleHandler", &Azurerm_servicebus_topic_authorization_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_shared_image{}, Azurerm_shared_image_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_shared_imageHandler", &Azurerm_shared_imageHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_shared_image_gallery{}, Azurerm_shared_image_gallery_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_shared_image_galleryHandler", &Azurerm_shared_image_galleryHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_shared_image_version{}, Azurerm_shared_image_version_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_shared_image_versionHandler", &Azurerm_shared_image_versionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_signalr_service{}, Azurerm_signalr_service_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_signalr_serviceHandler", &Azurerm_signalr_serviceHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_snapshot{}, Azurerm_snapshot_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_snapshotHandler", &Azurerm_snapshotHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_sql_active_directory_administrator{}, Azurerm_sql_active_directory_administrator_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_sql_active_directory_administratorHandler", &Azurerm_sql_active_directory_administratorHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_sql_database{}, Azurerm_sql_database_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_sql_databaseHandler", &Azurerm_sql_databaseHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_sql_elasticpool{}, Azurerm_sql_elasticpool_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_sql_elasticpoolHandler", &Azurerm_sql_elasticpoolHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_sql_firewall_rule{}, Azurerm_sql_firewall_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_sql_firewall_ruleHandler", &Azurerm_sql_firewall_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_sql_server{}, Azurerm_sql_server_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_sql_serverHandler", &Azurerm_sql_serverHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_sql_virtual_network_rule{}, Azurerm_sql_virtual_network_rule_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_sql_virtual_network_ruleHandler", &Azurerm_sql_virtual_network_ruleHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_storage_account{}, Azurerm_storage_account_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_storage_accountHandler", &Azurerm_storage_accountHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_storage_blob{}, Azurerm_storage_blob_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_storage_blobHandler", &Azurerm_storage_blobHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_storage_container{}, Azurerm_storage_container_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_storage_containerHandler", &Azurerm_storage_containerHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_storage_queue{}, Azurerm_storage_queue_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_storage_queueHandler", &Azurerm_storage_queueHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_storage_share{}, Azurerm_storage_share_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_storage_shareHandler", &Azurerm_storage_shareHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_storage_table{}, Azurerm_storage_table_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_storage_tableHandler", &Azurerm_storage_tableHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_subnet{}, Azurerm_subnet_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_subnetHandler", &Azurerm_subnetHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_subnet_network_security_group_association{}, Azurerm_subnet_network_security_group_association_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_subnet_network_security_group_associationHandler", &Azurerm_subnet_network_security_group_associationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_subnet_route_table_association{}, Azurerm_subnet_route_table_association_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_subnet_route_table_associationHandler", &Azurerm_subnet_route_table_associationHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_template_deployment{}, Azurerm_template_deployment_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_template_deploymentHandler", &Azurerm_template_deploymentHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_traffic_manager_endpoint{}, Azurerm_traffic_manager_endpoint_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_traffic_manager_endpointHandler", &Azurerm_traffic_manager_endpointHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_traffic_manager_profile{}, Azurerm_traffic_manager_profile_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_traffic_manager_profileHandler", &Azurerm_traffic_manager_profileHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_user_assigned_identity{}, Azurerm_user_assigned_identity_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_user_assigned_identityHandler", &Azurerm_user_assigned_identityHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_virtual_machine{}, Azurerm_virtual_machine_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_virtual_machineHandler", &Azurerm_virtual_machineHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_virtual_machine_data_disk_attachment{}, Azurerm_virtual_machine_data_disk_attachment_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_virtual_machine_data_disk_attachmentHandler", &Azurerm_virtual_machine_data_disk_attachmentHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_virtual_machine_extension{}, Azurerm_virtual_machine_extension_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_virtual_machine_extensionHandler", &Azurerm_virtual_machine_extensionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_virtual_machine_scale_set{}, Azurerm_virtual_machine_scale_set_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_virtual_machine_scale_setHandler", &Azurerm_virtual_machine_scale_setHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_virtual_network{}, Azurerm_virtual_network_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_virtual_networkHandler", &Azurerm_virtual_networkHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_virtual_network_gateway{}, Azurerm_virtual_network_gateway_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_virtual_network_gatewayHandler", &Azurerm_virtual_network_gatewayHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_virtual_network_gateway_connection{}, Azurerm_virtual_network_gateway_connection_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_virtual_network_gateway_connectionHandler", &Azurerm_virtual_network_gateway_connectionHandler{provider: p}, evs[0])

	evs = sb.RegisterTypes("TerraformAzureRM", sb.BuildResource(&Azurerm_virtual_network_peering{}, Azurerm_virtual_network_peering_rtb))
	sb.RegisterHandler("TerraformAzureRM::Azurerm_virtual_network_peeringHandler", &Azurerm_virtual_network_peeringHandler{provider: p}, evs[0])

}

type Azurerm_api_management_additional_location_1 struct {
	Gateway_regional_url *string

	Location string

	Public_ip_addresses *[]string
}

type Azurerm_api_management_certificate_2 struct {
	Certificate_password string

	Encoded_certificate string

	Store_name string
}

type Azurerm_api_management_hostname_configuration_3_management_4 struct {
	Certificate *string

	Certificate_password *string

	Host_name string

	Key_vault_id *string

	Negotiate_client_certificate *bool
}

type Azurerm_api_management_hostname_configuration_3_portal_5 struct {
	Certificate *string

	Certificate_password *string

	Host_name string

	Key_vault_id *string

	Negotiate_client_certificate *bool
}

type Azurerm_api_management_hostname_configuration_3_proxy_6 struct {
	Certificate *string

	Certificate_password *string

	Default_ssl_binding *bool

	Host_name string

	Key_vault_id *string

	Negotiate_client_certificate *bool
}

type Azurerm_api_management_hostname_configuration_3_scm_7 struct {
	Certificate *string

	Certificate_password *string

	Host_name string

	Key_vault_id *string

	Negotiate_client_certificate *bool
}

type Azurerm_api_management_hostname_configuration_3 struct {
	Management *[]Azurerm_api_management_hostname_configuration_3_management_4

	Portal *[]Azurerm_api_management_hostname_configuration_3_portal_5

	Proxy *[]Azurerm_api_management_hostname_configuration_3_proxy_6

	Scm *[]Azurerm_api_management_hostname_configuration_3_scm_7
}

type Azurerm_api_management_identity_8 struct {
	Principal_id *string

	Tenant_id *string

	Type string
}

type Azurerm_api_management_security_9 struct {
	Disable_backend_ssl30 *bool

	Disable_backend_tls10 *bool

	Disable_backend_tls11 *bool

	Disable_frontend_ssl30 *bool

	Disable_frontend_tls10 *bool

	Disable_frontend_tls11 *bool

	Disable_triple_des_chipers *bool
}

type Azurerm_api_management_sku_10 struct {
	Capacity int

	Name string
}

type Azurerm_api_management struct {
	Azurerm_api_management_id *string `lyra:"ignore"`

	Additional_location *[]Azurerm_api_management_additional_location_1

	Certificate *[]Azurerm_api_management_certificate_2

	Gateway_regional_url *string

	Gateway_url *string

	Hostname_configuration *[]Azurerm_api_management_hostname_configuration_3

	Identity *[]Azurerm_api_management_identity_8

	Location string

	Management_api_url *string

	Name string

	Notification_sender_email *string

	Portal_url *string

	Public_ip_addresses *[]string

	Publisher_email string

	Publisher_name string

	Resource_group_name string

	Scm_url *string

	Security *[]Azurerm_api_management_security_9

	Sku []Azurerm_api_management_sku_10

	Tags *map[string]string
}

var Azurerm_api_management_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_api_management_id",

		"additional_location",

		"certificate",

		"gateway_regional_url",

		"gateway_url",

		"hostname_configuration",

		"identity",

		"management_api_url",

		"notification_sender_email",

		"portal_url",

		"public_ip_addresses",

		"scm_url",

		"security",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_api_managementHandler ...
type Azurerm_api_managementHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_api_managementHandler) Create(desired *Azurerm_api_management) (*Azurerm_api_management, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_api_management", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_api_management", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_api_managementHandler) Update(externalID string, desired *Azurerm_api_management) (*Azurerm_api_management, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_api_management", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_api_management", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_api_management{Azurerm_api_management_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_api_management", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_api_managementHandler) Read(externalID string) (*Azurerm_api_management, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_api_management", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_api_management", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_api_management{Azurerm_api_management_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_api_management", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_api_managementHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_api_management", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_api_management", externalID)
}

type Azurerm_app_service_connection_string_11 struct {
	Name string

	Type string

	Value string
}

type Azurerm_app_service_identity_12 struct {
	Principal_id *string

	Tenant_id *string

	Type string
}

type Azurerm_app_service_site_config_13_ip_restriction_14 struct {
	Ip_address string

	Subnet_mask *string
}

type Azurerm_app_service_site_config_13 struct {
	Always_on *bool

	App_command_line *string

	Default_documents *[]string

	Dotnet_framework_version *string

	Ftps_state *string

	Http2_enabled *bool

	Ip_restriction *[]Azurerm_app_service_site_config_13_ip_restriction_14

	Java_container *string

	Java_container_version *string

	Java_version *string

	Linux_fx_version *string

	Local_mysql_enabled *bool

	Managed_pipeline_mode *string

	Min_tls_version *string

	Php_version *string

	Python_version *string

	Remote_debugging_enabled *bool

	Remote_debugging_version *string

	Scm_type *string

	Use_32_bit_worker_process *bool

	Virtual_network_name *string

	Websockets_enabled *bool
}

type Azurerm_app_service_site_credential_15 struct {
	Password *string

	Username *string
}

type Azurerm_app_service_source_control_16 struct {
	Branch *string

	Repo_url *string
}

type Azurerm_app_service struct {
	Azurerm_app_service_id *string `lyra:"ignore"`

	App_service_plan_id string

	App_settings *map[string]string

	Client_affinity_enabled *bool

	Connection_string *[]Azurerm_app_service_connection_string_11

	Default_site_hostname *string

	Enabled *bool

	Https_only *bool

	Identity *[]Azurerm_app_service_identity_12

	Location string

	Name string

	Outbound_ip_addresses *string

	Possible_outbound_ip_addresses *string

	Resource_group_name string

	Site_config *[]Azurerm_app_service_site_config_13

	Site_credential *[]Azurerm_app_service_site_credential_15

	Source_control *[]Azurerm_app_service_source_control_16

	Tags *map[string]string
}

var Azurerm_app_service_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_app_service_id",

		"app_settings",

		"client_affinity_enabled",

		"connection_string",

		"default_site_hostname",

		"enabled",

		"https_only",

		"identity",

		"outbound_ip_addresses",

		"possible_outbound_ip_addresses",

		"site_config",

		"site_credential",

		"source_control",

		"tags",
	)
	rtb.ImmutableAttributes(

		"app_service_plan_id",

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_app_serviceHandler ...
type Azurerm_app_serviceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_app_serviceHandler) Create(desired *Azurerm_app_service) (*Azurerm_app_service, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_app_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_app_service", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_app_serviceHandler) Update(externalID string, desired *Azurerm_app_service) (*Azurerm_app_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_app_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_app_service", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service{Azurerm_app_service_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_app_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_app_serviceHandler) Read(externalID string) (*Azurerm_app_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_app_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_app_service", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service{Azurerm_app_service_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_app_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_app_serviceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_app_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_app_service", externalID)
}

type Azurerm_app_service_active_slot struct {
	Azurerm_app_service_active_slot_id *string `lyra:"ignore"`

	App_service_name string

	App_service_slot_name string

	Resource_group_name string
}

var Azurerm_app_service_active_slot_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_app_service_active_slot_id",
	)
	rtb.ImmutableAttributes(

		"app_service_name",

		"resource_group_name",
	)
}

// Azurerm_app_service_active_slotHandler ...
type Azurerm_app_service_active_slotHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_app_service_active_slotHandler) Create(desired *Azurerm_app_service_active_slot) (*Azurerm_app_service_active_slot, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_app_service_active_slot", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_app_service_active_slot", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_app_service_active_slotHandler) Update(externalID string, desired *Azurerm_app_service_active_slot) (*Azurerm_app_service_active_slot, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_app_service_active_slot", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_app_service_active_slot", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service_active_slot{Azurerm_app_service_active_slot_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_app_service_active_slot", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_app_service_active_slotHandler) Read(externalID string) (*Azurerm_app_service_active_slot, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_app_service_active_slot", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_app_service_active_slot", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service_active_slot{Azurerm_app_service_active_slot_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_app_service_active_slot", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_app_service_active_slotHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_app_service_active_slot", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_app_service_active_slot", externalID)
}

type Azurerm_app_service_custom_hostname_binding struct {
	Azurerm_app_service_custom_hostname_binding_id *string `lyra:"ignore"`

	App_service_name string

	Hostname string

	Resource_group_name string
}

var Azurerm_app_service_custom_hostname_binding_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_app_service_custom_hostname_binding_id",
	)
	rtb.ImmutableAttributes(

		"app_service_name",

		"hostname",

		"resource_group_name",
	)
}

// Azurerm_app_service_custom_hostname_bindingHandler ...
type Azurerm_app_service_custom_hostname_bindingHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_app_service_custom_hostname_bindingHandler) Create(desired *Azurerm_app_service_custom_hostname_binding) (*Azurerm_app_service_custom_hostname_binding, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_app_service_custom_hostname_binding", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_app_service_custom_hostname_binding", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_app_service_custom_hostname_bindingHandler) Update(externalID string, desired *Azurerm_app_service_custom_hostname_binding) (*Azurerm_app_service_custom_hostname_binding, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_app_service_custom_hostname_binding", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_app_service_custom_hostname_binding", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service_custom_hostname_binding{Azurerm_app_service_custom_hostname_binding_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_app_service_custom_hostname_binding", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_app_service_custom_hostname_bindingHandler) Read(externalID string) (*Azurerm_app_service_custom_hostname_binding, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_app_service_custom_hostname_binding", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_app_service_custom_hostname_binding", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service_custom_hostname_binding{Azurerm_app_service_custom_hostname_binding_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_app_service_custom_hostname_binding", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_app_service_custom_hostname_bindingHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_app_service_custom_hostname_binding", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_app_service_custom_hostname_binding", externalID)
}

type Azurerm_app_service_plan_properties_17 struct {
	App_service_environment_id *string

	Per_site_scaling *bool

	Reserved *bool
}

type Azurerm_app_service_plan_sku_18 struct {
	Capacity *int

	Size string

	Tier string
}

type Azurerm_app_service_plan struct {
	Azurerm_app_service_plan_id *string `lyra:"ignore"`

	App_service_environment_id *string

	Kind *string

	Location string

	Maximum_number_of_workers *int

	Name string

	Per_site_scaling *bool

	Properties *[]Azurerm_app_service_plan_properties_17

	Reserved *bool

	Resource_group_name string

	Sku []Azurerm_app_service_plan_sku_18

	Tags *map[string]string
}

var Azurerm_app_service_plan_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_app_service_plan_id",

		"app_service_environment_id",

		"kind",

		"maximum_number_of_workers",

		"per_site_scaling",

		"properties",

		"reserved",

		"tags",
	)
	rtb.ImmutableAttributes(

		"app_service_environment_id",

		"kind",

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_app_service_planHandler ...
type Azurerm_app_service_planHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_app_service_planHandler) Create(desired *Azurerm_app_service_plan) (*Azurerm_app_service_plan, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_app_service_plan", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_app_service_plan", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_app_service_planHandler) Update(externalID string, desired *Azurerm_app_service_plan) (*Azurerm_app_service_plan, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_app_service_plan", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_app_service_plan", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service_plan{Azurerm_app_service_plan_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_app_service_plan", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_app_service_planHandler) Read(externalID string) (*Azurerm_app_service_plan, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_app_service_plan", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_app_service_plan", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service_plan{Azurerm_app_service_plan_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_app_service_plan", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_app_service_planHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_app_service_plan", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_app_service_plan", externalID)
}

type Azurerm_app_service_slot_connection_string_19 struct {
	Name string

	Type string

	Value string
}

type Azurerm_app_service_slot_identity_20 struct {
	Principal_id *string

	Tenant_id *string

	Type string
}

type Azurerm_app_service_slot_site_config_21_ip_restriction_22 struct {
	Ip_address string

	Subnet_mask *string
}

type Azurerm_app_service_slot_site_config_21 struct {
	Always_on *bool

	App_command_line *string

	Default_documents *[]string

	Dotnet_framework_version *string

	Ftps_state *string

	Http2_enabled *bool

	Ip_restriction *[]Azurerm_app_service_slot_site_config_21_ip_restriction_22

	Java_container *string

	Java_container_version *string

	Java_version *string

	Linux_fx_version *string

	Local_mysql_enabled *bool

	Managed_pipeline_mode *string

	Min_tls_version *string

	Php_version *string

	Python_version *string

	Remote_debugging_enabled *bool

	Remote_debugging_version *string

	Scm_type *string

	Use_32_bit_worker_process *bool

	Virtual_network_name *string

	Websockets_enabled *bool
}

type Azurerm_app_service_slot struct {
	Azurerm_app_service_slot_id *string `lyra:"ignore"`

	App_service_name string

	App_service_plan_id string

	App_settings *map[string]string

	Client_affinity_enabled *bool

	Connection_string *[]Azurerm_app_service_slot_connection_string_19

	Default_site_hostname *string

	Enabled *bool

	Https_only *bool

	Identity *[]Azurerm_app_service_slot_identity_20

	Location string

	Name string

	Resource_group_name string

	Site_config *[]Azurerm_app_service_slot_site_config_21

	Tags *map[string]string
}

var Azurerm_app_service_slot_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_app_service_slot_id",

		"app_settings",

		"client_affinity_enabled",

		"connection_string",

		"default_site_hostname",

		"enabled",

		"https_only",

		"identity",

		"site_config",

		"tags",
	)
	rtb.ImmutableAttributes(

		"app_service_name",

		"app_service_plan_id",

		"identity",

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_app_service_slotHandler ...
type Azurerm_app_service_slotHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_app_service_slotHandler) Create(desired *Azurerm_app_service_slot) (*Azurerm_app_service_slot, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_app_service_slot", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_app_service_slot", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_app_service_slotHandler) Update(externalID string, desired *Azurerm_app_service_slot) (*Azurerm_app_service_slot, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_app_service_slot", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_app_service_slot", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service_slot{Azurerm_app_service_slot_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_app_service_slot", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_app_service_slotHandler) Read(externalID string) (*Azurerm_app_service_slot, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_app_service_slot", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_app_service_slot", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_app_service_slot{Azurerm_app_service_slot_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_app_service_slot", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_app_service_slotHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_app_service_slot", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_app_service_slot", externalID)
}

type Azurerm_application_gateway_authentication_certificate_23 struct {
	Data string

	Id *string

	Name string
}

type Azurerm_application_gateway_backend_address_pool_24 struct {
	Fqdn_list *[]string

	Id *string

	Ip_address_list *[]string

	Name string
}

type Azurerm_application_gateway_backend_http_settings_25_authentication_certificate_26 struct {
	Id *string

	Name string
}

type Azurerm_application_gateway_backend_http_settings_25 struct {
	Authentication_certificate *[]Azurerm_application_gateway_backend_http_settings_25_authentication_certificate_26

	Cookie_based_affinity string

	Id *string

	Name string

	Port int

	Probe_id *string

	Probe_name *string

	Protocol string

	Request_timeout *int
}

type Azurerm_application_gateway_frontend_ip_configuration_27 struct {
	Id *string

	Name string

	Private_ip_address *string

	Private_ip_address_allocation *string

	Public_ip_address_id *string

	Subnet_id *string
}

type Azurerm_application_gateway_frontend_port_28 struct {
	Id *string

	Name string

	Port int
}

type Azurerm_application_gateway_gateway_ip_configuration_29 struct {
	Id *string

	Name string

	Subnet_id string
}

type Azurerm_application_gateway_http_listener_30 struct {
	Frontend_ip_configuration_id *string

	Frontend_ip_configuration_name string

	Frontend_port_id *string

	Frontend_port_name string

	Host_name *string

	Id *string

	Name string

	Protocol string

	Require_sni *bool

	Ssl_certificate_id *string

	Ssl_certificate_name *string
}

type Azurerm_application_gateway_probe_31_match_32 struct {
	Body *string

	Status_code *[]string
}

type Azurerm_application_gateway_probe_31 struct {
	Host string

	Id *string

	Interval int

	Match *[]Azurerm_application_gateway_probe_31_match_32

	Minimum_servers *int

	Name string

	Path string

	Protocol string

	Timeout int

	Unhealthy_threshold int
}

type Azurerm_application_gateway_request_routing_rule_33 struct {
	Backend_address_pool_id *string

	Backend_address_pool_name *string

	Backend_http_settings_id *string

	Backend_http_settings_name *string

	Http_listener_id *string

	Http_listener_name string

	Id *string

	Name string

	Rule_type string

	Url_path_map_id *string

	Url_path_map_name *string
}

type Azurerm_application_gateway_sku_34 struct {
	Capacity int

	Name string

	Tier string
}

type Azurerm_application_gateway_ssl_certificate_35 struct {
	Data string

	Id *string

	Name string

	Password string

	Public_cert_data *string
}

type Azurerm_application_gateway_url_path_map_36_path_rule_37 struct {
	Backend_address_pool_id *string

	Backend_address_pool_name string

	Backend_http_settings_id *string

	Backend_http_settings_name string

	Id *string

	Name string

	Paths []string
}

type Azurerm_application_gateway_url_path_map_36 struct {
	Default_backend_address_pool_id *string

	Default_backend_address_pool_name string

	Default_backend_http_settings_id *string

	Default_backend_http_settings_name string

	Id *string

	Name string

	Path_rule []Azurerm_application_gateway_url_path_map_36_path_rule_37
}

type Azurerm_application_gateway_waf_configuration_38 struct {
	Enabled bool

	Firewall_mode string

	Rule_set_type *string

	Rule_set_version string
}

type Azurerm_application_gateway struct {
	Azurerm_application_gateway_id *string `lyra:"ignore"`

	Authentication_certificate *[]Azurerm_application_gateway_authentication_certificate_23

	Backend_address_pool []Azurerm_application_gateway_backend_address_pool_24

	Backend_http_settings []Azurerm_application_gateway_backend_http_settings_25

	Disabled_ssl_protocols *[]string

	Frontend_ip_configuration []Azurerm_application_gateway_frontend_ip_configuration_27

	Frontend_port []Azurerm_application_gateway_frontend_port_28

	Gateway_ip_configuration []Azurerm_application_gateway_gateway_ip_configuration_29

	Http_listener []Azurerm_application_gateway_http_listener_30

	Location string

	Name string

	Probe *[]Azurerm_application_gateway_probe_31

	Request_routing_rule []Azurerm_application_gateway_request_routing_rule_33

	Resource_group_name string

	Sku []Azurerm_application_gateway_sku_34

	Ssl_certificate *[]Azurerm_application_gateway_ssl_certificate_35

	Tags *map[string]string

	Url_path_map *[]Azurerm_application_gateway_url_path_map_36

	Waf_configuration *[]Azurerm_application_gateway_waf_configuration_38
}

var Azurerm_application_gateway_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_application_gateway_id",

		"authentication_certificate",

		"disabled_ssl_protocols",

		"probe",

		"ssl_certificate",

		"tags",

		"url_path_map",

		"waf_configuration",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_application_gatewayHandler ...
type Azurerm_application_gatewayHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_application_gatewayHandler) Create(desired *Azurerm_application_gateway) (*Azurerm_application_gateway, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_application_gateway", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_application_gateway", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_application_gatewayHandler) Update(externalID string, desired *Azurerm_application_gateway) (*Azurerm_application_gateway, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_application_gateway", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_application_gateway", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_application_gateway{Azurerm_application_gateway_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_application_gateway", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_application_gatewayHandler) Read(externalID string) (*Azurerm_application_gateway, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_application_gateway", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_application_gateway", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_application_gateway{Azurerm_application_gateway_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_application_gateway", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_application_gatewayHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_application_gateway", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_application_gateway", externalID)
}

type Azurerm_application_insights struct {
	Azurerm_application_insights_id *string `lyra:"ignore"`

	App_id *string

	Application_type string

	Instrumentation_key *string

	Location string

	Name string

	Resource_group_name string

	Tags *map[string]string
}

var Azurerm_application_insights_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_application_insights_id",

		"app_id",

		"instrumentation_key",

		"tags",
	)
	rtb.ImmutableAttributes(

		"application_type",

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_application_insightsHandler ...
type Azurerm_application_insightsHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_application_insightsHandler) Create(desired *Azurerm_application_insights) (*Azurerm_application_insights, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_application_insights", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_application_insights", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_application_insightsHandler) Update(externalID string, desired *Azurerm_application_insights) (*Azurerm_application_insights, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_application_insights", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_application_insights", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_application_insights{Azurerm_application_insights_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_application_insights", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_application_insightsHandler) Read(externalID string) (*Azurerm_application_insights, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_application_insights", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_application_insights", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_application_insights{Azurerm_application_insights_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_application_insights", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_application_insightsHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_application_insights", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_application_insights", externalID)
}

type Azurerm_application_insights_api_key struct {
	Azurerm_application_insights_api_key_id *string `lyra:"ignore"`

	Api_key *string

	Application_insights_id string

	Name string

	Read_permissions *[]string

	Write_permissions *[]string
}

var Azurerm_application_insights_api_key_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_application_insights_api_key_id",

		"api_key",

		"read_permissions",

		"write_permissions",
	)
	rtb.ImmutableAttributes(

		"application_insights_id",

		"name",

		"read_permissions",

		"write_permissions",
	)
}

// Azurerm_application_insights_api_keyHandler ...
type Azurerm_application_insights_api_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_application_insights_api_keyHandler) Create(desired *Azurerm_application_insights_api_key) (*Azurerm_application_insights_api_key, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_application_insights_api_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_application_insights_api_key", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_application_insights_api_keyHandler) Update(externalID string, desired *Azurerm_application_insights_api_key) (*Azurerm_application_insights_api_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_application_insights_api_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_application_insights_api_key", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_application_insights_api_key{Azurerm_application_insights_api_key_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_application_insights_api_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_application_insights_api_keyHandler) Read(externalID string) (*Azurerm_application_insights_api_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_application_insights_api_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_application_insights_api_key", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_application_insights_api_key{Azurerm_application_insights_api_key_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_application_insights_api_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_application_insights_api_keyHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_application_insights_api_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_application_insights_api_key", externalID)
}

type Azurerm_application_security_group struct {
	Azurerm_application_security_group_id *string `lyra:"ignore"`

	Location string

	Name string

	Resource_group_name string

	Tags *map[string]string
}

var Azurerm_application_security_group_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_application_security_group_id",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_application_security_groupHandler ...
type Azurerm_application_security_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_application_security_groupHandler) Create(desired *Azurerm_application_security_group) (*Azurerm_application_security_group, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_application_security_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_application_security_group", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_application_security_groupHandler) Update(externalID string, desired *Azurerm_application_security_group) (*Azurerm_application_security_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_application_security_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_application_security_group", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_application_security_group{Azurerm_application_security_group_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_application_security_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_application_security_groupHandler) Read(externalID string) (*Azurerm_application_security_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_application_security_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_application_security_group", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_application_security_group{Azurerm_application_security_group_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_application_security_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_application_security_groupHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_application_security_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_application_security_group", externalID)
}

type Azurerm_automation_account_sku_39 struct {
	Name *string
}

type Azurerm_automation_account struct {
	Azurerm_automation_account_id *string `lyra:"ignore"`

	Dsc_primary_access_key *string

	Dsc_secondary_access_key *string

	Dsc_server_endpoint *string

	Location string

	Name string

	Resource_group_name string

	Sku []Azurerm_automation_account_sku_39

	Tags *map[string]string
}

var Azurerm_automation_account_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_automation_account_id",

		"dsc_primary_access_key",

		"dsc_secondary_access_key",

		"dsc_server_endpoint",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_automation_accountHandler ...
type Azurerm_automation_accountHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_automation_accountHandler) Create(desired *Azurerm_automation_account) (*Azurerm_automation_account, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_automation_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_automation_account", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_automation_accountHandler) Update(externalID string, desired *Azurerm_automation_account) (*Azurerm_automation_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_automation_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_automation_account", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_account{Azurerm_automation_account_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_automation_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_automation_accountHandler) Read(externalID string) (*Azurerm_automation_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_automation_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_automation_account", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_account{Azurerm_automation_account_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_automation_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_automation_accountHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_automation_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_automation_account", externalID)
}

type Azurerm_automation_credential struct {
	Azurerm_automation_credential_id *string `lyra:"ignore"`

	Account_name string

	Description *string

	Name string

	Password string

	Resource_group_name string

	Username string
}

var Azurerm_automation_credential_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_automation_credential_id",

		"description",
	)
	rtb.ImmutableAttributes(

		"account_name",

		"name",

		"resource_group_name",
	)
}

// Azurerm_automation_credentialHandler ...
type Azurerm_automation_credentialHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_automation_credentialHandler) Create(desired *Azurerm_automation_credential) (*Azurerm_automation_credential, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_automation_credential", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_automation_credential", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_automation_credentialHandler) Update(externalID string, desired *Azurerm_automation_credential) (*Azurerm_automation_credential, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_automation_credential", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_automation_credential", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_credential{Azurerm_automation_credential_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_automation_credential", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_automation_credentialHandler) Read(externalID string) (*Azurerm_automation_credential, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_automation_credential", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_automation_credential", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_credential{Azurerm_automation_credential_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_automation_credential", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_automation_credentialHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_automation_credential", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_automation_credential", externalID)
}

type Azurerm_automation_dsc_configuration struct {
	Azurerm_automation_dsc_configuration_id *string `lyra:"ignore"`

	Automation_account_name string

	Content_embedded string

	Description *string

	Location string

	Log_verbose *bool

	Name string

	Resource_group_name string

	State *string
}

var Azurerm_automation_dsc_configuration_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_automation_dsc_configuration_id",

		"description",

		"log_verbose",

		"state",
	)
	rtb.ImmutableAttributes(

		"automation_account_name",

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_automation_dsc_configurationHandler ...
type Azurerm_automation_dsc_configurationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_automation_dsc_configurationHandler) Create(desired *Azurerm_automation_dsc_configuration) (*Azurerm_automation_dsc_configuration, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_automation_dsc_configuration", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_automation_dsc_configuration", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_automation_dsc_configurationHandler) Update(externalID string, desired *Azurerm_automation_dsc_configuration) (*Azurerm_automation_dsc_configuration, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_automation_dsc_configuration", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_automation_dsc_configuration", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_dsc_configuration{Azurerm_automation_dsc_configuration_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_automation_dsc_configuration", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_automation_dsc_configurationHandler) Read(externalID string) (*Azurerm_automation_dsc_configuration, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_automation_dsc_configuration", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_automation_dsc_configuration", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_dsc_configuration{Azurerm_automation_dsc_configuration_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_automation_dsc_configuration", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_automation_dsc_configurationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_automation_dsc_configuration", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_automation_dsc_configuration", externalID)
}

type Azurerm_automation_dsc_nodeconfiguration struct {
	Azurerm_automation_dsc_nodeconfiguration_id *string `lyra:"ignore"`

	Automation_account_name string

	Configuration_name *string

	Content_embedded string

	Name string

	Resource_group_name string
}

var Azurerm_automation_dsc_nodeconfiguration_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_automation_dsc_nodeconfiguration_id",

		"configuration_name",
	)
	rtb.ImmutableAttributes(

		"automation_account_name",

		"name",

		"resource_group_name",
	)
}

// Azurerm_automation_dsc_nodeconfigurationHandler ...
type Azurerm_automation_dsc_nodeconfigurationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_automation_dsc_nodeconfigurationHandler) Create(desired *Azurerm_automation_dsc_nodeconfiguration) (*Azurerm_automation_dsc_nodeconfiguration, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_automation_dsc_nodeconfiguration", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_automation_dsc_nodeconfiguration", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_automation_dsc_nodeconfigurationHandler) Update(externalID string, desired *Azurerm_automation_dsc_nodeconfiguration) (*Azurerm_automation_dsc_nodeconfiguration, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_automation_dsc_nodeconfiguration", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_automation_dsc_nodeconfiguration", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_dsc_nodeconfiguration{Azurerm_automation_dsc_nodeconfiguration_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_automation_dsc_nodeconfiguration", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_automation_dsc_nodeconfigurationHandler) Read(externalID string) (*Azurerm_automation_dsc_nodeconfiguration, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_automation_dsc_nodeconfiguration", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_automation_dsc_nodeconfiguration", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_dsc_nodeconfiguration{Azurerm_automation_dsc_nodeconfiguration_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_automation_dsc_nodeconfiguration", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_automation_dsc_nodeconfigurationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_automation_dsc_nodeconfiguration", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_automation_dsc_nodeconfiguration", externalID)
}

type Azurerm_automation_module_module_link_40_hash_41 struct {
	Algorithm string

	Value string
}

type Azurerm_automation_module_module_link_40 struct {
	Hash *[]Azurerm_automation_module_module_link_40_hash_41

	Uri string
}

type Azurerm_automation_module struct {
	Azurerm_automation_module_id *string `lyra:"ignore"`

	Automation_account_name string

	Module_link []Azurerm_automation_module_module_link_40

	Name string

	Resource_group_name string
}

var Azurerm_automation_module_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_automation_module_id",
	)
	rtb.ImmutableAttributes(

		"automation_account_name",

		"name",

		"resource_group_name",
	)
}

// Azurerm_automation_moduleHandler ...
type Azurerm_automation_moduleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_automation_moduleHandler) Create(desired *Azurerm_automation_module) (*Azurerm_automation_module, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_automation_module", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_automation_module", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_automation_moduleHandler) Update(externalID string, desired *Azurerm_automation_module) (*Azurerm_automation_module, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_automation_module", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_automation_module", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_module{Azurerm_automation_module_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_automation_module", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_automation_moduleHandler) Read(externalID string) (*Azurerm_automation_module, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_automation_module", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_automation_module", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_module{Azurerm_automation_module_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_automation_module", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_automation_moduleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_automation_module", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_automation_module", externalID)
}

type Azurerm_automation_runbook_publish_content_link_42_hash_43 struct {
	Algorithm string

	Value string
}

type Azurerm_automation_runbook_publish_content_link_42 struct {
	Hash *[]Azurerm_automation_runbook_publish_content_link_42_hash_43

	Uri string

	Version *string
}

type Azurerm_automation_runbook struct {
	Azurerm_automation_runbook_id *string `lyra:"ignore"`

	Account_name string

	Content *string

	Description *string

	Location string

	Log_progress bool

	Log_verbose bool

	Name string

	Publish_content_link []Azurerm_automation_runbook_publish_content_link_42

	Resource_group_name string

	Runbook_type string

	Tags *map[string]string
}

var Azurerm_automation_runbook_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_automation_runbook_id",

		"content",

		"description",

		"tags",
	)
	rtb.ImmutableAttributes(

		"account_name",

		"location",

		"name",

		"resource_group_name",

		"runbook_type",
	)
}

// Azurerm_automation_runbookHandler ...
type Azurerm_automation_runbookHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_automation_runbookHandler) Create(desired *Azurerm_automation_runbook) (*Azurerm_automation_runbook, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_automation_runbook", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_automation_runbook", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_automation_runbookHandler) Update(externalID string, desired *Azurerm_automation_runbook) (*Azurerm_automation_runbook, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_automation_runbook", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_automation_runbook", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_runbook{Azurerm_automation_runbook_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_automation_runbook", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_automation_runbookHandler) Read(externalID string) (*Azurerm_automation_runbook, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_automation_runbook", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_automation_runbook", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_runbook{Azurerm_automation_runbook_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_automation_runbook", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_automation_runbookHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_automation_runbook", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_automation_runbook", externalID)
}

type Azurerm_automation_schedule_monthly_occurrence_44 struct {
	Day string

	Occurrence int
}

type Azurerm_automation_schedule struct {
	Azurerm_automation_schedule_id *string `lyra:"ignore"`

	Account_name *string

	Automation_account_name *string

	Description *string

	Expiry_time *string

	Frequency string

	Interval *int

	Month_days *[]int

	Monthly_occurrence *[]Azurerm_automation_schedule_monthly_occurrence_44

	Name string

	Resource_group_name string

	Start_time *string

	Timezone *string

	Week_days *[]string
}

var Azurerm_automation_schedule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_automation_schedule_id",

		"account_name",

		"automation_account_name",

		"description",

		"expiry_time",

		"interval",

		"month_days",

		"monthly_occurrence",

		"start_time",

		"timezone",

		"week_days",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",
	)
}

// Azurerm_automation_scheduleHandler ...
type Azurerm_automation_scheduleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_automation_scheduleHandler) Create(desired *Azurerm_automation_schedule) (*Azurerm_automation_schedule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_automation_schedule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_automation_schedule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_automation_scheduleHandler) Update(externalID string, desired *Azurerm_automation_schedule) (*Azurerm_automation_schedule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_automation_schedule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_automation_schedule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_schedule{Azurerm_automation_schedule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_automation_schedule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_automation_scheduleHandler) Read(externalID string) (*Azurerm_automation_schedule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_automation_schedule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_automation_schedule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_automation_schedule{Azurerm_automation_schedule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_automation_schedule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_automation_scheduleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_automation_schedule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_automation_schedule", externalID)
}

type Azurerm_autoscale_setting_notification_45_email_46 struct {
	Custom_emails *[]string

	Send_to_subscription_administrator *bool

	Send_to_subscription_co_administrator *bool
}

type Azurerm_autoscale_setting_notification_45_webhook_47 struct {
	Properties *map[string]string

	Service_uri string
}

type Azurerm_autoscale_setting_notification_45 struct {
	Email *[]Azurerm_autoscale_setting_notification_45_email_46

	Webhook *[]Azurerm_autoscale_setting_notification_45_webhook_47
}

type Azurerm_autoscale_setting_profile_48_capacity_49 struct {
	Default int

	Maximum int

	Minimum int
}

type Azurerm_autoscale_setting_profile_48_fixed_date_50 struct {
	End string

	Start string

	Timezone *string
}

type Azurerm_autoscale_setting_profile_48_recurrence_51 struct {
	Days []string

	Hours []int

	Minutes []int

	Timezone *string
}

type Azurerm_autoscale_setting_profile_48_rule_52_metric_trigger_53 struct {
	Metric_name string

	Metric_resource_id string

	Operator string

	Statistic string

	Threshold float64

	Time_aggregation string

	Time_grain string

	Time_window string
}

type Azurerm_autoscale_setting_profile_48_rule_52_scale_action_54 struct {
	Cooldown string

	Direction string

	Type string

	Value int
}

type Azurerm_autoscale_setting_profile_48_rule_52 struct {
	Metric_trigger []Azurerm_autoscale_setting_profile_48_rule_52_metric_trigger_53

	Scale_action []Azurerm_autoscale_setting_profile_48_rule_52_scale_action_54
}

type Azurerm_autoscale_setting_profile_48 struct {
	Capacity []Azurerm_autoscale_setting_profile_48_capacity_49

	Fixed_date *[]Azurerm_autoscale_setting_profile_48_fixed_date_50

	Name string

	Recurrence *[]Azurerm_autoscale_setting_profile_48_recurrence_51

	Rule *[]Azurerm_autoscale_setting_profile_48_rule_52
}

type Azurerm_autoscale_setting struct {
	Azurerm_autoscale_setting_id *string `lyra:"ignore"`

	Enabled *bool

	Location string

	Name string

	Notification *[]Azurerm_autoscale_setting_notification_45

	Profile []Azurerm_autoscale_setting_profile_48

	Resource_group_name string

	Tags *map[string]string

	Target_resource_id string
}

var Azurerm_autoscale_setting_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_autoscale_setting_id",

		"enabled",

		"notification",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"target_resource_id",
	)
}

// Azurerm_autoscale_settingHandler ...
type Azurerm_autoscale_settingHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_autoscale_settingHandler) Create(desired *Azurerm_autoscale_setting) (*Azurerm_autoscale_setting, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_autoscale_setting", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_autoscale_setting", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_autoscale_settingHandler) Update(externalID string, desired *Azurerm_autoscale_setting) (*Azurerm_autoscale_setting, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_autoscale_setting", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_autoscale_setting", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_autoscale_setting{Azurerm_autoscale_setting_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_autoscale_setting", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_autoscale_settingHandler) Read(externalID string) (*Azurerm_autoscale_setting, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_autoscale_setting", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_autoscale_setting", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_autoscale_setting{Azurerm_autoscale_setting_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_autoscale_setting", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_autoscale_settingHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_autoscale_setting", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_autoscale_setting", externalID)
}

type Azurerm_availability_set struct {
	Azurerm_availability_set_id *string `lyra:"ignore"`

	Location string

	Managed *bool

	Name string

	Platform_fault_domain_count *int

	Platform_update_domain_count *int

	Resource_group_name string

	Tags *map[string]string
}

var Azurerm_availability_set_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_availability_set_id",

		"managed",

		"platform_fault_domain_count",

		"platform_update_domain_count",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"managed",

		"name",

		"platform_fault_domain_count",

		"platform_update_domain_count",

		"resource_group_name",
	)
}

// Azurerm_availability_setHandler ...
type Azurerm_availability_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_availability_setHandler) Create(desired *Azurerm_availability_set) (*Azurerm_availability_set, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_availability_set", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_availability_set", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_availability_setHandler) Update(externalID string, desired *Azurerm_availability_set) (*Azurerm_availability_set, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_availability_set", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_availability_set", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_availability_set{Azurerm_availability_set_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_availability_set", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_availability_setHandler) Read(externalID string) (*Azurerm_availability_set, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_availability_set", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_availability_set", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_availability_set{Azurerm_availability_set_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_availability_set", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_availability_setHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_availability_set", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_availability_set", externalID)
}

type Azurerm_azuread_application struct {
	Azurerm_azuread_application_id *string `lyra:"ignore"`

	Application_id *string

	Available_to_other_tenants *bool

	Homepage *string

	Identifier_uris *[]string

	Name string

	Oauth2_allow_implicit_flow *bool

	Reply_urls *[]string
}

var Azurerm_azuread_application_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_azuread_application_id",

		"application_id",

		"available_to_other_tenants",

		"homepage",

		"identifier_uris",

		"oauth2_allow_implicit_flow",

		"reply_urls",
	)
	rtb.ImmutableAttributes()
}

// Azurerm_azuread_applicationHandler ...
type Azurerm_azuread_applicationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_azuread_applicationHandler) Create(desired *Azurerm_azuread_application) (*Azurerm_azuread_application, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_azuread_application", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_azuread_application", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_azuread_applicationHandler) Update(externalID string, desired *Azurerm_azuread_application) (*Azurerm_azuread_application, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_azuread_application", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_azuread_application", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_azuread_application{Azurerm_azuread_application_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_azuread_application", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_azuread_applicationHandler) Read(externalID string) (*Azurerm_azuread_application, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_azuread_application", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_azuread_application", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_azuread_application{Azurerm_azuread_application_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_azuread_application", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_azuread_applicationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_azuread_application", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_azuread_application", externalID)
}

type Azurerm_azuread_service_principal struct {
	Azurerm_azuread_service_principal_id *string `lyra:"ignore"`

	Application_id string

	Display_name *string
}

var Azurerm_azuread_service_principal_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_azuread_service_principal_id",

		"display_name",
	)
	rtb.ImmutableAttributes(

		"application_id",
	)
}

// Azurerm_azuread_service_principalHandler ...
type Azurerm_azuread_service_principalHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_azuread_service_principalHandler) Create(desired *Azurerm_azuread_service_principal) (*Azurerm_azuread_service_principal, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_azuread_service_principal", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_azuread_service_principal", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_azuread_service_principalHandler) Update(externalID string, desired *Azurerm_azuread_service_principal) (*Azurerm_azuread_service_principal, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_azuread_service_principal", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_azuread_service_principal", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_azuread_service_principal{Azurerm_azuread_service_principal_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_azuread_service_principal", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_azuread_service_principalHandler) Read(externalID string) (*Azurerm_azuread_service_principal, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_azuread_service_principal", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_azuread_service_principal", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_azuread_service_principal{Azurerm_azuread_service_principal_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_azuread_service_principal", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_azuread_service_principalHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_azuread_service_principal", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_azuread_service_principal", externalID)
}

type Azurerm_azuread_service_principal_password struct {
	Azurerm_azuread_service_principal_password_id *string `lyra:"ignore"`

	End_date string

	Key_id *string

	Service_principal_id string

	Start_date *string

	Value string
}

var Azurerm_azuread_service_principal_password_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_azuread_service_principal_password_id",

		"key_id",

		"start_date",
	)
	rtb.ImmutableAttributes(

		"end_date",

		"key_id",

		"service_principal_id",

		"start_date",

		"value",
	)
}

// Azurerm_azuread_service_principal_passwordHandler ...
type Azurerm_azuread_service_principal_passwordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_azuread_service_principal_passwordHandler) Create(desired *Azurerm_azuread_service_principal_password) (*Azurerm_azuread_service_principal_password, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_azuread_service_principal_password", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_azuread_service_principal_password", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_azuread_service_principal_passwordHandler) Update(externalID string, desired *Azurerm_azuread_service_principal_password) (*Azurerm_azuread_service_principal_password, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_azuread_service_principal_password", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_azuread_service_principal_password", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_azuread_service_principal_password{Azurerm_azuread_service_principal_password_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_azuread_service_principal_password", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_azuread_service_principal_passwordHandler) Read(externalID string) (*Azurerm_azuread_service_principal_password, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_azuread_service_principal_password", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_azuread_service_principal_password", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_azuread_service_principal_password{Azurerm_azuread_service_principal_password_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_azuread_service_principal_password", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_azuread_service_principal_passwordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_azuread_service_principal_password", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_azuread_service_principal_password", externalID)
}

type Azurerm_batch_account struct {
	Azurerm_batch_account_id *string `lyra:"ignore"`

	Location string

	Name string

	Pool_allocation_mode *string

	Resource_group_name string

	Storage_account_id *string

	Tags *map[string]string
}

var Azurerm_batch_account_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_batch_account_id",

		"pool_allocation_mode",

		"storage_account_id",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_batch_accountHandler ...
type Azurerm_batch_accountHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_batch_accountHandler) Create(desired *Azurerm_batch_account) (*Azurerm_batch_account, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_batch_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_batch_account", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_batch_accountHandler) Update(externalID string, desired *Azurerm_batch_account) (*Azurerm_batch_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_batch_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_batch_account", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_batch_account{Azurerm_batch_account_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_batch_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_batch_accountHandler) Read(externalID string) (*Azurerm_batch_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_batch_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_batch_account", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_batch_account{Azurerm_batch_account_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_batch_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_batch_accountHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_batch_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_batch_account", externalID)
}

type Azurerm_batch_pool_auto_scale_55 struct {
	Evaluation_interval *string

	Formula string
}

type Azurerm_batch_pool_fixed_scale_56 struct {
	Resize_timeout *string

	Target_dedicated_nodes *int

	Target_low_priority_nodes *int
}

type Azurerm_batch_pool_start_task_57_user_identity_58_auto_user_59 struct {
	Elevation_level *string

	Scope *string
}

type Azurerm_batch_pool_start_task_57_user_identity_58 struct {
	Auto_user *[]Azurerm_batch_pool_start_task_57_user_identity_58_auto_user_59

	User_name *string
}

type Azurerm_batch_pool_start_task_57 struct {
	Command_line string

	Environment *map[string]string

	Max_task_retry_count *int

	User_identity []Azurerm_batch_pool_start_task_57_user_identity_58

	Wait_for_success *bool
}

type Azurerm_batch_pool_storage_image_reference_60 struct {
	Id *string

	Offer string

	Publisher string

	Sku string

	Version string
}

type Azurerm_batch_pool struct {
	Azurerm_batch_pool_id *string `lyra:"ignore"`

	Account_name string

	Auto_scale *[]Azurerm_batch_pool_auto_scale_55

	Display_name *string

	Fixed_scale *[]Azurerm_batch_pool_fixed_scale_56

	Name string

	Node_agent_sku_id string

	Resource_group_name string

	Start_task *[]Azurerm_batch_pool_start_task_57

	Stop_pending_resize_operation *bool

	Storage_image_reference []Azurerm_batch_pool_storage_image_reference_60

	Vm_size string
}

var Azurerm_batch_pool_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_batch_pool_id",

		"auto_scale",

		"display_name",

		"fixed_scale",

		"start_task",

		"stop_pending_resize_operation",
	)
	rtb.ImmutableAttributes(

		"account_name",

		"display_name",

		"name",

		"node_agent_sku_id",

		"resource_group_name",

		"storage_image_reference",

		"vm_size",
	)
}

// Azurerm_batch_poolHandler ...
type Azurerm_batch_poolHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_batch_poolHandler) Create(desired *Azurerm_batch_pool) (*Azurerm_batch_pool, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_batch_pool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_batch_pool", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_batch_poolHandler) Update(externalID string, desired *Azurerm_batch_pool) (*Azurerm_batch_pool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_batch_pool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_batch_pool", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_batch_pool{Azurerm_batch_pool_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_batch_pool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_batch_poolHandler) Read(externalID string) (*Azurerm_batch_pool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_batch_pool", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_batch_pool", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_batch_pool{Azurerm_batch_pool_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_batch_pool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_batch_poolHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_batch_pool", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_batch_pool", externalID)
}

type Azurerm_cdn_endpoint_geo_filter_61 struct {
	Action string

	Country_codes []string

	Relative_path string
}

type Azurerm_cdn_endpoint_origin_62 struct {
	Host_name string

	Http_port *int

	Https_port *int

	Name string
}

type Azurerm_cdn_endpoint struct {
	Azurerm_cdn_endpoint_id *string `lyra:"ignore"`

	Content_types_to_compress *[]string

	Geo_filter *[]Azurerm_cdn_endpoint_geo_filter_61

	Host_name *string

	Is_compression_enabled *bool

	Is_http_allowed *bool

	Is_https_allowed *bool

	Location string

	Name string

	Optimization_type *string

	Origin []Azurerm_cdn_endpoint_origin_62

	Origin_host_header *string

	Origin_path *string

	Probe_path *string

	Profile_name string

	Querystring_caching_behaviour *string

	Resource_group_name string

	Tags *map[string]string
}

var Azurerm_cdn_endpoint_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_cdn_endpoint_id",

		"content_types_to_compress",

		"geo_filter",

		"host_name",

		"is_compression_enabled",

		"is_http_allowed",

		"is_https_allowed",

		"optimization_type",

		"origin_host_header",

		"origin_path",

		"probe_path",

		"querystring_caching_behaviour",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"origin",

		"profile_name",

		"resource_group_name",
	)
}

// Azurerm_cdn_endpointHandler ...
type Azurerm_cdn_endpointHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_cdn_endpointHandler) Create(desired *Azurerm_cdn_endpoint) (*Azurerm_cdn_endpoint, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_cdn_endpoint", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_cdn_endpoint", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_cdn_endpointHandler) Update(externalID string, desired *Azurerm_cdn_endpoint) (*Azurerm_cdn_endpoint, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_cdn_endpoint", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_cdn_endpoint", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_cdn_endpoint{Azurerm_cdn_endpoint_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_cdn_endpoint", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_cdn_endpointHandler) Read(externalID string) (*Azurerm_cdn_endpoint, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_cdn_endpoint", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_cdn_endpoint", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_cdn_endpoint{Azurerm_cdn_endpoint_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_cdn_endpoint", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_cdn_endpointHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_cdn_endpoint", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_cdn_endpoint", externalID)
}

type Azurerm_cdn_profile struct {
	Azurerm_cdn_profile_id *string `lyra:"ignore"`

	Location string

	Name string

	Resource_group_name string

	Sku string

	Tags *map[string]string
}

var Azurerm_cdn_profile_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_cdn_profile_id",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"sku",
	)
}

// Azurerm_cdn_profileHandler ...
type Azurerm_cdn_profileHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_cdn_profileHandler) Create(desired *Azurerm_cdn_profile) (*Azurerm_cdn_profile, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_cdn_profile", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_cdn_profile", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_cdn_profileHandler) Update(externalID string, desired *Azurerm_cdn_profile) (*Azurerm_cdn_profile, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_cdn_profile", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_cdn_profile", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_cdn_profile{Azurerm_cdn_profile_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_cdn_profile", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_cdn_profileHandler) Read(externalID string) (*Azurerm_cdn_profile, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_cdn_profile", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_cdn_profile", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_cdn_profile{Azurerm_cdn_profile_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_cdn_profile", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_cdn_profileHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_cdn_profile", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_cdn_profile", externalID)
}

type Azurerm_cognitive_account_sku_63 struct {
	Name string

	Tier string
}

type Azurerm_cognitive_account struct {
	Azurerm_cognitive_account_id *string `lyra:"ignore"`

	Endpoint *string

	Kind string

	Location string

	Name string

	Resource_group_name string

	Sku []Azurerm_cognitive_account_sku_63

	Tags *map[string]string
}

var Azurerm_cognitive_account_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_cognitive_account_id",

		"endpoint",

		"tags",
	)
	rtb.ImmutableAttributes(

		"kind",

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_cognitive_accountHandler ...
type Azurerm_cognitive_accountHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_cognitive_accountHandler) Create(desired *Azurerm_cognitive_account) (*Azurerm_cognitive_account, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_cognitive_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_cognitive_account", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_cognitive_accountHandler) Update(externalID string, desired *Azurerm_cognitive_account) (*Azurerm_cognitive_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_cognitive_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_cognitive_account", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_cognitive_account{Azurerm_cognitive_account_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_cognitive_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_cognitive_accountHandler) Read(externalID string) (*Azurerm_cognitive_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_cognitive_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_cognitive_account", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_cognitive_account{Azurerm_cognitive_account_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_cognitive_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_cognitive_accountHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_cognitive_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_cognitive_account", externalID)
}

type Azurerm_container_group_container_64_ports_65 struct {
	Port *int

	Protocol *string
}

type Azurerm_container_group_container_64_volume_66 struct {
	Mount_path string

	Name string

	Read_only *bool

	Share_name string

	Storage_account_key string

	Storage_account_name string
}

type Azurerm_container_group_container_64 struct {
	Command *string

	Commands *[]string

	Cpu float64

	Environment_variables *map[string]string

	Image string

	Memory float64

	Name string

	Port *int

	Ports *[]Azurerm_container_group_container_64_ports_65

	Protocol *string

	Secure_environment_variables *map[string]string

	Volume *[]Azurerm_container_group_container_64_volume_66
}

type Azurerm_container_group_image_registry_credential_67 struct {
	Password string

	Server string

	Username string
}

type Azurerm_container_group struct {
	Azurerm_container_group_id *string `lyra:"ignore"`

	Container []Azurerm_container_group_container_64

	Dns_name_label *string

	Fqdn *string

	Image_registry_credential *[]Azurerm_container_group_image_registry_credential_67

	Ip_address *string

	Ip_address_type *string

	Location string

	Name string

	Os_type string

	Resource_group_name string

	Restart_policy *string

	Tags *map[string]string
}

var Azurerm_container_group_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_container_group_id",

		"dns_name_label",

		"fqdn",

		"image_registry_credential",

		"ip_address",

		"ip_address_type",

		"restart_policy",

		"tags",
	)
	rtb.ImmutableAttributes(

		"container",

		"dns_name_label",

		"image_registry_credential",

		"ip_address_type",

		"location",

		"name",

		"os_type",

		"resource_group_name",

		"restart_policy",

		"tags",
	)
}

// Azurerm_container_groupHandler ...
type Azurerm_container_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_container_groupHandler) Create(desired *Azurerm_container_group) (*Azurerm_container_group, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_container_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_container_group", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_container_groupHandler) Update(externalID string, desired *Azurerm_container_group) (*Azurerm_container_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_container_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_container_group", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_container_group{Azurerm_container_group_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_container_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_container_groupHandler) Read(externalID string) (*Azurerm_container_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_container_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_container_group", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_container_group{Azurerm_container_group_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_container_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_container_groupHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_container_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_container_group", externalID)
}

type Azurerm_container_registry_storage_account_68 struct {
	Access_key string

	Name string
}

type Azurerm_container_registry struct {
	Azurerm_container_registry_id *string `lyra:"ignore"`

	Admin_enabled *bool

	Admin_password *string

	Admin_username *string

	Georeplication_locations *[]string

	Location string

	Login_server *string

	Name string

	Resource_group_name string

	Sku *string

	Storage_account *[]Azurerm_container_registry_storage_account_68

	Storage_account_id *string

	Tags *map[string]string
}

var Azurerm_container_registry_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_container_registry_id",

		"admin_enabled",

		"admin_password",

		"admin_username",

		"georeplication_locations",

		"login_server",

		"sku",

		"storage_account",

		"storage_account_id",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_container_registryHandler ...
type Azurerm_container_registryHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_container_registryHandler) Create(desired *Azurerm_container_registry) (*Azurerm_container_registry, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_container_registry", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_container_registry", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_container_registryHandler) Update(externalID string, desired *Azurerm_container_registry) (*Azurerm_container_registry, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_container_registry", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_container_registry", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_container_registry{Azurerm_container_registry_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_container_registry", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_container_registryHandler) Read(externalID string) (*Azurerm_container_registry, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_container_registry", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_container_registry", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_container_registry{Azurerm_container_registry_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_container_registry", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_container_registryHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_container_registry", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_container_registry", externalID)
}

type Azurerm_container_service_agent_pool_profile_69 struct {
	Count *int

	Dns_prefix string

	Fqdn *string

	Name string

	Vm_size string
}

type Azurerm_container_service_diagnostics_profile_70 struct {
	Enabled bool

	Storage_uri *string
}

type Azurerm_container_service_linux_profile_71_ssh_key_72 struct {
	Key_data string
}

type Azurerm_container_service_linux_profile_71 struct {
	Admin_username string

	Ssh_key []Azurerm_container_service_linux_profile_71_ssh_key_72
}

type Azurerm_container_service_master_profile_73 struct {
	Count *int

	Dns_prefix string

	Fqdn *string
}

type Azurerm_container_service_service_principal_74 struct {
	Client_id string

	Client_secret string
}

type Azurerm_container_service struct {
	Azurerm_container_service_id *string `lyra:"ignore"`

	Agent_pool_profile []Azurerm_container_service_agent_pool_profile_69

	Diagnostics_profile []Azurerm_container_service_diagnostics_profile_70

	Linux_profile []Azurerm_container_service_linux_profile_71

	Location string

	Master_profile []Azurerm_container_service_master_profile_73

	Name string

	Orchestration_platform string

	Resource_group_name string

	Service_principal *[]Azurerm_container_service_service_principal_74

	Tags *map[string]string
}

var Azurerm_container_service_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_container_service_id",

		"service_principal",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"orchestration_platform",

		"resource_group_name",
	)
}

// Azurerm_container_serviceHandler ...
type Azurerm_container_serviceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_container_serviceHandler) Create(desired *Azurerm_container_service) (*Azurerm_container_service, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_container_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_container_service", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_container_serviceHandler) Update(externalID string, desired *Azurerm_container_service) (*Azurerm_container_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_container_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_container_service", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_container_service{Azurerm_container_service_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_container_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_container_serviceHandler) Read(externalID string) (*Azurerm_container_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_container_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_container_service", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_container_service{Azurerm_container_service_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_container_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_container_serviceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_container_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_container_service", externalID)
}

type Azurerm_cosmosdb_account_capabilities_75 struct {
	Name string
}

type Azurerm_cosmosdb_account_consistency_policy_76 struct {
	Consistency_level string

	Max_interval_in_seconds *int

	Max_staleness_prefix *int
}

type Azurerm_cosmosdb_account_failover_policy_77 struct {
	Id *string

	Location string

	Priority int
}

type Azurerm_cosmosdb_account_geo_location_78 struct {
	Failover_priority int

	Id *string

	Location string

	Prefix *string
}

type Azurerm_cosmosdb_account_virtual_network_rule_79 struct {
	Id string
}

type Azurerm_cosmosdb_account struct {
	Azurerm_cosmosdb_account_id *string `lyra:"ignore"`

	Capabilities *[]Azurerm_cosmosdb_account_capabilities_75

	Connection_strings *[]string

	Consistency_policy []Azurerm_cosmosdb_account_consistency_policy_76

	Enable_automatic_failover *bool

	Enable_multiple_write_locations *bool

	Endpoint *string

	Failover_policy *[]Azurerm_cosmosdb_account_failover_policy_77

	Geo_location *[]Azurerm_cosmosdb_account_geo_location_78

	Ip_range_filter *string

	Is_virtual_network_filter_enabled *bool

	Kind *string

	Location string

	Name string

	Offer_type string

	Primary_master_key *string

	Primary_readonly_master_key *string

	Read_endpoints *[]string

	Resource_group_name string

	Secondary_master_key *string

	Secondary_readonly_master_key *string

	Tags *map[string]string

	Virtual_network_rule *[]Azurerm_cosmosdb_account_virtual_network_rule_79

	Write_endpoints *[]string
}

var Azurerm_cosmosdb_account_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_cosmosdb_account_id",

		"capabilities",

		"connection_strings",

		"enable_automatic_failover",

		"enable_multiple_write_locations",

		"endpoint",

		"failover_policy",

		"geo_location",

		"ip_range_filter",

		"is_virtual_network_filter_enabled",

		"kind",

		"primary_master_key",

		"primary_readonly_master_key",

		"read_endpoints",

		"secondary_master_key",

		"secondary_readonly_master_key",

		"tags",

		"virtual_network_rule",

		"write_endpoints",
	)
	rtb.ImmutableAttributes(

		"kind",

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_cosmosdb_accountHandler ...
type Azurerm_cosmosdb_accountHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_cosmosdb_accountHandler) Create(desired *Azurerm_cosmosdb_account) (*Azurerm_cosmosdb_account, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_cosmosdb_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_cosmosdb_account", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_cosmosdb_accountHandler) Update(externalID string, desired *Azurerm_cosmosdb_account) (*Azurerm_cosmosdb_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_cosmosdb_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_cosmosdb_account", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_cosmosdb_account{Azurerm_cosmosdb_account_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_cosmosdb_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_cosmosdb_accountHandler) Read(externalID string) (*Azurerm_cosmosdb_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_cosmosdb_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_cosmosdb_account", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_cosmosdb_account{Azurerm_cosmosdb_account_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_cosmosdb_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_cosmosdb_accountHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_cosmosdb_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_cosmosdb_account", externalID)
}

type Azurerm_data_lake_analytics_account struct {
	Azurerm_data_lake_analytics_account_id *string `lyra:"ignore"`

	Default_store_account_name string

	Location string

	Name string

	Resource_group_name string

	Tags *map[string]string

	Tier *string
}

var Azurerm_data_lake_analytics_account_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_data_lake_analytics_account_id",

		"tags",

		"tier",
	)
	rtb.ImmutableAttributes(

		"default_store_account_name",

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_data_lake_analytics_accountHandler ...
type Azurerm_data_lake_analytics_accountHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_data_lake_analytics_accountHandler) Create(desired *Azurerm_data_lake_analytics_account) (*Azurerm_data_lake_analytics_account, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_data_lake_analytics_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_data_lake_analytics_account", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_data_lake_analytics_accountHandler) Update(externalID string, desired *Azurerm_data_lake_analytics_account) (*Azurerm_data_lake_analytics_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_data_lake_analytics_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_data_lake_analytics_account", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_analytics_account{Azurerm_data_lake_analytics_account_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_data_lake_analytics_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_data_lake_analytics_accountHandler) Read(externalID string) (*Azurerm_data_lake_analytics_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_data_lake_analytics_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_data_lake_analytics_account", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_analytics_account{Azurerm_data_lake_analytics_account_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_data_lake_analytics_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_data_lake_analytics_accountHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_data_lake_analytics_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_data_lake_analytics_account", externalID)
}

type Azurerm_data_lake_analytics_firewall_rule struct {
	Azurerm_data_lake_analytics_firewall_rule_id *string `lyra:"ignore"`

	Account_name string

	End_ip_address string

	Name string

	Resource_group_name string

	Start_ip_address string
}

var Azurerm_data_lake_analytics_firewall_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_data_lake_analytics_firewall_rule_id",
	)
	rtb.ImmutableAttributes(

		"account_name",

		"name",

		"resource_group_name",
	)
}

// Azurerm_data_lake_analytics_firewall_ruleHandler ...
type Azurerm_data_lake_analytics_firewall_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_data_lake_analytics_firewall_ruleHandler) Create(desired *Azurerm_data_lake_analytics_firewall_rule) (*Azurerm_data_lake_analytics_firewall_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_data_lake_analytics_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_data_lake_analytics_firewall_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_data_lake_analytics_firewall_ruleHandler) Update(externalID string, desired *Azurerm_data_lake_analytics_firewall_rule) (*Azurerm_data_lake_analytics_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_data_lake_analytics_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_data_lake_analytics_firewall_rule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_analytics_firewall_rule{Azurerm_data_lake_analytics_firewall_rule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_data_lake_analytics_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_data_lake_analytics_firewall_ruleHandler) Read(externalID string) (*Azurerm_data_lake_analytics_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_data_lake_analytics_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_data_lake_analytics_firewall_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_analytics_firewall_rule{Azurerm_data_lake_analytics_firewall_rule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_data_lake_analytics_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_data_lake_analytics_firewall_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_data_lake_analytics_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_data_lake_analytics_firewall_rule", externalID)
}

type Azurerm_data_lake_store struct {
	Azurerm_data_lake_store_id *string `lyra:"ignore"`

	Encryption_state *string

	Encryption_type *string

	Endpoint *string

	Firewall_allow_azure_ips *string

	Firewall_state *string

	Location string

	Name string

	Resource_group_name string

	Tags *map[string]string

	Tier *string
}

var Azurerm_data_lake_store_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_data_lake_store_id",

		"encryption_state",

		"encryption_type",

		"endpoint",

		"firewall_allow_azure_ips",

		"firewall_state",

		"tags",

		"tier",
	)
	rtb.ImmutableAttributes(

		"encryption_state",

		"encryption_type",

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_data_lake_storeHandler ...
type Azurerm_data_lake_storeHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_data_lake_storeHandler) Create(desired *Azurerm_data_lake_store) (*Azurerm_data_lake_store, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_data_lake_store", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_data_lake_store", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_data_lake_storeHandler) Update(externalID string, desired *Azurerm_data_lake_store) (*Azurerm_data_lake_store, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_data_lake_store", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_data_lake_store", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_store{Azurerm_data_lake_store_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_data_lake_store", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_data_lake_storeHandler) Read(externalID string) (*Azurerm_data_lake_store, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_data_lake_store", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_data_lake_store", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_store{Azurerm_data_lake_store_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_data_lake_store", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_data_lake_storeHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_data_lake_store", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_data_lake_store", externalID)
}

type Azurerm_data_lake_store_file struct {
	Azurerm_data_lake_store_file_id *string `lyra:"ignore"`

	Account_name string

	Local_file_path string

	Remote_file_path string
}

var Azurerm_data_lake_store_file_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_data_lake_store_file_id",
	)
	rtb.ImmutableAttributes(

		"account_name",

		"local_file_path",

		"remote_file_path",
	)
}

// Azurerm_data_lake_store_fileHandler ...
type Azurerm_data_lake_store_fileHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_data_lake_store_fileHandler) Create(desired *Azurerm_data_lake_store_file) (*Azurerm_data_lake_store_file, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_data_lake_store_file", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_data_lake_store_file", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_data_lake_store_fileHandler) Update(externalID string, desired *Azurerm_data_lake_store_file) (*Azurerm_data_lake_store_file, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_data_lake_store_file", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_data_lake_store_file", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_store_file{Azurerm_data_lake_store_file_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_data_lake_store_file", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_data_lake_store_fileHandler) Read(externalID string) (*Azurerm_data_lake_store_file, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_data_lake_store_file", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_data_lake_store_file", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_store_file{Azurerm_data_lake_store_file_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_data_lake_store_file", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_data_lake_store_fileHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_data_lake_store_file", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_data_lake_store_file", externalID)
}

type Azurerm_data_lake_store_firewall_rule struct {
	Azurerm_data_lake_store_firewall_rule_id *string `lyra:"ignore"`

	Account_name string

	End_ip_address string

	Name string

	Resource_group_name string

	Start_ip_address string
}

var Azurerm_data_lake_store_firewall_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_data_lake_store_firewall_rule_id",
	)
	rtb.ImmutableAttributes(

		"account_name",

		"name",

		"resource_group_name",
	)
}

// Azurerm_data_lake_store_firewall_ruleHandler ...
type Azurerm_data_lake_store_firewall_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_data_lake_store_firewall_ruleHandler) Create(desired *Azurerm_data_lake_store_firewall_rule) (*Azurerm_data_lake_store_firewall_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_data_lake_store_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_data_lake_store_firewall_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_data_lake_store_firewall_ruleHandler) Update(externalID string, desired *Azurerm_data_lake_store_firewall_rule) (*Azurerm_data_lake_store_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_data_lake_store_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_data_lake_store_firewall_rule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_store_firewall_rule{Azurerm_data_lake_store_firewall_rule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_data_lake_store_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_data_lake_store_firewall_ruleHandler) Read(externalID string) (*Azurerm_data_lake_store_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_data_lake_store_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_data_lake_store_firewall_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_data_lake_store_firewall_rule{Azurerm_data_lake_store_firewall_rule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_data_lake_store_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_data_lake_store_firewall_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_data_lake_store_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_data_lake_store_firewall_rule", externalID)
}

type Azurerm_databricks_workspace struct {
	Azurerm_databricks_workspace_id *string `lyra:"ignore"`

	Location string

	Managed_resource_group_id *string

	Managed_resource_group_name *string

	Name string

	Resource_group_name string

	Sku string

	Tags *map[string]string
}

var Azurerm_databricks_workspace_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_databricks_workspace_id",

		"managed_resource_group_id",

		"managed_resource_group_name",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"managed_resource_group_name",

		"name",

		"resource_group_name",

		"sku",
	)
}

// Azurerm_databricks_workspaceHandler ...
type Azurerm_databricks_workspaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_databricks_workspaceHandler) Create(desired *Azurerm_databricks_workspace) (*Azurerm_databricks_workspace, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_databricks_workspace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_databricks_workspace", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_databricks_workspaceHandler) Update(externalID string, desired *Azurerm_databricks_workspace) (*Azurerm_databricks_workspace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_databricks_workspace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_databricks_workspace", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_databricks_workspace{Azurerm_databricks_workspace_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_databricks_workspace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_databricks_workspaceHandler) Read(externalID string) (*Azurerm_databricks_workspace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_databricks_workspace", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_databricks_workspace", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_databricks_workspace{Azurerm_databricks_workspace_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_databricks_workspace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_databricks_workspaceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_databricks_workspace", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_databricks_workspace", externalID)
}

type Azurerm_dev_test_lab struct {
	Azurerm_dev_test_lab_id *string `lyra:"ignore"`

	Artifacts_storage_account_id *string

	Default_premium_storage_account_id *string

	Default_storage_account_id *string

	Key_vault_id *string

	Location string

	Name string

	Premium_data_disk_storage_account_id *string

	Resource_group_name string

	Storage_type *string

	Tags *map[string]string

	Unique_identifier *string
}

var Azurerm_dev_test_lab_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dev_test_lab_id",

		"artifacts_storage_account_id",

		"default_premium_storage_account_id",

		"default_storage_account_id",

		"key_vault_id",

		"premium_data_disk_storage_account_id",

		"storage_type",

		"tags",

		"unique_identifier",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_dev_test_labHandler ...
type Azurerm_dev_test_labHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dev_test_labHandler) Create(desired *Azurerm_dev_test_lab) (*Azurerm_dev_test_lab, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dev_test_lab", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dev_test_lab", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dev_test_labHandler) Update(externalID string, desired *Azurerm_dev_test_lab) (*Azurerm_dev_test_lab, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dev_test_lab", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dev_test_lab", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_lab{Azurerm_dev_test_lab_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dev_test_lab", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dev_test_labHandler) Read(externalID string) (*Azurerm_dev_test_lab, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dev_test_lab", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dev_test_lab", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_lab{Azurerm_dev_test_lab_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dev_test_lab", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dev_test_labHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dev_test_lab", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dev_test_lab", externalID)
}

type Azurerm_dev_test_linux_virtual_machine_gallery_image_reference_80 struct {
	Offer string

	Publisher string

	Sku string

	Version string
}

type Azurerm_dev_test_linux_virtual_machine_inbound_nat_rule_81 struct {
	Backend_port int

	Frontend_port *int

	Protocol string
}

type Azurerm_dev_test_linux_virtual_machine struct {
	Azurerm_dev_test_linux_virtual_machine_id *string `lyra:"ignore"`

	Allow_claim *bool

	Disallow_public_ip_address *bool

	Fqdn *string

	Gallery_image_reference []Azurerm_dev_test_linux_virtual_machine_gallery_image_reference_80

	Inbound_nat_rule *[]Azurerm_dev_test_linux_virtual_machine_inbound_nat_rule_81

	Lab_name string

	Lab_subnet_name string

	Lab_virtual_network_id string

	Location string

	Name string

	Notes *string

	Password *string

	Resource_group_name string

	Size string

	Ssh_key *string

	Storage_type string

	Tags *map[string]string

	Unique_identifier *string

	Username string
}

var Azurerm_dev_test_linux_virtual_machine_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dev_test_linux_virtual_machine_id",

		"allow_claim",

		"disallow_public_ip_address",

		"fqdn",

		"inbound_nat_rule",

		"notes",

		"password",

		"ssh_key",

		"tags",

		"unique_identifier",
	)
	rtb.ImmutableAttributes(

		"disallow_public_ip_address",

		"inbound_nat_rule",

		"lab_name",

		"lab_subnet_name",

		"lab_virtual_network_id",

		"location",

		"name",

		"password",

		"resource_group_name",

		"size",

		"ssh_key",

		"username",
	)
}

// Azurerm_dev_test_linux_virtual_machineHandler ...
type Azurerm_dev_test_linux_virtual_machineHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dev_test_linux_virtual_machineHandler) Create(desired *Azurerm_dev_test_linux_virtual_machine) (*Azurerm_dev_test_linux_virtual_machine, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dev_test_linux_virtual_machine", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dev_test_linux_virtual_machine", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dev_test_linux_virtual_machineHandler) Update(externalID string, desired *Azurerm_dev_test_linux_virtual_machine) (*Azurerm_dev_test_linux_virtual_machine, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dev_test_linux_virtual_machine", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dev_test_linux_virtual_machine", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_linux_virtual_machine{Azurerm_dev_test_linux_virtual_machine_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dev_test_linux_virtual_machine", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dev_test_linux_virtual_machineHandler) Read(externalID string) (*Azurerm_dev_test_linux_virtual_machine, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dev_test_linux_virtual_machine", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dev_test_linux_virtual_machine", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_linux_virtual_machine{Azurerm_dev_test_linux_virtual_machine_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dev_test_linux_virtual_machine", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dev_test_linux_virtual_machineHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dev_test_linux_virtual_machine", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dev_test_linux_virtual_machine", externalID)
}

type Azurerm_dev_test_policy struct {
	Azurerm_dev_test_policy_id *string `lyra:"ignore"`

	Description *string

	Evaluator_type string

	Fact_data *string

	Lab_name string

	Name string

	Policy_set_name string

	Resource_group_name string

	Tags *map[string]string

	Threshold string
}

var Azurerm_dev_test_policy_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dev_test_policy_id",

		"description",

		"fact_data",

		"tags",
	)
	rtb.ImmutableAttributes(

		"evaluator_type",

		"lab_name",

		"name",

		"policy_set_name",

		"resource_group_name",
	)
}

// Azurerm_dev_test_policyHandler ...
type Azurerm_dev_test_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dev_test_policyHandler) Create(desired *Azurerm_dev_test_policy) (*Azurerm_dev_test_policy, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dev_test_policy", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dev_test_policy", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dev_test_policyHandler) Update(externalID string, desired *Azurerm_dev_test_policy) (*Azurerm_dev_test_policy, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dev_test_policy", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dev_test_policy", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_policy{Azurerm_dev_test_policy_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dev_test_policy", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dev_test_policyHandler) Read(externalID string) (*Azurerm_dev_test_policy, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dev_test_policy", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dev_test_policy", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_policy{Azurerm_dev_test_policy_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dev_test_policy", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dev_test_policyHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dev_test_policy", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dev_test_policy", externalID)
}

type Azurerm_dev_test_virtual_network_subnet_82 struct {
	Name *string

	Use_in_virtual_machine_creation *string

	Use_public_ip_address *string
}

type Azurerm_dev_test_virtual_network struct {
	Azurerm_dev_test_virtual_network_id *string `lyra:"ignore"`

	Description *string

	Lab_name string

	Name string

	Resource_group_name string

	Subnet *[]Azurerm_dev_test_virtual_network_subnet_82

	Tags *map[string]string

	Unique_identifier *string
}

var Azurerm_dev_test_virtual_network_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dev_test_virtual_network_id",

		"description",

		"subnet",

		"tags",

		"unique_identifier",
	)
	rtb.ImmutableAttributes(

		"lab_name",

		"name",

		"resource_group_name",
	)
}

// Azurerm_dev_test_virtual_networkHandler ...
type Azurerm_dev_test_virtual_networkHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dev_test_virtual_networkHandler) Create(desired *Azurerm_dev_test_virtual_network) (*Azurerm_dev_test_virtual_network, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dev_test_virtual_network", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dev_test_virtual_network", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dev_test_virtual_networkHandler) Update(externalID string, desired *Azurerm_dev_test_virtual_network) (*Azurerm_dev_test_virtual_network, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dev_test_virtual_network", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dev_test_virtual_network", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_virtual_network{Azurerm_dev_test_virtual_network_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dev_test_virtual_network", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dev_test_virtual_networkHandler) Read(externalID string) (*Azurerm_dev_test_virtual_network, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dev_test_virtual_network", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dev_test_virtual_network", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_virtual_network{Azurerm_dev_test_virtual_network_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dev_test_virtual_network", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dev_test_virtual_networkHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dev_test_virtual_network", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dev_test_virtual_network", externalID)
}

type Azurerm_dev_test_windows_virtual_machine_gallery_image_reference_83 struct {
	Offer string

	Publisher string

	Sku string

	Version string
}

type Azurerm_dev_test_windows_virtual_machine_inbound_nat_rule_84 struct {
	Backend_port int

	Frontend_port *int

	Protocol string
}

type Azurerm_dev_test_windows_virtual_machine struct {
	Azurerm_dev_test_windows_virtual_machine_id *string `lyra:"ignore"`

	Allow_claim *bool

	Disallow_public_ip_address *bool

	Fqdn *string

	Gallery_image_reference []Azurerm_dev_test_windows_virtual_machine_gallery_image_reference_83

	Inbound_nat_rule *[]Azurerm_dev_test_windows_virtual_machine_inbound_nat_rule_84

	Lab_name string

	Lab_subnet_name string

	Lab_virtual_network_id string

	Location string

	Name string

	Notes *string

	Password string

	Resource_group_name string

	Size string

	Storage_type string

	Tags *map[string]string

	Unique_identifier *string

	Username string
}

var Azurerm_dev_test_windows_virtual_machine_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dev_test_windows_virtual_machine_id",

		"allow_claim",

		"disallow_public_ip_address",

		"fqdn",

		"inbound_nat_rule",

		"notes",

		"tags",

		"unique_identifier",
	)
	rtb.ImmutableAttributes(

		"disallow_public_ip_address",

		"inbound_nat_rule",

		"lab_name",

		"lab_subnet_name",

		"lab_virtual_network_id",

		"location",

		"name",

		"password",

		"resource_group_name",

		"size",

		"username",
	)
}

// Azurerm_dev_test_windows_virtual_machineHandler ...
type Azurerm_dev_test_windows_virtual_machineHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dev_test_windows_virtual_machineHandler) Create(desired *Azurerm_dev_test_windows_virtual_machine) (*Azurerm_dev_test_windows_virtual_machine, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dev_test_windows_virtual_machine", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dev_test_windows_virtual_machine", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dev_test_windows_virtual_machineHandler) Update(externalID string, desired *Azurerm_dev_test_windows_virtual_machine) (*Azurerm_dev_test_windows_virtual_machine, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dev_test_windows_virtual_machine", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dev_test_windows_virtual_machine", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_windows_virtual_machine{Azurerm_dev_test_windows_virtual_machine_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dev_test_windows_virtual_machine", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dev_test_windows_virtual_machineHandler) Read(externalID string) (*Azurerm_dev_test_windows_virtual_machine, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dev_test_windows_virtual_machine", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dev_test_windows_virtual_machine", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dev_test_windows_virtual_machine{Azurerm_dev_test_windows_virtual_machine_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dev_test_windows_virtual_machine", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dev_test_windows_virtual_machineHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dev_test_windows_virtual_machine", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dev_test_windows_virtual_machine", externalID)
}

type Azurerm_devspace_controller_sku_85 struct {
	Name string

	Tier string
}

type Azurerm_devspace_controller struct {
	Azurerm_devspace_controller_id *string `lyra:"ignore"`

	Data_plane_fqdn *string

	Host_suffix string

	Location string

	Name string

	Resource_group_name string

	Sku []Azurerm_devspace_controller_sku_85

	Tags *map[string]string

	Target_container_host_credentials_base64 string

	Target_container_host_resource_id string
}

var Azurerm_devspace_controller_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_devspace_controller_id",

		"data_plane_fqdn",

		"tags",
	)
	rtb.ImmutableAttributes(

		"host_suffix",

		"location",

		"name",

		"resource_group_name",

		"sku",

		"target_container_host_credentials_base64",

		"target_container_host_resource_id",
	)
}

// Azurerm_devspace_controllerHandler ...
type Azurerm_devspace_controllerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_devspace_controllerHandler) Create(desired *Azurerm_devspace_controller) (*Azurerm_devspace_controller, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_devspace_controller", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_devspace_controller", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_devspace_controllerHandler) Update(externalID string, desired *Azurerm_devspace_controller) (*Azurerm_devspace_controller, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_devspace_controller", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_devspace_controller", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_devspace_controller{Azurerm_devspace_controller_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_devspace_controller", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_devspace_controllerHandler) Read(externalID string) (*Azurerm_devspace_controller, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_devspace_controller", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_devspace_controller", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_devspace_controller{Azurerm_devspace_controller_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_devspace_controller", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_devspace_controllerHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_devspace_controller", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_devspace_controller", externalID)
}

type Azurerm_dns_a_record struct {
	Azurerm_dns_a_record_id *string `lyra:"ignore"`

	Name string

	Records []string

	Resource_group_name string

	Tags *map[string]string

	Ttl int

	Zone_name string
}

var Azurerm_dns_a_record_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_a_record_id",

		"tags",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",
	)
}

// Azurerm_dns_a_recordHandler ...
type Azurerm_dns_a_recordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_a_recordHandler) Create(desired *Azurerm_dns_a_record) (*Azurerm_dns_a_record, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_a_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_a_record", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_a_recordHandler) Update(externalID string, desired *Azurerm_dns_a_record) (*Azurerm_dns_a_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_a_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_a_record", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_a_record{Azurerm_dns_a_record_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_a_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_a_recordHandler) Read(externalID string) (*Azurerm_dns_a_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_a_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_a_record", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_a_record{Azurerm_dns_a_record_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_a_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_a_recordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_a_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_a_record", externalID)
}

type Azurerm_dns_aaaa_record struct {
	Azurerm_dns_aaaa_record_id *string `lyra:"ignore"`

	Name string

	Records []string

	Resource_group_name string

	Tags *map[string]string

	Ttl int

	Zone_name string
}

var Azurerm_dns_aaaa_record_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_aaaa_record_id",

		"tags",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",
	)
}

// Azurerm_dns_aaaa_recordHandler ...
type Azurerm_dns_aaaa_recordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_aaaa_recordHandler) Create(desired *Azurerm_dns_aaaa_record) (*Azurerm_dns_aaaa_record, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_aaaa_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_aaaa_record", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_aaaa_recordHandler) Update(externalID string, desired *Azurerm_dns_aaaa_record) (*Azurerm_dns_aaaa_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_aaaa_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_aaaa_record", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_aaaa_record{Azurerm_dns_aaaa_record_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_aaaa_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_aaaa_recordHandler) Read(externalID string) (*Azurerm_dns_aaaa_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_aaaa_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_aaaa_record", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_aaaa_record{Azurerm_dns_aaaa_record_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_aaaa_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_aaaa_recordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_aaaa_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_aaaa_record", externalID)
}

type Azurerm_dns_caa_record_record_86 struct {
	Flags int

	Tag string

	Value string
}

type Azurerm_dns_caa_record struct {
	Azurerm_dns_caa_record_id *string `lyra:"ignore"`

	Name string

	Record []Azurerm_dns_caa_record_record_86

	Resource_group_name string

	Tags *map[string]string

	Ttl int

	Zone_name string
}

var Azurerm_dns_caa_record_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_caa_record_id",

		"tags",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",
	)
}

// Azurerm_dns_caa_recordHandler ...
type Azurerm_dns_caa_recordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_caa_recordHandler) Create(desired *Azurerm_dns_caa_record) (*Azurerm_dns_caa_record, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_caa_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_caa_record", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_caa_recordHandler) Update(externalID string, desired *Azurerm_dns_caa_record) (*Azurerm_dns_caa_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_caa_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_caa_record", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_caa_record{Azurerm_dns_caa_record_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_caa_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_caa_recordHandler) Read(externalID string) (*Azurerm_dns_caa_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_caa_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_caa_record", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_caa_record{Azurerm_dns_caa_record_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_caa_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_caa_recordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_caa_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_caa_record", externalID)
}

type Azurerm_dns_cname_record struct {
	Azurerm_dns_cname_record_id *string `lyra:"ignore"`

	Name string

	Record string

	Records *string

	Resource_group_name string

	Tags *map[string]string

	Ttl int

	Zone_name string
}

var Azurerm_dns_cname_record_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_cname_record_id",

		"records",

		"tags",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",
	)
}

// Azurerm_dns_cname_recordHandler ...
type Azurerm_dns_cname_recordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_cname_recordHandler) Create(desired *Azurerm_dns_cname_record) (*Azurerm_dns_cname_record, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_cname_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_cname_record", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_cname_recordHandler) Update(externalID string, desired *Azurerm_dns_cname_record) (*Azurerm_dns_cname_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_cname_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_cname_record", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_cname_record{Azurerm_dns_cname_record_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_cname_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_cname_recordHandler) Read(externalID string) (*Azurerm_dns_cname_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_cname_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_cname_record", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_cname_record{Azurerm_dns_cname_record_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_cname_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_cname_recordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_cname_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_cname_record", externalID)
}

type Azurerm_dns_mx_record_record_87 struct {
	Exchange string

	Preference string
}

type Azurerm_dns_mx_record struct {
	Azurerm_dns_mx_record_id *string `lyra:"ignore"`

	Name string

	Record []Azurerm_dns_mx_record_record_87

	Resource_group_name string

	Tags *map[string]string

	Ttl int

	Zone_name string
}

var Azurerm_dns_mx_record_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_mx_record_id",

		"tags",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",
	)
}

// Azurerm_dns_mx_recordHandler ...
type Azurerm_dns_mx_recordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_mx_recordHandler) Create(desired *Azurerm_dns_mx_record) (*Azurerm_dns_mx_record, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_mx_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_mx_record", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_mx_recordHandler) Update(externalID string, desired *Azurerm_dns_mx_record) (*Azurerm_dns_mx_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_mx_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_mx_record", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_mx_record{Azurerm_dns_mx_record_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_mx_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_mx_recordHandler) Read(externalID string) (*Azurerm_dns_mx_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_mx_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_mx_record", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_mx_record{Azurerm_dns_mx_record_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_mx_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_mx_recordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_mx_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_mx_record", externalID)
}

type Azurerm_dns_ns_record_record_88 struct {
	Nsdname string
}

type Azurerm_dns_ns_record struct {
	Azurerm_dns_ns_record_id *string `lyra:"ignore"`

	Name string

	Record *[]Azurerm_dns_ns_record_record_88

	Records *[]string

	Resource_group_name string

	Tags *map[string]string

	Ttl int

	Zone_name string
}

var Azurerm_dns_ns_record_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_ns_record_id",

		"record",

		"records",

		"tags",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",
	)
}

// Azurerm_dns_ns_recordHandler ...
type Azurerm_dns_ns_recordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_ns_recordHandler) Create(desired *Azurerm_dns_ns_record) (*Azurerm_dns_ns_record, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_ns_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_ns_record", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_ns_recordHandler) Update(externalID string, desired *Azurerm_dns_ns_record) (*Azurerm_dns_ns_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_ns_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_ns_record", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_ns_record{Azurerm_dns_ns_record_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_ns_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_ns_recordHandler) Read(externalID string) (*Azurerm_dns_ns_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_ns_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_ns_record", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_ns_record{Azurerm_dns_ns_record_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_ns_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_ns_recordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_ns_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_ns_record", externalID)
}

type Azurerm_dns_ptr_record struct {
	Azurerm_dns_ptr_record_id *string `lyra:"ignore"`

	Name string

	Records []string

	Resource_group_name string

	Tags *map[string]string

	Ttl int

	Zone_name string
}

var Azurerm_dns_ptr_record_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_ptr_record_id",

		"tags",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",
	)
}

// Azurerm_dns_ptr_recordHandler ...
type Azurerm_dns_ptr_recordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_ptr_recordHandler) Create(desired *Azurerm_dns_ptr_record) (*Azurerm_dns_ptr_record, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_ptr_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_ptr_record", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_ptr_recordHandler) Update(externalID string, desired *Azurerm_dns_ptr_record) (*Azurerm_dns_ptr_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_ptr_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_ptr_record", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_ptr_record{Azurerm_dns_ptr_record_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_ptr_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_ptr_recordHandler) Read(externalID string) (*Azurerm_dns_ptr_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_ptr_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_ptr_record", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_ptr_record{Azurerm_dns_ptr_record_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_ptr_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_ptr_recordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_ptr_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_ptr_record", externalID)
}

type Azurerm_dns_srv_record_record_89 struct {
	Port int

	Priority int

	Target string

	Weight int
}

type Azurerm_dns_srv_record struct {
	Azurerm_dns_srv_record_id *string `lyra:"ignore"`

	Name string

	Record []Azurerm_dns_srv_record_record_89

	Resource_group_name string

	Tags *map[string]string

	Ttl int

	Zone_name string
}

var Azurerm_dns_srv_record_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_srv_record_id",

		"tags",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",
	)
}

// Azurerm_dns_srv_recordHandler ...
type Azurerm_dns_srv_recordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_srv_recordHandler) Create(desired *Azurerm_dns_srv_record) (*Azurerm_dns_srv_record, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_srv_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_srv_record", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_srv_recordHandler) Update(externalID string, desired *Azurerm_dns_srv_record) (*Azurerm_dns_srv_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_srv_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_srv_record", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_srv_record{Azurerm_dns_srv_record_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_srv_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_srv_recordHandler) Read(externalID string) (*Azurerm_dns_srv_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_srv_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_srv_record", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_srv_record{Azurerm_dns_srv_record_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_srv_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_srv_recordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_srv_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_srv_record", externalID)
}

type Azurerm_dns_txt_record_record_90 struct {
	Value string
}

type Azurerm_dns_txt_record struct {
	Azurerm_dns_txt_record_id *string `lyra:"ignore"`

	Name string

	Record []Azurerm_dns_txt_record_record_90

	Resource_group_name string

	Tags *map[string]string

	Ttl int

	Zone_name string
}

var Azurerm_dns_txt_record_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_txt_record_id",

		"tags",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",
	)
}

// Azurerm_dns_txt_recordHandler ...
type Azurerm_dns_txt_recordHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_txt_recordHandler) Create(desired *Azurerm_dns_txt_record) (*Azurerm_dns_txt_record, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_txt_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_txt_record", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_txt_recordHandler) Update(externalID string, desired *Azurerm_dns_txt_record) (*Azurerm_dns_txt_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_txt_record", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_txt_record", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_txt_record{Azurerm_dns_txt_record_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_txt_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_txt_recordHandler) Read(externalID string) (*Azurerm_dns_txt_record, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_txt_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_txt_record", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_txt_record{Azurerm_dns_txt_record_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_txt_record", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_txt_recordHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_txt_record", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_txt_record", externalID)
}

type Azurerm_dns_zone struct {
	Azurerm_dns_zone_id *string `lyra:"ignore"`

	Max_number_of_record_sets *int

	Name string

	Name_servers *[]string

	Number_of_record_sets *int

	Registration_virtual_network_ids *[]string

	Resolution_virtual_network_ids *[]string

	Resource_group_name string

	Tags *map[string]string

	Zone_type *string
}

var Azurerm_dns_zone_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_dns_zone_id",

		"max_number_of_record_sets",

		"name_servers",

		"number_of_record_sets",

		"registration_virtual_network_ids",

		"resolution_virtual_network_ids",

		"tags",

		"zone_type",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",
	)
}

// Azurerm_dns_zoneHandler ...
type Azurerm_dns_zoneHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_dns_zoneHandler) Create(desired *Azurerm_dns_zone) (*Azurerm_dns_zone, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_dns_zone", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_dns_zone", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_dns_zoneHandler) Update(externalID string, desired *Azurerm_dns_zone) (*Azurerm_dns_zone, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_dns_zone", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_dns_zone", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_zone{Azurerm_dns_zone_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_dns_zone", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_dns_zoneHandler) Read(externalID string) (*Azurerm_dns_zone, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_dns_zone", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_dns_zone", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_dns_zone{Azurerm_dns_zone_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_dns_zone", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_dns_zoneHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_dns_zone", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_dns_zone", externalID)
}

type Azurerm_eventgrid_topic struct {
	Azurerm_eventgrid_topic_id *string `lyra:"ignore"`

	Endpoint *string

	Location string

	Name string

	Primary_access_key *string

	Resource_group_name string

	Secondary_access_key *string

	Tags *map[string]string
}

var Azurerm_eventgrid_topic_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_eventgrid_topic_id",

		"endpoint",

		"primary_access_key",

		"secondary_access_key",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_eventgrid_topicHandler ...
type Azurerm_eventgrid_topicHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_eventgrid_topicHandler) Create(desired *Azurerm_eventgrid_topic) (*Azurerm_eventgrid_topic, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_eventgrid_topic", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_eventgrid_topic", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_eventgrid_topicHandler) Update(externalID string, desired *Azurerm_eventgrid_topic) (*Azurerm_eventgrid_topic, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_eventgrid_topic", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_eventgrid_topic", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventgrid_topic{Azurerm_eventgrid_topic_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_eventgrid_topic", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_eventgrid_topicHandler) Read(externalID string) (*Azurerm_eventgrid_topic, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_eventgrid_topic", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_eventgrid_topic", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventgrid_topic{Azurerm_eventgrid_topic_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_eventgrid_topic", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_eventgrid_topicHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_eventgrid_topic", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_eventgrid_topic", externalID)
}

type Azurerm_eventhub_capture_description_91_destination_92 struct {
	Archive_name_format string

	Blob_container_name string

	Name string

	Storage_account_id string
}

type Azurerm_eventhub_capture_description_91 struct {
	Destination []Azurerm_eventhub_capture_description_91_destination_92

	Enabled bool

	Encoding string

	Interval_in_seconds *int

	Size_limit_in_bytes *int
}

type Azurerm_eventhub struct {
	Azurerm_eventhub_id *string `lyra:"ignore"`

	Capture_description *[]Azurerm_eventhub_capture_description_91

	Location *string

	Message_retention int

	Name string

	Namespace_name string

	Partition_count int

	Partition_ids *[]string

	Resource_group_name string
}

var Azurerm_eventhub_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_eventhub_id",

		"capture_description",

		"location",

		"partition_ids",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"namespace_name",

		"partition_count",

		"resource_group_name",
	)
}

// Azurerm_eventhubHandler ...
type Azurerm_eventhubHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_eventhubHandler) Create(desired *Azurerm_eventhub) (*Azurerm_eventhub, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_eventhub", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_eventhub", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_eventhubHandler) Update(externalID string, desired *Azurerm_eventhub) (*Azurerm_eventhub, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_eventhub", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_eventhub", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub{Azurerm_eventhub_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_eventhub", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_eventhubHandler) Read(externalID string) (*Azurerm_eventhub, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_eventhub", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_eventhub", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub{Azurerm_eventhub_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_eventhub", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_eventhubHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_eventhub", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_eventhub", externalID)
}

type Azurerm_eventhub_authorization_rule struct {
	Azurerm_eventhub_authorization_rule_id *string `lyra:"ignore"`

	Eventhub_name string

	Listen *bool

	Location *string

	Manage *bool

	Name string

	Namespace_name string

	Primary_connection_string *string

	Primary_key *string

	Resource_group_name string

	Secondary_connection_string *string

	Secondary_key *string

	Send *bool
}

var Azurerm_eventhub_authorization_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_eventhub_authorization_rule_id",

		"listen",

		"location",

		"manage",

		"primary_connection_string",

		"primary_key",

		"secondary_connection_string",

		"secondary_key",

		"send",
	)
	rtb.ImmutableAttributes(

		"eventhub_name",

		"location",

		"name",

		"namespace_name",

		"resource_group_name",
	)
}

// Azurerm_eventhub_authorization_ruleHandler ...
type Azurerm_eventhub_authorization_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_eventhub_authorization_ruleHandler) Create(desired *Azurerm_eventhub_authorization_rule) (*Azurerm_eventhub_authorization_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_eventhub_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_eventhub_authorization_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_eventhub_authorization_ruleHandler) Update(externalID string, desired *Azurerm_eventhub_authorization_rule) (*Azurerm_eventhub_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_eventhub_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_eventhub_authorization_rule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub_authorization_rule{Azurerm_eventhub_authorization_rule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_eventhub_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_eventhub_authorization_ruleHandler) Read(externalID string) (*Azurerm_eventhub_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_eventhub_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_eventhub_authorization_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub_authorization_rule{Azurerm_eventhub_authorization_rule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_eventhub_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_eventhub_authorization_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_eventhub_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_eventhub_authorization_rule", externalID)
}

type Azurerm_eventhub_consumer_group struct {
	Azurerm_eventhub_consumer_group_id *string `lyra:"ignore"`

	Eventhub_name string

	Location *string

	Name string

	Namespace_name string

	Resource_group_name string

	User_metadata *string
}

var Azurerm_eventhub_consumer_group_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_eventhub_consumer_group_id",

		"location",

		"user_metadata",
	)
	rtb.ImmutableAttributes(

		"eventhub_name",

		"location",

		"name",

		"namespace_name",

		"resource_group_name",
	)
}

// Azurerm_eventhub_consumer_groupHandler ...
type Azurerm_eventhub_consumer_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_eventhub_consumer_groupHandler) Create(desired *Azurerm_eventhub_consumer_group) (*Azurerm_eventhub_consumer_group, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_eventhub_consumer_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_eventhub_consumer_group", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_eventhub_consumer_groupHandler) Update(externalID string, desired *Azurerm_eventhub_consumer_group) (*Azurerm_eventhub_consumer_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_eventhub_consumer_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_eventhub_consumer_group", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub_consumer_group{Azurerm_eventhub_consumer_group_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_eventhub_consumer_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_eventhub_consumer_groupHandler) Read(externalID string) (*Azurerm_eventhub_consumer_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_eventhub_consumer_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_eventhub_consumer_group", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub_consumer_group{Azurerm_eventhub_consumer_group_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_eventhub_consumer_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_eventhub_consumer_groupHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_eventhub_consumer_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_eventhub_consumer_group", externalID)
}

type Azurerm_eventhub_namespace struct {
	Azurerm_eventhub_namespace_id *string `lyra:"ignore"`

	Auto_inflate_enabled *bool

	Capacity *int

	Default_primary_connection_string *string

	Default_primary_key *string

	Default_secondary_connection_string *string

	Default_secondary_key *string

	Kafka_enabled *bool

	Location string

	Maximum_throughput_units *int

	Name string

	Resource_group_name string

	Sku string

	Tags *map[string]string
}

var Azurerm_eventhub_namespace_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_eventhub_namespace_id",

		"auto_inflate_enabled",

		"capacity",

		"default_primary_connection_string",

		"default_primary_key",

		"default_secondary_connection_string",

		"default_secondary_key",

		"kafka_enabled",

		"maximum_throughput_units",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_eventhub_namespaceHandler ...
type Azurerm_eventhub_namespaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_eventhub_namespaceHandler) Create(desired *Azurerm_eventhub_namespace) (*Azurerm_eventhub_namespace, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_eventhub_namespace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_eventhub_namespace", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_eventhub_namespaceHandler) Update(externalID string, desired *Azurerm_eventhub_namespace) (*Azurerm_eventhub_namespace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_eventhub_namespace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_eventhub_namespace", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub_namespace{Azurerm_eventhub_namespace_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_eventhub_namespace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_eventhub_namespaceHandler) Read(externalID string) (*Azurerm_eventhub_namespace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_eventhub_namespace", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_eventhub_namespace", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub_namespace{Azurerm_eventhub_namespace_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_eventhub_namespace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_eventhub_namespaceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_eventhub_namespace", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_eventhub_namespace", externalID)
}

type Azurerm_eventhub_namespace_authorization_rule struct {
	Azurerm_eventhub_namespace_authorization_rule_id *string `lyra:"ignore"`

	Listen *bool

	Location *string

	Manage *bool

	Name string

	Namespace_name string

	Primary_connection_string *string

	Primary_key *string

	Resource_group_name string

	Secondary_connection_string *string

	Secondary_key *string

	Send *bool
}

var Azurerm_eventhub_namespace_authorization_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_eventhub_namespace_authorization_rule_id",

		"listen",

		"location",

		"manage",

		"primary_connection_string",

		"primary_key",

		"secondary_connection_string",

		"secondary_key",

		"send",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"namespace_name",

		"resource_group_name",
	)
}

// Azurerm_eventhub_namespace_authorization_ruleHandler ...
type Azurerm_eventhub_namespace_authorization_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_eventhub_namespace_authorization_ruleHandler) Create(desired *Azurerm_eventhub_namespace_authorization_rule) (*Azurerm_eventhub_namespace_authorization_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_eventhub_namespace_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_eventhub_namespace_authorization_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_eventhub_namespace_authorization_ruleHandler) Update(externalID string, desired *Azurerm_eventhub_namespace_authorization_rule) (*Azurerm_eventhub_namespace_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_eventhub_namespace_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_eventhub_namespace_authorization_rule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub_namespace_authorization_rule{Azurerm_eventhub_namespace_authorization_rule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_eventhub_namespace_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_eventhub_namespace_authorization_ruleHandler) Read(externalID string) (*Azurerm_eventhub_namespace_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_eventhub_namespace_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_eventhub_namespace_authorization_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_eventhub_namespace_authorization_rule{Azurerm_eventhub_namespace_authorization_rule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_eventhub_namespace_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_eventhub_namespace_authorization_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_eventhub_namespace_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_eventhub_namespace_authorization_rule", externalID)
}

type Azurerm_express_route_circuit_sku_93 struct {
	Family string

	Tier string
}

type Azurerm_express_route_circuit struct {
	Azurerm_express_route_circuit_id *string `lyra:"ignore"`

	Allow_classic_operations *bool

	Bandwidth_in_mbps int

	Location string

	Name string

	Peering_location string

	Resource_group_name string

	Service_key *string

	Service_provider_name string

	Service_provider_provisioning_state *string

	Sku []Azurerm_express_route_circuit_sku_93

	Tags *map[string]string
}

var Azurerm_express_route_circuit_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_express_route_circuit_id",

		"allow_classic_operations",

		"service_key",

		"service_provider_provisioning_state",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"peering_location",

		"resource_group_name",

		"service_provider_name",
	)
}

// Azurerm_express_route_circuitHandler ...
type Azurerm_express_route_circuitHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_express_route_circuitHandler) Create(desired *Azurerm_express_route_circuit) (*Azurerm_express_route_circuit, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_express_route_circuit", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_express_route_circuit", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_express_route_circuitHandler) Update(externalID string, desired *Azurerm_express_route_circuit) (*Azurerm_express_route_circuit, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_express_route_circuit", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_express_route_circuit", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_express_route_circuit{Azurerm_express_route_circuit_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_express_route_circuit", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_express_route_circuitHandler) Read(externalID string) (*Azurerm_express_route_circuit, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_express_route_circuit", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_express_route_circuit", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_express_route_circuit{Azurerm_express_route_circuit_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_express_route_circuit", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_express_route_circuitHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_express_route_circuit", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_express_route_circuit", externalID)
}

type Azurerm_express_route_circuit_authorization struct {
	Azurerm_express_route_circuit_authorization_id *string `lyra:"ignore"`

	Authorization_key *string

	Authorization_use_status *string

	Express_route_circuit_name string

	Name string

	Resource_group_name string
}

var Azurerm_express_route_circuit_authorization_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_express_route_circuit_authorization_id",

		"authorization_key",

		"authorization_use_status",
	)
	rtb.ImmutableAttributes(

		"express_route_circuit_name",

		"name",

		"resource_group_name",
	)
}

// Azurerm_express_route_circuit_authorizationHandler ...
type Azurerm_express_route_circuit_authorizationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_express_route_circuit_authorizationHandler) Create(desired *Azurerm_express_route_circuit_authorization) (*Azurerm_express_route_circuit_authorization, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_express_route_circuit_authorization", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_express_route_circuit_authorization", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_express_route_circuit_authorizationHandler) Update(externalID string, desired *Azurerm_express_route_circuit_authorization) (*Azurerm_express_route_circuit_authorization, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_express_route_circuit_authorization", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_express_route_circuit_authorization", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_express_route_circuit_authorization{Azurerm_express_route_circuit_authorization_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_express_route_circuit_authorization", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_express_route_circuit_authorizationHandler) Read(externalID string) (*Azurerm_express_route_circuit_authorization, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_express_route_circuit_authorization", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_express_route_circuit_authorization", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_express_route_circuit_authorization{Azurerm_express_route_circuit_authorization_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_express_route_circuit_authorization", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_express_route_circuit_authorizationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_express_route_circuit_authorization", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_express_route_circuit_authorization", externalID)
}

type Azurerm_express_route_circuit_peering_microsoft_peering_config_94 struct {
	Advertised_public_prefixes []string
}

type Azurerm_express_route_circuit_peering struct {
	Azurerm_express_route_circuit_peering_id *string `lyra:"ignore"`

	Azure_asn *int

	Express_route_circuit_name string

	Microsoft_peering_config *[]Azurerm_express_route_circuit_peering_microsoft_peering_config_94

	Peer_asn *int

	Peering_type string

	Primary_azure_port *string

	Primary_peer_address_prefix string

	Resource_group_name string

	Secondary_azure_port *string

	Secondary_peer_address_prefix string

	Shared_key *string

	Vlan_id int
}

var Azurerm_express_route_circuit_peering_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_express_route_circuit_peering_id",

		"azure_asn",

		"microsoft_peering_config",

		"peer_asn",

		"primary_azure_port",

		"secondary_azure_port",

		"shared_key",
	)
	rtb.ImmutableAttributes(

		"express_route_circuit_name",

		"resource_group_name",
	)
}

// Azurerm_express_route_circuit_peeringHandler ...
type Azurerm_express_route_circuit_peeringHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_express_route_circuit_peeringHandler) Create(desired *Azurerm_express_route_circuit_peering) (*Azurerm_express_route_circuit_peering, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_express_route_circuit_peering", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_express_route_circuit_peering", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_express_route_circuit_peeringHandler) Update(externalID string, desired *Azurerm_express_route_circuit_peering) (*Azurerm_express_route_circuit_peering, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_express_route_circuit_peering", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_express_route_circuit_peering", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_express_route_circuit_peering{Azurerm_express_route_circuit_peering_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_express_route_circuit_peering", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_express_route_circuit_peeringHandler) Read(externalID string) (*Azurerm_express_route_circuit_peering, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_express_route_circuit_peering", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_express_route_circuit_peering", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_express_route_circuit_peering{Azurerm_express_route_circuit_peering_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_express_route_circuit_peering", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_express_route_circuit_peeringHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_express_route_circuit_peering", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_express_route_circuit_peering", externalID)
}

type Azurerm_firewall_ip_configuration_95 struct {
	Internal_public_ip_address_id *string

	Name string

	Private_ip_address *string

	Public_ip_address_id *string

	Subnet_id string
}

type Azurerm_firewall struct {
	Azurerm_firewall_id *string `lyra:"ignore"`

	Ip_configuration []Azurerm_firewall_ip_configuration_95

	Location string

	Name string

	Resource_group_name string

	Tags *map[string]string
}

var Azurerm_firewall_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_firewall_id",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_firewallHandler ...
type Azurerm_firewallHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_firewallHandler) Create(desired *Azurerm_firewall) (*Azurerm_firewall, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_firewall", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_firewall", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_firewallHandler) Update(externalID string, desired *Azurerm_firewall) (*Azurerm_firewall, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_firewall", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_firewall", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_firewall{Azurerm_firewall_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_firewall", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_firewallHandler) Read(externalID string) (*Azurerm_firewall, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_firewall", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_firewall", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_firewall{Azurerm_firewall_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_firewall", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_firewallHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_firewall", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_firewall", externalID)
}

type Azurerm_firewall_application_rule_collection_rule_96_protocol_97 struct {
	Port *int

	Type string
}

type Azurerm_firewall_application_rule_collection_rule_96 struct {
	Description *string

	Fqdn_tags *[]string

	Name string

	Protocol *[]Azurerm_firewall_application_rule_collection_rule_96_protocol_97

	Source_addresses []string

	Target_fqdns *[]string
}

type Azurerm_firewall_application_rule_collection struct {
	Azurerm_firewall_application_rule_collection_id *string `lyra:"ignore"`

	Action string

	Azure_firewall_name string

	Name string

	Priority int

	Resource_group_name string

	Rule []Azurerm_firewall_application_rule_collection_rule_96
}

var Azurerm_firewall_application_rule_collection_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_firewall_application_rule_collection_id",
	)
	rtb.ImmutableAttributes(

		"azure_firewall_name",

		"name",

		"resource_group_name",
	)
}

// Azurerm_firewall_application_rule_collectionHandler ...
type Azurerm_firewall_application_rule_collectionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_firewall_application_rule_collectionHandler) Create(desired *Azurerm_firewall_application_rule_collection) (*Azurerm_firewall_application_rule_collection, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_firewall_application_rule_collection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_firewall_application_rule_collection", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_firewall_application_rule_collectionHandler) Update(externalID string, desired *Azurerm_firewall_application_rule_collection) (*Azurerm_firewall_application_rule_collection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_firewall_application_rule_collection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_firewall_application_rule_collection", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_firewall_application_rule_collection{Azurerm_firewall_application_rule_collection_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_firewall_application_rule_collection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_firewall_application_rule_collectionHandler) Read(externalID string) (*Azurerm_firewall_application_rule_collection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_firewall_application_rule_collection", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_firewall_application_rule_collection", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_firewall_application_rule_collection{Azurerm_firewall_application_rule_collection_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_firewall_application_rule_collection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_firewall_application_rule_collectionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_firewall_application_rule_collection", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_firewall_application_rule_collection", externalID)
}

type Azurerm_firewall_network_rule_collection_rule_98 struct {
	Description *string

	Destination_addresses []string

	Destination_ports []string

	Name string

	Protocols []string

	Source_addresses []string
}

type Azurerm_firewall_network_rule_collection struct {
	Azurerm_firewall_network_rule_collection_id *string `lyra:"ignore"`

	Action string

	Azure_firewall_name string

	Name string

	Priority int

	Resource_group_name string

	Rule []Azurerm_firewall_network_rule_collection_rule_98
}

var Azurerm_firewall_network_rule_collection_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_firewall_network_rule_collection_id",
	)
	rtb.ImmutableAttributes(

		"azure_firewall_name",

		"name",

		"resource_group_name",
	)
}

// Azurerm_firewall_network_rule_collectionHandler ...
type Azurerm_firewall_network_rule_collectionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_firewall_network_rule_collectionHandler) Create(desired *Azurerm_firewall_network_rule_collection) (*Azurerm_firewall_network_rule_collection, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_firewall_network_rule_collection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_firewall_network_rule_collection", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_firewall_network_rule_collectionHandler) Update(externalID string, desired *Azurerm_firewall_network_rule_collection) (*Azurerm_firewall_network_rule_collection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_firewall_network_rule_collection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_firewall_network_rule_collection", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_firewall_network_rule_collection{Azurerm_firewall_network_rule_collection_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_firewall_network_rule_collection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_firewall_network_rule_collectionHandler) Read(externalID string) (*Azurerm_firewall_network_rule_collection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_firewall_network_rule_collection", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_firewall_network_rule_collection", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_firewall_network_rule_collection{Azurerm_firewall_network_rule_collection_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_firewall_network_rule_collection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_firewall_network_rule_collectionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_firewall_network_rule_collection", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_firewall_network_rule_collection", externalID)
}

type Azurerm_function_app_connection_string_99 struct {
	Name string

	Type string

	Value string
}

type Azurerm_function_app_identity_100 struct {
	Principal_id *string

	Tenant_id *string

	Type string
}

type Azurerm_function_app_site_config_101 struct {
	Always_on *bool

	Use_32_bit_worker_process *bool

	Websockets_enabled *bool
}

type Azurerm_function_app_site_credential_102 struct {
	Password *string

	Username *string
}

type Azurerm_function_app struct {
	Azurerm_function_app_id *string `lyra:"ignore"`

	App_service_plan_id string

	App_settings *map[string]string

	Client_affinity_enabled *bool

	Connection_string *[]Azurerm_function_app_connection_string_99

	Default_hostname *string

	Enable_builtin_logging *bool

	Enabled *bool

	Https_only *bool

	Identity *[]Azurerm_function_app_identity_100

	Location string

	Name string

	Outbound_ip_addresses *string

	Resource_group_name string

	Site_config *[]Azurerm_function_app_site_config_101

	Site_credential *[]Azurerm_function_app_site_credential_102

	Storage_connection_string string

	Tags *map[string]string

	Version *string
}

var Azurerm_function_app_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_function_app_id",

		"app_settings",

		"client_affinity_enabled",

		"connection_string",

		"default_hostname",

		"enable_builtin_logging",

		"enabled",

		"https_only",

		"identity",

		"outbound_ip_addresses",

		"site_config",

		"site_credential",

		"tags",

		"version",
	)
	rtb.ImmutableAttributes(

		"app_service_plan_id",

		"location",

		"name",

		"resource_group_name",

		"storage_connection_string",
	)
}

// Azurerm_function_appHandler ...
type Azurerm_function_appHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_function_appHandler) Create(desired *Azurerm_function_app) (*Azurerm_function_app, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_function_app", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_function_app", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_function_appHandler) Update(externalID string, desired *Azurerm_function_app) (*Azurerm_function_app, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_function_app", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_function_app", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_function_app{Azurerm_function_app_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_function_app", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_function_appHandler) Read(externalID string) (*Azurerm_function_app, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_function_app", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_function_app", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_function_app{Azurerm_function_app_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_function_app", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_function_appHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_function_app", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_function_app", externalID)
}

type Azurerm_image_data_disk_103 struct {
	Blob_uri *string

	Caching *string

	Lun *int

	Managed_disk_id *string

	Size_gb *int
}

type Azurerm_image_os_disk_104 struct {
	Blob_uri *string

	Caching *string

	Managed_disk_id *string

	Os_state *string

	Os_type *string

	Size_gb *int
}

type Azurerm_image struct {
	Azurerm_image_id *string `lyra:"ignore"`

	Data_disk *[]Azurerm_image_data_disk_103

	Location string

	Name string

	Os_disk *[]Azurerm_image_os_disk_104

	Resource_group_name string

	Source_virtual_machine_id *string

	Tags *map[string]string
}

var Azurerm_image_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_image_id",

		"data_disk",

		"os_disk",

		"source_virtual_machine_id",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"os_disk",

		"resource_group_name",
	)
}

// Azurerm_imageHandler ...
type Azurerm_imageHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_imageHandler) Create(desired *Azurerm_image) (*Azurerm_image, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_image", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_image", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_imageHandler) Update(externalID string, desired *Azurerm_image) (*Azurerm_image, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_image", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_image", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_image{Azurerm_image_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_image", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_imageHandler) Read(externalID string) (*Azurerm_image, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_image", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_image", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_image{Azurerm_image_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_image", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_imageHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_image", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_image", externalID)
}

type Azurerm_iothub_endpoint_105 struct {
	Batch_frequency_in_seconds *int

	Connection_string string

	Container_name *string

	Encoding *string

	File_name_format *string

	Max_chunk_size_in_bytes *int

	Name string

	Type string
}

type Azurerm_iothub_route_106 struct {
	Condition *string

	Enabled bool

	Endpoint_names []string

	Name string

	Source string
}

type Azurerm_iothub_shared_access_policy_107 struct {
	Key_name *string

	Permissions *string

	Primary_key *string

	Secondary_key *string
}

type Azurerm_iothub_sku_108 struct {
	Capacity int

	Name string

	Tier string
}

type Azurerm_iothub struct {
	Azurerm_iothub_id *string `lyra:"ignore"`

	Endpoint *[]Azurerm_iothub_endpoint_105

	Event_hub_events_endpoint *string

	Event_hub_events_path *string

	Event_hub_operations_endpoint *string

	Event_hub_operations_path *string

	Hostname *string

	Location string

	Name string

	Resource_group_name string

	Route *[]Azurerm_iothub_route_106

	Shared_access_policy *[]Azurerm_iothub_shared_access_policy_107

	Sku []Azurerm_iothub_sku_108

	Tags *map[string]string

	Type *string
}

var Azurerm_iothub_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_iothub_id",

		"endpoint",

		"event_hub_events_endpoint",

		"event_hub_events_path",

		"event_hub_operations_endpoint",

		"event_hub_operations_path",

		"hostname",

		"route",

		"shared_access_policy",

		"tags",

		"type",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_iothubHandler ...
type Azurerm_iothubHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_iothubHandler) Create(desired *Azurerm_iothub) (*Azurerm_iothub, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_iothub", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_iothub", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_iothubHandler) Update(externalID string, desired *Azurerm_iothub) (*Azurerm_iothub, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_iothub", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_iothub", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_iothub{Azurerm_iothub_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_iothub", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_iothubHandler) Read(externalID string) (*Azurerm_iothub, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_iothub", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_iothub", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_iothub{Azurerm_iothub_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_iothub", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_iothubHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_iothub", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_iothub", externalID)
}

type Azurerm_iothub_consumer_group struct {
	Azurerm_iothub_consumer_group_id *string `lyra:"ignore"`

	Eventhub_endpoint_name string

	Iothub_name string

	Name string

	Resource_group_name string
}

var Azurerm_iothub_consumer_group_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_iothub_consumer_group_id",
	)
	rtb.ImmutableAttributes(

		"eventhub_endpoint_name",

		"iothub_name",

		"name",

		"resource_group_name",
	)
}

// Azurerm_iothub_consumer_groupHandler ...
type Azurerm_iothub_consumer_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_iothub_consumer_groupHandler) Create(desired *Azurerm_iothub_consumer_group) (*Azurerm_iothub_consumer_group, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_iothub_consumer_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_iothub_consumer_group", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_iothub_consumer_groupHandler) Update(externalID string, desired *Azurerm_iothub_consumer_group) (*Azurerm_iothub_consumer_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_iothub_consumer_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_iothub_consumer_group", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_iothub_consumer_group{Azurerm_iothub_consumer_group_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_iothub_consumer_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_iothub_consumer_groupHandler) Read(externalID string) (*Azurerm_iothub_consumer_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_iothub_consumer_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_iothub_consumer_group", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_iothub_consumer_group{Azurerm_iothub_consumer_group_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_iothub_consumer_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_iothub_consumer_groupHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_iothub_consumer_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_iothub_consumer_group", externalID)
}

type Azurerm_key_vault_access_policy_109 struct {
	Application_id *string

	Certificate_permissions *[]string

	Key_permissions *[]string

	Object_id string

	Secret_permissions *[]string

	Tenant_id string
}

type Azurerm_key_vault_network_acls_110 struct {
	Bypass string

	Default_action string

	Ip_rules *[]string

	Virtual_network_subnet_ids *[]string
}

type Azurerm_key_vault_sku_111 struct {
	Name string
}

type Azurerm_key_vault struct {
	Azurerm_key_vault_id *string `lyra:"ignore"`

	Access_policy *[]Azurerm_key_vault_access_policy_109

	Enabled_for_deployment *bool

	Enabled_for_disk_encryption *bool

	Enabled_for_template_deployment *bool

	Location string

	Name string

	Network_acls *[]Azurerm_key_vault_network_acls_110

	Resource_group_name string

	Sku []Azurerm_key_vault_sku_111

	Tags *map[string]string

	Tenant_id string

	Vault_uri *string
}

var Azurerm_key_vault_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_key_vault_id",

		"access_policy",

		"enabled_for_deployment",

		"enabled_for_disk_encryption",

		"enabled_for_template_deployment",

		"network_acls",

		"tags",

		"vault_uri",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_key_vaultHandler ...
type Azurerm_key_vaultHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_key_vaultHandler) Create(desired *Azurerm_key_vault) (*Azurerm_key_vault, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_key_vault", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_key_vault", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_key_vaultHandler) Update(externalID string, desired *Azurerm_key_vault) (*Azurerm_key_vault, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_key_vault", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_key_vault", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault{Azurerm_key_vault_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_key_vault", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_key_vaultHandler) Read(externalID string) (*Azurerm_key_vault, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_key_vault", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_key_vault", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault{Azurerm_key_vault_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_key_vault", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_key_vaultHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_key_vault", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_key_vault", externalID)
}

type Azurerm_key_vault_access_policy struct {
	Azurerm_key_vault_access_policy_id *string `lyra:"ignore"`

	Application_id *string

	Certificate_permissions *[]string

	Key_permissions *[]string

	Object_id string

	Resource_group_name string

	Secret_permissions *[]string

	Tenant_id string

	Vault_name string
}

var Azurerm_key_vault_access_policy_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_key_vault_access_policy_id",

		"application_id",

		"certificate_permissions",

		"key_permissions",

		"secret_permissions",
	)
	rtb.ImmutableAttributes(

		"application_id",

		"object_id",

		"resource_group_name",

		"tenant_id",

		"vault_name",
	)
}

// Azurerm_key_vault_access_policyHandler ...
type Azurerm_key_vault_access_policyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_key_vault_access_policyHandler) Create(desired *Azurerm_key_vault_access_policy) (*Azurerm_key_vault_access_policy, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_key_vault_access_policy", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_key_vault_access_policy", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_key_vault_access_policyHandler) Update(externalID string, desired *Azurerm_key_vault_access_policy) (*Azurerm_key_vault_access_policy, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_key_vault_access_policy", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_key_vault_access_policy", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault_access_policy{Azurerm_key_vault_access_policy_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_key_vault_access_policy", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_key_vault_access_policyHandler) Read(externalID string) (*Azurerm_key_vault_access_policy, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_key_vault_access_policy", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_key_vault_access_policy", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault_access_policy{Azurerm_key_vault_access_policy_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_key_vault_access_policy", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_key_vault_access_policyHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_key_vault_access_policy", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_key_vault_access_policy", externalID)
}

type Azurerm_key_vault_certificate_certificate_112 struct {
	Contents string

	Password *string
}

type Azurerm_key_vault_certificate_certificate_policy_113_issuer_parameters_114 struct {
	Name string
}

type Azurerm_key_vault_certificate_certificate_policy_113_key_properties_115 struct {
	Exportable bool

	Key_size int

	Key_type string

	Reuse_key bool
}

type Azurerm_key_vault_certificate_certificate_policy_113_lifetime_action_116_action_117 struct {
	Action_type string
}

type Azurerm_key_vault_certificate_certificate_policy_113_lifetime_action_116_trigger_118 struct {
	Days_before_expiry *int

	Lifetime_percentage *int
}

type Azurerm_key_vault_certificate_certificate_policy_113_lifetime_action_116 struct {
	Action []Azurerm_key_vault_certificate_certificate_policy_113_lifetime_action_116_action_117

	Trigger []Azurerm_key_vault_certificate_certificate_policy_113_lifetime_action_116_trigger_118
}

type Azurerm_key_vault_certificate_certificate_policy_113_secret_properties_119 struct {
	Content_type string
}

type Azurerm_key_vault_certificate_certificate_policy_113_x509_certificate_properties_120_subject_alternative_names_121 struct {
	Dns_names *[]string

	Emails *[]string

	Upns *[]string
}

type Azurerm_key_vault_certificate_certificate_policy_113_x509_certificate_properties_120 struct {
	Extended_key_usage *[]string

	Key_usage []string

	Subject string

	Subject_alternative_names *[]Azurerm_key_vault_certificate_certificate_policy_113_x509_certificate_properties_120_subject_alternative_names_121

	Validity_in_months int
}

type Azurerm_key_vault_certificate_certificate_policy_113 struct {
	Issuer_parameters []Azurerm_key_vault_certificate_certificate_policy_113_issuer_parameters_114

	Key_properties []Azurerm_key_vault_certificate_certificate_policy_113_key_properties_115

	Lifetime_action *[]Azurerm_key_vault_certificate_certificate_policy_113_lifetime_action_116

	Secret_properties []Azurerm_key_vault_certificate_certificate_policy_113_secret_properties_119

	X509_certificate_properties *[]Azurerm_key_vault_certificate_certificate_policy_113_x509_certificate_properties_120
}

type Azurerm_key_vault_certificate struct {
	Azurerm_key_vault_certificate_id *string `lyra:"ignore"`

	Certificate *[]Azurerm_key_vault_certificate_certificate_112

	Certificate_data *string

	Certificate_policy []Azurerm_key_vault_certificate_certificate_policy_113

	Name string

	Secret_id *string

	Tags *map[string]string

	Thumbprint *string

	Vault_uri string

	Version *string
}

var Azurerm_key_vault_certificate_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_key_vault_certificate_id",

		"certificate",

		"certificate_data",

		"secret_id",

		"tags",

		"thumbprint",

		"version",
	)
	rtb.ImmutableAttributes(

		"certificate",

		"certificate_policy",

		"name",

		"vault_uri",
	)
}

// Azurerm_key_vault_certificateHandler ...
type Azurerm_key_vault_certificateHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_key_vault_certificateHandler) Create(desired *Azurerm_key_vault_certificate) (*Azurerm_key_vault_certificate, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_key_vault_certificate", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_key_vault_certificate", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_key_vault_certificateHandler) Update(externalID string, desired *Azurerm_key_vault_certificate) (*Azurerm_key_vault_certificate, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_key_vault_certificate", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_key_vault_certificate", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault_certificate{Azurerm_key_vault_certificate_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_key_vault_certificate", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_key_vault_certificateHandler) Read(externalID string) (*Azurerm_key_vault_certificate, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_key_vault_certificate", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_key_vault_certificate", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault_certificate{Azurerm_key_vault_certificate_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_key_vault_certificate", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_key_vault_certificateHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_key_vault_certificate", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_key_vault_certificate", externalID)
}

type Azurerm_key_vault_key struct {
	Azurerm_key_vault_key_id *string `lyra:"ignore"`

	E *string

	Key_opts []string

	Key_size int

	Key_type string

	N *string

	Name string

	Tags *map[string]string

	Vault_uri string

	Version *string
}

var Azurerm_key_vault_key_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_key_vault_key_id",

		"e",

		"n",

		"tags",

		"version",
	)
	rtb.ImmutableAttributes(

		"key_size",

		"key_type",

		"name",

		"vault_uri",
	)
}

// Azurerm_key_vault_keyHandler ...
type Azurerm_key_vault_keyHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_key_vault_keyHandler) Create(desired *Azurerm_key_vault_key) (*Azurerm_key_vault_key, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_key_vault_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_key_vault_key", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_key_vault_keyHandler) Update(externalID string, desired *Azurerm_key_vault_key) (*Azurerm_key_vault_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_key_vault_key", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_key_vault_key", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault_key{Azurerm_key_vault_key_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_key_vault_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_key_vault_keyHandler) Read(externalID string) (*Azurerm_key_vault_key, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_key_vault_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_key_vault_key", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault_key{Azurerm_key_vault_key_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_key_vault_key", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_key_vault_keyHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_key_vault_key", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_key_vault_key", externalID)
}

type Azurerm_key_vault_secret struct {
	Azurerm_key_vault_secret_id *string `lyra:"ignore"`

	Content_type *string

	Name string

	Tags *map[string]string

	Value string

	Vault_uri string

	Version *string
}

var Azurerm_key_vault_secret_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_key_vault_secret_id",

		"content_type",

		"tags",

		"version",
	)
	rtb.ImmutableAttributes(

		"name",

		"vault_uri",
	)
}

// Azurerm_key_vault_secretHandler ...
type Azurerm_key_vault_secretHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_key_vault_secretHandler) Create(desired *Azurerm_key_vault_secret) (*Azurerm_key_vault_secret, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_key_vault_secret", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_key_vault_secret", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_key_vault_secretHandler) Update(externalID string, desired *Azurerm_key_vault_secret) (*Azurerm_key_vault_secret, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_key_vault_secret", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_key_vault_secret", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault_secret{Azurerm_key_vault_secret_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_key_vault_secret", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_key_vault_secretHandler) Read(externalID string) (*Azurerm_key_vault_secret, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_key_vault_secret", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_key_vault_secret", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_key_vault_secret{Azurerm_key_vault_secret_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_key_vault_secret", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_key_vault_secretHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_key_vault_secret", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_key_vault_secret", externalID)
}

type Azurerm_kubernetes_cluster_addon_profile_122_aci_connector_linux_123 struct {
	Enabled bool

	Subnet_name string
}

type Azurerm_kubernetes_cluster_addon_profile_122_http_application_routing_124 struct {
	Enabled bool

	Http_application_routing_zone_name *string
}

type Azurerm_kubernetes_cluster_addon_profile_122_oms_agent_125 struct {
	Enabled bool

	Log_analytics_workspace_id string
}

type Azurerm_kubernetes_cluster_addon_profile_122 struct {
	Aci_connector_linux *[]Azurerm_kubernetes_cluster_addon_profile_122_aci_connector_linux_123

	Http_application_routing *[]Azurerm_kubernetes_cluster_addon_profile_122_http_application_routing_124

	Oms_agent *[]Azurerm_kubernetes_cluster_addon_profile_122_oms_agent_125
}

type Azurerm_kubernetes_cluster_agent_pool_profile_126 struct {
	Count *int

	Dns_prefix *string

	Fqdn *string

	Max_pods *int

	Name string

	Os_disk_size_gb *int

	Os_type *string

	Vm_size string

	Vnet_subnet_id *string
}

type Azurerm_kubernetes_cluster_kube_admin_config_127 struct {
	Client_certificate *string

	Client_key *string

	Cluster_ca_certificate *string

	Host *string

	Password *string

	Username *string
}

type Azurerm_kubernetes_cluster_kube_config_128 struct {
	Client_certificate *string

	Client_key *string

	Cluster_ca_certificate *string

	Host *string

	Password *string

	Username *string
}

type Azurerm_kubernetes_cluster_linux_profile_129_ssh_key_130 struct {
	Key_data string
}

type Azurerm_kubernetes_cluster_linux_profile_129 struct {
	Admin_username string

	Ssh_key []Azurerm_kubernetes_cluster_linux_profile_129_ssh_key_130
}

type Azurerm_kubernetes_cluster_network_profile_131 struct {
	Dns_service_ip *string

	Docker_bridge_cidr *string

	Network_plugin string

	Pod_cidr *string

	Service_cidr *string
}

type Azurerm_kubernetes_cluster_role_based_access_control_132_azure_active_directory_133 struct {
	Client_app_id string

	Server_app_id string

	Server_app_secret string

	Tenant_id *string
}

type Azurerm_kubernetes_cluster_role_based_access_control_132 struct {
	Azure_active_directory *[]Azurerm_kubernetes_cluster_role_based_access_control_132_azure_active_directory_133

	Enabled bool
}

type Azurerm_kubernetes_cluster_service_principal_134 struct {
	Client_id string

	Client_secret string
}

type Azurerm_kubernetes_cluster struct {
	Azurerm_kubernetes_cluster_id *string `lyra:"ignore"`

	Addon_profile *[]Azurerm_kubernetes_cluster_addon_profile_122

	Agent_pool_profile []Azurerm_kubernetes_cluster_agent_pool_profile_126

	Dns_prefix string

	Fqdn *string

	Kube_admin_config *[]Azurerm_kubernetes_cluster_kube_admin_config_127

	Kube_admin_config_raw *string

	Kube_config *[]Azurerm_kubernetes_cluster_kube_config_128

	Kube_config_raw *string

	Kubernetes_version *string

	Linux_profile *[]Azurerm_kubernetes_cluster_linux_profile_129

	Location string

	Name string

	Network_profile *[]Azurerm_kubernetes_cluster_network_profile_131

	Node_resource_group *string

	Resource_group_name string

	Role_based_access_control *[]Azurerm_kubernetes_cluster_role_based_access_control_132

	Service_principal []Azurerm_kubernetes_cluster_service_principal_134

	Tags *map[string]string
}

var Azurerm_kubernetes_cluster_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_kubernetes_cluster_id",

		"addon_profile",

		"fqdn",

		"kube_admin_config",

		"kube_admin_config_raw",

		"kube_config",

		"kube_config_raw",

		"kubernetes_version",

		"linux_profile",

		"network_profile",

		"node_resource_group",

		"role_based_access_control",

		"tags",
	)
	rtb.ImmutableAttributes(

		"dns_prefix",

		"location",

		"name",

		"network_profile",

		"resource_group_name",

		"role_based_access_control",
	)
}

// Azurerm_kubernetes_clusterHandler ...
type Azurerm_kubernetes_clusterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_kubernetes_clusterHandler) Create(desired *Azurerm_kubernetes_cluster) (*Azurerm_kubernetes_cluster, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_kubernetes_cluster", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_kubernetes_cluster", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_kubernetes_clusterHandler) Update(externalID string, desired *Azurerm_kubernetes_cluster) (*Azurerm_kubernetes_cluster, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_kubernetes_cluster", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_kubernetes_cluster", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_kubernetes_cluster{Azurerm_kubernetes_cluster_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_kubernetes_cluster", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_kubernetes_clusterHandler) Read(externalID string) (*Azurerm_kubernetes_cluster, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_kubernetes_cluster", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_kubernetes_cluster", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_kubernetes_cluster{Azurerm_kubernetes_cluster_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_kubernetes_cluster", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_kubernetes_clusterHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_kubernetes_cluster", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_kubernetes_cluster", externalID)
}

type Azurerm_lb_frontend_ip_configuration_135 struct {
	Inbound_nat_rules *[]string

	Load_balancer_rules *[]string

	Name string

	Private_ip_address *string

	Private_ip_address_allocation *string

	Public_ip_address_id *string

	Subnet_id *string

	Zones *[]string
}

type Azurerm_lb struct {
	Azurerm_lb_id *string `lyra:"ignore"`

	Frontend_ip_configuration *[]Azurerm_lb_frontend_ip_configuration_135

	Location string

	Name string

	Private_ip_address *string

	Private_ip_addresses *[]string

	Resource_group_name string

	Sku *string

	Tags *map[string]string
}

var Azurerm_lb_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_lb_id",

		"frontend_ip_configuration",

		"private_ip_address",

		"private_ip_addresses",

		"sku",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"sku",
	)
}

// Azurerm_lbHandler ...
type Azurerm_lbHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_lbHandler) Create(desired *Azurerm_lb) (*Azurerm_lb, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_lb", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_lb", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_lbHandler) Update(externalID string, desired *Azurerm_lb) (*Azurerm_lb, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_lb", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_lb", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb{Azurerm_lb_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_lb", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_lbHandler) Read(externalID string) (*Azurerm_lb, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_lb", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_lb", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb{Azurerm_lb_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_lb", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_lbHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_lb", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_lb", externalID)
}

type Azurerm_lb_backend_address_pool struct {
	Azurerm_lb_backend_address_pool_id *string `lyra:"ignore"`

	Backend_ip_configurations *[]string

	Load_balancing_rules *[]string

	Loadbalancer_id string

	Location *string

	Name string

	Resource_group_name string
}

var Azurerm_lb_backend_address_pool_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_lb_backend_address_pool_id",

		"backend_ip_configurations",

		"load_balancing_rules",

		"location",
	)
	rtb.ImmutableAttributes(

		"loadbalancer_id",

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_lb_backend_address_poolHandler ...
type Azurerm_lb_backend_address_poolHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_lb_backend_address_poolHandler) Create(desired *Azurerm_lb_backend_address_pool) (*Azurerm_lb_backend_address_pool, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_lb_backend_address_pool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_lb_backend_address_pool", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_lb_backend_address_poolHandler) Update(externalID string, desired *Azurerm_lb_backend_address_pool) (*Azurerm_lb_backend_address_pool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_lb_backend_address_pool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_lb_backend_address_pool", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_backend_address_pool{Azurerm_lb_backend_address_pool_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_lb_backend_address_pool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_lb_backend_address_poolHandler) Read(externalID string) (*Azurerm_lb_backend_address_pool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_lb_backend_address_pool", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_lb_backend_address_pool", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_backend_address_pool{Azurerm_lb_backend_address_pool_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_lb_backend_address_pool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_lb_backend_address_poolHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_lb_backend_address_pool", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_lb_backend_address_pool", externalID)
}

type Azurerm_lb_nat_pool struct {
	Azurerm_lb_nat_pool_id *string `lyra:"ignore"`

	Backend_port int

	Frontend_ip_configuration_id *string

	Frontend_ip_configuration_name string

	Frontend_port_end int

	Frontend_port_start int

	Loadbalancer_id string

	Location *string

	Name string

	Protocol string

	Resource_group_name string
}

var Azurerm_lb_nat_pool_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_lb_nat_pool_id",

		"frontend_ip_configuration_id",

		"location",
	)
	rtb.ImmutableAttributes(

		"loadbalancer_id",

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_lb_nat_poolHandler ...
type Azurerm_lb_nat_poolHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_lb_nat_poolHandler) Create(desired *Azurerm_lb_nat_pool) (*Azurerm_lb_nat_pool, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_lb_nat_pool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_lb_nat_pool", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_lb_nat_poolHandler) Update(externalID string, desired *Azurerm_lb_nat_pool) (*Azurerm_lb_nat_pool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_lb_nat_pool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_lb_nat_pool", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_nat_pool{Azurerm_lb_nat_pool_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_lb_nat_pool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_lb_nat_poolHandler) Read(externalID string) (*Azurerm_lb_nat_pool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_lb_nat_pool", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_lb_nat_pool", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_nat_pool{Azurerm_lb_nat_pool_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_lb_nat_pool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_lb_nat_poolHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_lb_nat_pool", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_lb_nat_pool", externalID)
}

type Azurerm_lb_nat_rule struct {
	Azurerm_lb_nat_rule_id *string `lyra:"ignore"`

	Backend_ip_configuration_id *string

	Backend_port int

	Enable_floating_ip *bool

	Frontend_ip_configuration_id *string

	Frontend_ip_configuration_name string

	Frontend_port int

	Loadbalancer_id string

	Location *string

	Name string

	Protocol string

	Resource_group_name string
}

var Azurerm_lb_nat_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_lb_nat_rule_id",

		"backend_ip_configuration_id",

		"enable_floating_ip",

		"frontend_ip_configuration_id",

		"location",
	)
	rtb.ImmutableAttributes(

		"loadbalancer_id",

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_lb_nat_ruleHandler ...
type Azurerm_lb_nat_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_lb_nat_ruleHandler) Create(desired *Azurerm_lb_nat_rule) (*Azurerm_lb_nat_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_lb_nat_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_lb_nat_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_lb_nat_ruleHandler) Update(externalID string, desired *Azurerm_lb_nat_rule) (*Azurerm_lb_nat_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_lb_nat_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_lb_nat_rule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_nat_rule{Azurerm_lb_nat_rule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_lb_nat_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_lb_nat_ruleHandler) Read(externalID string) (*Azurerm_lb_nat_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_lb_nat_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_lb_nat_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_nat_rule{Azurerm_lb_nat_rule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_lb_nat_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_lb_nat_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_lb_nat_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_lb_nat_rule", externalID)
}

type Azurerm_lb_probe struct {
	Azurerm_lb_probe_id *string `lyra:"ignore"`

	Interval_in_seconds *int

	Load_balancer_rules *[]string

	Loadbalancer_id string

	Location *string

	Name string

	Number_of_probes *int

	Port int

	Protocol *string

	Request_path *string

	Resource_group_name string
}

var Azurerm_lb_probe_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_lb_probe_id",

		"interval_in_seconds",

		"load_balancer_rules",

		"location",

		"number_of_probes",

		"protocol",

		"request_path",
	)
	rtb.ImmutableAttributes(

		"loadbalancer_id",

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_lb_probeHandler ...
type Azurerm_lb_probeHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_lb_probeHandler) Create(desired *Azurerm_lb_probe) (*Azurerm_lb_probe, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_lb_probe", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_lb_probe", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_lb_probeHandler) Update(externalID string, desired *Azurerm_lb_probe) (*Azurerm_lb_probe, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_lb_probe", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_lb_probe", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_probe{Azurerm_lb_probe_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_lb_probe", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_lb_probeHandler) Read(externalID string) (*Azurerm_lb_probe, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_lb_probe", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_lb_probe", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_probe{Azurerm_lb_probe_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_lb_probe", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_lb_probeHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_lb_probe", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_lb_probe", externalID)
}

type Azurerm_lb_rule struct {
	Azurerm_lb_rule_id *string `lyra:"ignore"`

	Backend_address_pool_id *string

	Backend_port int

	Enable_floating_ip *bool

	Frontend_ip_configuration_id *string

	Frontend_ip_configuration_name string

	Frontend_port int

	Idle_timeout_in_minutes *int

	Load_distribution *string

	Loadbalancer_id string

	Location *string

	Name string

	Probe_id *string

	Protocol string

	Resource_group_name string
}

var Azurerm_lb_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_lb_rule_id",

		"backend_address_pool_id",

		"enable_floating_ip",

		"frontend_ip_configuration_id",

		"idle_timeout_in_minutes",

		"load_distribution",

		"location",

		"probe_id",
	)
	rtb.ImmutableAttributes(

		"loadbalancer_id",

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_lb_ruleHandler ...
type Azurerm_lb_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_lb_ruleHandler) Create(desired *Azurerm_lb_rule) (*Azurerm_lb_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_lb_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_lb_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_lb_ruleHandler) Update(externalID string, desired *Azurerm_lb_rule) (*Azurerm_lb_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_lb_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_lb_rule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_rule{Azurerm_lb_rule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_lb_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_lb_ruleHandler) Read(externalID string) (*Azurerm_lb_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_lb_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_lb_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_lb_rule{Azurerm_lb_rule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_lb_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_lb_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_lb_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_lb_rule", externalID)
}

type Azurerm_local_network_gateway_bgp_settings_136 struct {
	Asn int

	Bgp_peering_address string

	Peer_weight *int
}

type Azurerm_local_network_gateway struct {
	Azurerm_local_network_gateway_id *string `lyra:"ignore"`

	Address_space []string

	Bgp_settings *[]Azurerm_local_network_gateway_bgp_settings_136

	Gateway_address string

	Location string

	Name string

	Resource_group_name string

	Tags *map[string]string
}

var Azurerm_local_network_gateway_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_local_network_gateway_id",

		"bgp_settings",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_local_network_gatewayHandler ...
type Azurerm_local_network_gatewayHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_local_network_gatewayHandler) Create(desired *Azurerm_local_network_gateway) (*Azurerm_local_network_gateway, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_local_network_gateway", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_local_network_gateway", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_local_network_gatewayHandler) Update(externalID string, desired *Azurerm_local_network_gateway) (*Azurerm_local_network_gateway, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_local_network_gateway", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_local_network_gateway", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_local_network_gateway{Azurerm_local_network_gateway_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_local_network_gateway", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_local_network_gatewayHandler) Read(externalID string) (*Azurerm_local_network_gateway, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_local_network_gateway", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_local_network_gateway", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_local_network_gateway{Azurerm_local_network_gateway_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_local_network_gateway", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_local_network_gatewayHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_local_network_gateway", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_local_network_gateway", externalID)
}

type Azurerm_log_analytics_solution_plan_137 struct {
	Name *string

	Product string

	Promotion_code *string

	Publisher string
}

type Azurerm_log_analytics_solution struct {
	Azurerm_log_analytics_solution_id *string `lyra:"ignore"`

	Location string

	Plan []Azurerm_log_analytics_solution_plan_137

	Resource_group_name string

	Solution_name string

	Workspace_name string

	Workspace_resource_id string
}

var Azurerm_log_analytics_solution_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_log_analytics_solution_id",
	)
	rtb.ImmutableAttributes(

		"location",

		"resource_group_name",

		"solution_name",

		"workspace_name",

		"workspace_resource_id",
	)
}

// Azurerm_log_analytics_solutionHandler ...
type Azurerm_log_analytics_solutionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_log_analytics_solutionHandler) Create(desired *Azurerm_log_analytics_solution) (*Azurerm_log_analytics_solution, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_log_analytics_solution", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_log_analytics_solution", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_log_analytics_solutionHandler) Update(externalID string, desired *Azurerm_log_analytics_solution) (*Azurerm_log_analytics_solution, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_log_analytics_solution", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_log_analytics_solution", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_log_analytics_solution{Azurerm_log_analytics_solution_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_log_analytics_solution", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_log_analytics_solutionHandler) Read(externalID string) (*Azurerm_log_analytics_solution, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_log_analytics_solution", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_log_analytics_solution", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_log_analytics_solution{Azurerm_log_analytics_solution_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_log_analytics_solution", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_log_analytics_solutionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_log_analytics_solution", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_log_analytics_solution", externalID)
}

type Azurerm_log_analytics_workspace struct {
	Azurerm_log_analytics_workspace_id *string `lyra:"ignore"`

	Location string

	Name string

	Portal_url *string

	Primary_shared_key *string

	Resource_group_name string

	Retention_in_days *int

	Secondary_shared_key *string

	Sku string

	Tags *map[string]string

	Workspace_id *string
}

var Azurerm_log_analytics_workspace_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_log_analytics_workspace_id",

		"portal_url",

		"primary_shared_key",

		"retention_in_days",

		"secondary_shared_key",

		"tags",

		"workspace_id",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"sku",
	)
}

// Azurerm_log_analytics_workspaceHandler ...
type Azurerm_log_analytics_workspaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_log_analytics_workspaceHandler) Create(desired *Azurerm_log_analytics_workspace) (*Azurerm_log_analytics_workspace, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_log_analytics_workspace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_log_analytics_workspace", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_log_analytics_workspaceHandler) Update(externalID string, desired *Azurerm_log_analytics_workspace) (*Azurerm_log_analytics_workspace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_log_analytics_workspace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_log_analytics_workspace", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_log_analytics_workspace{Azurerm_log_analytics_workspace_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_log_analytics_workspace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_log_analytics_workspaceHandler) Read(externalID string) (*Azurerm_log_analytics_workspace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_log_analytics_workspace", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_log_analytics_workspace", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_log_analytics_workspace{Azurerm_log_analytics_workspace_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_log_analytics_workspace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_log_analytics_workspaceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_log_analytics_workspace", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_log_analytics_workspace", externalID)
}

type Azurerm_log_analytics_workspace_linked_service struct {
	Azurerm_log_analytics_workspace_linked_service_id *string `lyra:"ignore"`

	Linked_service_name *string

	Linked_service_properties map[string]string

	Name *string

	Resource_group_name string

	Tags *map[string]string

	Workspace_name string
}

var Azurerm_log_analytics_workspace_linked_service_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_log_analytics_workspace_linked_service_id",

		"linked_service_name",

		"name",

		"tags",
	)
	rtb.ImmutableAttributes(

		"linked_service_name",

		"linked_service_properties",

		"resource_group_name",

		"workspace_name",
	)
}

// Azurerm_log_analytics_workspace_linked_serviceHandler ...
type Azurerm_log_analytics_workspace_linked_serviceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_log_analytics_workspace_linked_serviceHandler) Create(desired *Azurerm_log_analytics_workspace_linked_service) (*Azurerm_log_analytics_workspace_linked_service, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_log_analytics_workspace_linked_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_log_analytics_workspace_linked_service", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_log_analytics_workspace_linked_serviceHandler) Update(externalID string, desired *Azurerm_log_analytics_workspace_linked_service) (*Azurerm_log_analytics_workspace_linked_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_log_analytics_workspace_linked_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_log_analytics_workspace_linked_service", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_log_analytics_workspace_linked_service{Azurerm_log_analytics_workspace_linked_service_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_log_analytics_workspace_linked_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_log_analytics_workspace_linked_serviceHandler) Read(externalID string) (*Azurerm_log_analytics_workspace_linked_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_log_analytics_workspace_linked_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_log_analytics_workspace_linked_service", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_log_analytics_workspace_linked_service{Azurerm_log_analytics_workspace_linked_service_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_log_analytics_workspace_linked_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_log_analytics_workspace_linked_serviceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_log_analytics_workspace_linked_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_log_analytics_workspace_linked_service", externalID)
}

type Azurerm_logic_app_action_custom struct {
	Azurerm_logic_app_action_custom_id *string `lyra:"ignore"`

	Body string

	Logic_app_id string

	Name string
}

var Azurerm_logic_app_action_custom_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_logic_app_action_custom_id",
	)
	rtb.ImmutableAttributes(

		"logic_app_id",

		"name",
	)
}

// Azurerm_logic_app_action_customHandler ...
type Azurerm_logic_app_action_customHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_logic_app_action_customHandler) Create(desired *Azurerm_logic_app_action_custom) (*Azurerm_logic_app_action_custom, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_logic_app_action_custom", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_logic_app_action_custom", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_logic_app_action_customHandler) Update(externalID string, desired *Azurerm_logic_app_action_custom) (*Azurerm_logic_app_action_custom, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_logic_app_action_custom", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_logic_app_action_custom", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_action_custom{Azurerm_logic_app_action_custom_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_logic_app_action_custom", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_logic_app_action_customHandler) Read(externalID string) (*Azurerm_logic_app_action_custom, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_logic_app_action_custom", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_logic_app_action_custom", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_action_custom{Azurerm_logic_app_action_custom_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_logic_app_action_custom", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_logic_app_action_customHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_logic_app_action_custom", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_logic_app_action_custom", externalID)
}

type Azurerm_logic_app_action_http struct {
	Azurerm_logic_app_action_http_id *string `lyra:"ignore"`

	Body *string

	Headers *map[string]string

	Logic_app_id string

	Method string

	Name string

	Uri string
}

var Azurerm_logic_app_action_http_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_logic_app_action_http_id",

		"body",

		"headers",
	)
	rtb.ImmutableAttributes(

		"logic_app_id",

		"name",
	)
}

// Azurerm_logic_app_action_httpHandler ...
type Azurerm_logic_app_action_httpHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_logic_app_action_httpHandler) Create(desired *Azurerm_logic_app_action_http) (*Azurerm_logic_app_action_http, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_logic_app_action_http", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_logic_app_action_http", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_logic_app_action_httpHandler) Update(externalID string, desired *Azurerm_logic_app_action_http) (*Azurerm_logic_app_action_http, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_logic_app_action_http", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_logic_app_action_http", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_action_http{Azurerm_logic_app_action_http_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_logic_app_action_http", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_logic_app_action_httpHandler) Read(externalID string) (*Azurerm_logic_app_action_http, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_logic_app_action_http", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_logic_app_action_http", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_action_http{Azurerm_logic_app_action_http_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_logic_app_action_http", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_logic_app_action_httpHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_logic_app_action_http", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_logic_app_action_http", externalID)
}

type Azurerm_logic_app_trigger_custom struct {
	Azurerm_logic_app_trigger_custom_id *string `lyra:"ignore"`

	Body string

	Logic_app_id string

	Name string
}

var Azurerm_logic_app_trigger_custom_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_logic_app_trigger_custom_id",
	)
	rtb.ImmutableAttributes(

		"logic_app_id",

		"name",
	)
}

// Azurerm_logic_app_trigger_customHandler ...
type Azurerm_logic_app_trigger_customHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_logic_app_trigger_customHandler) Create(desired *Azurerm_logic_app_trigger_custom) (*Azurerm_logic_app_trigger_custom, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_logic_app_trigger_custom", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_logic_app_trigger_custom", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_logic_app_trigger_customHandler) Update(externalID string, desired *Azurerm_logic_app_trigger_custom) (*Azurerm_logic_app_trigger_custom, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_logic_app_trigger_custom", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_logic_app_trigger_custom", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_trigger_custom{Azurerm_logic_app_trigger_custom_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_logic_app_trigger_custom", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_logic_app_trigger_customHandler) Read(externalID string) (*Azurerm_logic_app_trigger_custom, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_logic_app_trigger_custom", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_logic_app_trigger_custom", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_trigger_custom{Azurerm_logic_app_trigger_custom_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_logic_app_trigger_custom", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_logic_app_trigger_customHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_logic_app_trigger_custom", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_logic_app_trigger_custom", externalID)
}

type Azurerm_logic_app_trigger_http_request struct {
	Azurerm_logic_app_trigger_http_request_id *string `lyra:"ignore"`

	Logic_app_id string

	Method *string

	Name string

	Relative_path *string

	Schema string
}

var Azurerm_logic_app_trigger_http_request_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_logic_app_trigger_http_request_id",

		"method",

		"relative_path",
	)
	rtb.ImmutableAttributes(

		"logic_app_id",

		"name",
	)
}

// Azurerm_logic_app_trigger_http_requestHandler ...
type Azurerm_logic_app_trigger_http_requestHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_logic_app_trigger_http_requestHandler) Create(desired *Azurerm_logic_app_trigger_http_request) (*Azurerm_logic_app_trigger_http_request, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_logic_app_trigger_http_request", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_logic_app_trigger_http_request", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_logic_app_trigger_http_requestHandler) Update(externalID string, desired *Azurerm_logic_app_trigger_http_request) (*Azurerm_logic_app_trigger_http_request, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_logic_app_trigger_http_request", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_logic_app_trigger_http_request", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_trigger_http_request{Azurerm_logic_app_trigger_http_request_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_logic_app_trigger_http_request", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_logic_app_trigger_http_requestHandler) Read(externalID string) (*Azurerm_logic_app_trigger_http_request, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_logic_app_trigger_http_request", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_logic_app_trigger_http_request", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_trigger_http_request{Azurerm_logic_app_trigger_http_request_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_logic_app_trigger_http_request", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_logic_app_trigger_http_requestHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_logic_app_trigger_http_request", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_logic_app_trigger_http_request", externalID)
}

type Azurerm_logic_app_trigger_recurrence struct {
	Azurerm_logic_app_trigger_recurrence_id *string `lyra:"ignore"`

	Frequency string

	Interval int

	Logic_app_id string

	Name string
}

var Azurerm_logic_app_trigger_recurrence_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_logic_app_trigger_recurrence_id",
	)
	rtb.ImmutableAttributes(

		"logic_app_id",

		"name",
	)
}

// Azurerm_logic_app_trigger_recurrenceHandler ...
type Azurerm_logic_app_trigger_recurrenceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_logic_app_trigger_recurrenceHandler) Create(desired *Azurerm_logic_app_trigger_recurrence) (*Azurerm_logic_app_trigger_recurrence, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_logic_app_trigger_recurrence", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_logic_app_trigger_recurrence", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_logic_app_trigger_recurrenceHandler) Update(externalID string, desired *Azurerm_logic_app_trigger_recurrence) (*Azurerm_logic_app_trigger_recurrence, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_logic_app_trigger_recurrence", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_logic_app_trigger_recurrence", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_trigger_recurrence{Azurerm_logic_app_trigger_recurrence_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_logic_app_trigger_recurrence", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_logic_app_trigger_recurrenceHandler) Read(externalID string) (*Azurerm_logic_app_trigger_recurrence, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_logic_app_trigger_recurrence", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_logic_app_trigger_recurrence", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_trigger_recurrence{Azurerm_logic_app_trigger_recurrence_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_logic_app_trigger_recurrence", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_logic_app_trigger_recurrenceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_logic_app_trigger_recurrence", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_logic_app_trigger_recurrence", externalID)
}

type Azurerm_logic_app_workflow struct {
	Azurerm_logic_app_workflow_id *string `lyra:"ignore"`

	Access_endpoint *string

	Location string

	Name string

	Parameters *map[string]string

	Resource_group_name string

	Tags *map[string]string

	Workflow_schema *string

	Workflow_version *string
}

var Azurerm_logic_app_workflow_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_logic_app_workflow_id",

		"access_endpoint",

		"parameters",

		"tags",

		"workflow_schema",

		"workflow_version",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"workflow_schema",

		"workflow_version",
	)
}

// Azurerm_logic_app_workflowHandler ...
type Azurerm_logic_app_workflowHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_logic_app_workflowHandler) Create(desired *Azurerm_logic_app_workflow) (*Azurerm_logic_app_workflow, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_logic_app_workflow", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_logic_app_workflow", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_logic_app_workflowHandler) Update(externalID string, desired *Azurerm_logic_app_workflow) (*Azurerm_logic_app_workflow, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_logic_app_workflow", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_logic_app_workflow", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_workflow{Azurerm_logic_app_workflow_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_logic_app_workflow", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_logic_app_workflowHandler) Read(externalID string) (*Azurerm_logic_app_workflow, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_logic_app_workflow", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_logic_app_workflow", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_logic_app_workflow{Azurerm_logic_app_workflow_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_logic_app_workflow", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_logic_app_workflowHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_logic_app_workflow", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_logic_app_workflow", externalID)
}

type Azurerm_managed_disk_encryption_settings_138_disk_encryption_key_139 struct {
	Secret_url string

	Source_vault_id string
}

type Azurerm_managed_disk_encryption_settings_138_key_encryption_key_140 struct {
	Key_url string

	Source_vault_id string
}

type Azurerm_managed_disk_encryption_settings_138 struct {
	Disk_encryption_key *[]Azurerm_managed_disk_encryption_settings_138_disk_encryption_key_139

	Enabled bool

	Key_encryption_key *[]Azurerm_managed_disk_encryption_settings_138_key_encryption_key_140
}

type Azurerm_managed_disk struct {
	Azurerm_managed_disk_id *string `lyra:"ignore"`

	Create_option string

	Disk_size_gb *int

	Encryption_settings *[]Azurerm_managed_disk_encryption_settings_138

	Image_reference_id *string

	Location string

	Name string

	Os_type *string

	Resource_group_name string

	Source_resource_id *string

	Source_uri *string

	Storage_account_type string

	Tags *map[string]string

	Zones *[]string
}

var Azurerm_managed_disk_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_managed_disk_id",

		"disk_size_gb",

		"encryption_settings",

		"image_reference_id",

		"os_type",

		"source_resource_id",

		"source_uri",

		"tags",

		"zones",
	)
	rtb.ImmutableAttributes(

		"create_option",

		"image_reference_id",

		"location",

		"name",

		"resource_group_name",

		"source_resource_id",

		"source_uri",

		"zones",
	)
}

// Azurerm_managed_diskHandler ...
type Azurerm_managed_diskHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_managed_diskHandler) Create(desired *Azurerm_managed_disk) (*Azurerm_managed_disk, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_managed_disk", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_managed_disk", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_managed_diskHandler) Update(externalID string, desired *Azurerm_managed_disk) (*Azurerm_managed_disk, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_managed_disk", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_managed_disk", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_managed_disk{Azurerm_managed_disk_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_managed_disk", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_managed_diskHandler) Read(externalID string) (*Azurerm_managed_disk, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_managed_disk", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_managed_disk", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_managed_disk{Azurerm_managed_disk_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_managed_disk", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_managed_diskHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_managed_disk", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_managed_disk", externalID)
}

type Azurerm_management_group struct {
	Azurerm_management_group_id *string `lyra:"ignore"`

	Display_name *string

	Group_id *string

	Parent_management_group_id *string

	Subscription_ids *[]string
}

var Azurerm_management_group_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_management_group_id",

		"display_name",

		"group_id",

		"parent_management_group_id",

		"subscription_ids",
	)
	rtb.ImmutableAttributes(

		"group_id",
	)
}

// Azurerm_management_groupHandler ...
type Azurerm_management_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_management_groupHandler) Create(desired *Azurerm_management_group) (*Azurerm_management_group, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_management_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_management_group", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_management_groupHandler) Update(externalID string, desired *Azurerm_management_group) (*Azurerm_management_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_management_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_management_group", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_management_group{Azurerm_management_group_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_management_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_management_groupHandler) Read(externalID string) (*Azurerm_management_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_management_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_management_group", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_management_group{Azurerm_management_group_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_management_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_management_groupHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_management_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_management_group", externalID)
}

type Azurerm_management_lock struct {
	Azurerm_management_lock_id *string `lyra:"ignore"`

	Lock_level string

	Name string

	Notes *string

	Scope string
}

var Azurerm_management_lock_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_management_lock_id",

		"notes",
	)
	rtb.ImmutableAttributes(

		"lock_level",

		"name",

		"notes",

		"scope",
	)
}

// Azurerm_management_lockHandler ...
type Azurerm_management_lockHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_management_lockHandler) Create(desired *Azurerm_management_lock) (*Azurerm_management_lock, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_management_lock", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_management_lock", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_management_lockHandler) Update(externalID string, desired *Azurerm_management_lock) (*Azurerm_management_lock, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_management_lock", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_management_lock", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_management_lock{Azurerm_management_lock_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_management_lock", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_management_lockHandler) Read(externalID string) (*Azurerm_management_lock, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_management_lock", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_management_lock", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_management_lock{Azurerm_management_lock_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_management_lock", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_management_lockHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_management_lock", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_management_lock", externalID)
}

type Azurerm_mariadb_database struct {
	Azurerm_mariadb_database_id *string `lyra:"ignore"`

	Charset string

	Collation string

	Name string

	Resource_group_name string

	Server_name string
}

var Azurerm_mariadb_database_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_mariadb_database_id",
	)
	rtb.ImmutableAttributes(

		"charset",

		"collation",

		"name",

		"resource_group_name",

		"server_name",
	)
}

// Azurerm_mariadb_databaseHandler ...
type Azurerm_mariadb_databaseHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_mariadb_databaseHandler) Create(desired *Azurerm_mariadb_database) (*Azurerm_mariadb_database, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_mariadb_database", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_mariadb_database", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_mariadb_databaseHandler) Update(externalID string, desired *Azurerm_mariadb_database) (*Azurerm_mariadb_database, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_mariadb_database", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_mariadb_database", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mariadb_database{Azurerm_mariadb_database_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_mariadb_database", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_mariadb_databaseHandler) Read(externalID string) (*Azurerm_mariadb_database, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_mariadb_database", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_mariadb_database", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mariadb_database{Azurerm_mariadb_database_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_mariadb_database", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_mariadb_databaseHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_mariadb_database", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_mariadb_database", externalID)
}

type Azurerm_mariadb_server_sku_141 struct {
	Capacity int

	Family string

	Name string

	Tier string
}

type Azurerm_mariadb_server_storage_profile_142 struct {
	Backup_retention_days *int

	Geo_redundant_backup *string

	Storage_mb int
}

type Azurerm_mariadb_server struct {
	Azurerm_mariadb_server_id *string `lyra:"ignore"`

	Administrator_login string

	Administrator_login_password string

	Fqdn *string

	Location string

	Name string

	Resource_group_name string

	Sku []Azurerm_mariadb_server_sku_141

	Ssl_enforcement string

	Storage_profile []Azurerm_mariadb_server_storage_profile_142

	Tags *map[string]string

	Version string
}

var Azurerm_mariadb_server_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_mariadb_server_id",

		"fqdn",

		"tags",
	)
	rtb.ImmutableAttributes(

		"administrator_login",

		"location",

		"name",

		"resource_group_name",

		"version",
	)
}

// Azurerm_mariadb_serverHandler ...
type Azurerm_mariadb_serverHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_mariadb_serverHandler) Create(desired *Azurerm_mariadb_server) (*Azurerm_mariadb_server, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_mariadb_server", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_mariadb_server", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_mariadb_serverHandler) Update(externalID string, desired *Azurerm_mariadb_server) (*Azurerm_mariadb_server, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_mariadb_server", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_mariadb_server", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mariadb_server{Azurerm_mariadb_server_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_mariadb_server", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_mariadb_serverHandler) Read(externalID string) (*Azurerm_mariadb_server, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_mariadb_server", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_mariadb_server", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mariadb_server{Azurerm_mariadb_server_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_mariadb_server", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_mariadb_serverHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_mariadb_server", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_mariadb_server", externalID)
}

type Azurerm_metric_alertrule_email_action_143 struct {
	Custom_emails *[]string

	Send_to_service_owners *bool
}

type Azurerm_metric_alertrule_webhook_action_144 struct {
	Properties *map[string]string

	Service_uri string
}

type Azurerm_metric_alertrule struct {
	Azurerm_metric_alertrule_id *string `lyra:"ignore"`

	Aggregation string

	Description *string

	Email_action *[]Azurerm_metric_alertrule_email_action_143

	Enabled *bool

	Location string

	Metric_name string

	Name string

	Operator string

	Period string

	Resource_group_name string

	Resource_id string

	Tags *map[string]string

	Threshold float64

	Webhook_action *[]Azurerm_metric_alertrule_webhook_action_144
}

var Azurerm_metric_alertrule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_metric_alertrule_id",

		"description",

		"email_action",

		"enabled",

		"tags",

		"webhook_action",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_metric_alertruleHandler ...
type Azurerm_metric_alertruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_metric_alertruleHandler) Create(desired *Azurerm_metric_alertrule) (*Azurerm_metric_alertrule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_metric_alertrule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_metric_alertrule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_metric_alertruleHandler) Update(externalID string, desired *Azurerm_metric_alertrule) (*Azurerm_metric_alertrule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_metric_alertrule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_metric_alertrule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_metric_alertrule{Azurerm_metric_alertrule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_metric_alertrule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_metric_alertruleHandler) Read(externalID string) (*Azurerm_metric_alertrule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_metric_alertrule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_metric_alertrule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_metric_alertrule{Azurerm_metric_alertrule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_metric_alertrule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_metric_alertruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_metric_alertrule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_metric_alertrule", externalID)
}

type Azurerm_monitor_action_group_email_receiver_145 struct {
	Email_address string

	Name string
}

type Azurerm_monitor_action_group_sms_receiver_146 struct {
	Country_code string

	Name string

	Phone_number string
}

type Azurerm_monitor_action_group_webhook_receiver_147 struct {
	Name string

	Service_uri string
}

type Azurerm_monitor_action_group struct {
	Azurerm_monitor_action_group_id *string `lyra:"ignore"`

	Email_receiver *[]Azurerm_monitor_action_group_email_receiver_145

	Enabled *bool

	Name string

	Resource_group_name string

	Short_name string

	Sms_receiver *[]Azurerm_monitor_action_group_sms_receiver_146

	Tags *map[string]string

	Webhook_receiver *[]Azurerm_monitor_action_group_webhook_receiver_147
}

var Azurerm_monitor_action_group_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_monitor_action_group_id",

		"email_receiver",

		"enabled",

		"sms_receiver",

		"tags",

		"webhook_receiver",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",
	)
}

// Azurerm_monitor_action_groupHandler ...
type Azurerm_monitor_action_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_monitor_action_groupHandler) Create(desired *Azurerm_monitor_action_group) (*Azurerm_monitor_action_group, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_monitor_action_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_monitor_action_group", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_monitor_action_groupHandler) Update(externalID string, desired *Azurerm_monitor_action_group) (*Azurerm_monitor_action_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_monitor_action_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_monitor_action_group", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_action_group{Azurerm_monitor_action_group_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_monitor_action_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_monitor_action_groupHandler) Read(externalID string) (*Azurerm_monitor_action_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_monitor_action_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_monitor_action_group", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_action_group{Azurerm_monitor_action_group_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_monitor_action_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_monitor_action_groupHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_monitor_action_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_monitor_action_group", externalID)
}

type Azurerm_monitor_activity_log_alert_action_148 struct {
	Action_group_id string

	Webhook_properties *map[string]string
}

type Azurerm_monitor_activity_log_alert_criteria_149 struct {
	Caller *string

	Category string

	Level *string

	Operation_name *string

	Resource_group *string

	Resource_id *string

	Resource_provider *string

	Resource_type *string

	Status *string

	Sub_status *string
}

type Azurerm_monitor_activity_log_alert struct {
	Azurerm_monitor_activity_log_alert_id *string `lyra:"ignore"`

	Action *[]Azurerm_monitor_activity_log_alert_action_148

	Criteria []Azurerm_monitor_activity_log_alert_criteria_149

	Description *string

	Enabled *bool

	Name string

	Resource_group_name string

	Scopes []string

	Tags *map[string]string
}

var Azurerm_monitor_activity_log_alert_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_monitor_activity_log_alert_id",

		"action",

		"description",

		"enabled",

		"tags",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",
	)
}

// Azurerm_monitor_activity_log_alertHandler ...
type Azurerm_monitor_activity_log_alertHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_monitor_activity_log_alertHandler) Create(desired *Azurerm_monitor_activity_log_alert) (*Azurerm_monitor_activity_log_alert, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_monitor_activity_log_alert", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_monitor_activity_log_alert", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_monitor_activity_log_alertHandler) Update(externalID string, desired *Azurerm_monitor_activity_log_alert) (*Azurerm_monitor_activity_log_alert, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_monitor_activity_log_alert", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_monitor_activity_log_alert", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_activity_log_alert{Azurerm_monitor_activity_log_alert_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_monitor_activity_log_alert", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_monitor_activity_log_alertHandler) Read(externalID string) (*Azurerm_monitor_activity_log_alert, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_monitor_activity_log_alert", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_monitor_activity_log_alert", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_activity_log_alert{Azurerm_monitor_activity_log_alert_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_monitor_activity_log_alert", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_monitor_activity_log_alertHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_monitor_activity_log_alert", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_monitor_activity_log_alert", externalID)
}

type Azurerm_monitor_diagnostic_setting_log_150_retention_policy_151 struct {
	Days *int

	Enabled bool
}

type Azurerm_monitor_diagnostic_setting_log_150 struct {
	Category string

	Enabled *bool

	Retention_policy []Azurerm_monitor_diagnostic_setting_log_150_retention_policy_151
}

type Azurerm_monitor_diagnostic_setting_metric_152_retention_policy_153 struct {
	Days *int

	Enabled bool
}

type Azurerm_monitor_diagnostic_setting_metric_152 struct {
	Category string

	Enabled *bool

	Retention_policy []Azurerm_monitor_diagnostic_setting_metric_152_retention_policy_153
}

type Azurerm_monitor_diagnostic_setting struct {
	Azurerm_monitor_diagnostic_setting_id *string `lyra:"ignore"`

	Eventhub_authorization_rule_id *string

	Eventhub_name *string

	Log *[]Azurerm_monitor_diagnostic_setting_log_150

	Log_analytics_workspace_id *string

	Metric *[]Azurerm_monitor_diagnostic_setting_metric_152

	Name string

	Storage_account_id *string

	Target_resource_id string
}

var Azurerm_monitor_diagnostic_setting_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_monitor_diagnostic_setting_id",

		"eventhub_authorization_rule_id",

		"eventhub_name",

		"log",

		"log_analytics_workspace_id",

		"metric",

		"storage_account_id",
	)
	rtb.ImmutableAttributes(

		"eventhub_authorization_rule_id",

		"eventhub_name",

		"log_analytics_workspace_id",

		"name",

		"storage_account_id",

		"target_resource_id",
	)
}

// Azurerm_monitor_diagnostic_settingHandler ...
type Azurerm_monitor_diagnostic_settingHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_monitor_diagnostic_settingHandler) Create(desired *Azurerm_monitor_diagnostic_setting) (*Azurerm_monitor_diagnostic_setting, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_monitor_diagnostic_setting", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_monitor_diagnostic_setting", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_monitor_diagnostic_settingHandler) Update(externalID string, desired *Azurerm_monitor_diagnostic_setting) (*Azurerm_monitor_diagnostic_setting, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_monitor_diagnostic_setting", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_monitor_diagnostic_setting", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_diagnostic_setting{Azurerm_monitor_diagnostic_setting_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_monitor_diagnostic_setting", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_monitor_diagnostic_settingHandler) Read(externalID string) (*Azurerm_monitor_diagnostic_setting, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_monitor_diagnostic_setting", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_monitor_diagnostic_setting", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_diagnostic_setting{Azurerm_monitor_diagnostic_setting_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_monitor_diagnostic_setting", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_monitor_diagnostic_settingHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_monitor_diagnostic_setting", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_monitor_diagnostic_setting", externalID)
}

type Azurerm_monitor_log_profile_retention_policy_154 struct {
	Days *int

	Enabled bool
}

type Azurerm_monitor_log_profile struct {
	Azurerm_monitor_log_profile_id *string `lyra:"ignore"`

	Categories []string

	Locations []string

	Name string

	Retention_policy []Azurerm_monitor_log_profile_retention_policy_154

	Servicebus_rule_id *string

	Storage_account_id *string
}

var Azurerm_monitor_log_profile_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_monitor_log_profile_id",

		"servicebus_rule_id",

		"storage_account_id",
	)
	rtb.ImmutableAttributes(

		"name",
	)
}

// Azurerm_monitor_log_profileHandler ...
type Azurerm_monitor_log_profileHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_monitor_log_profileHandler) Create(desired *Azurerm_monitor_log_profile) (*Azurerm_monitor_log_profile, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_monitor_log_profile", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_monitor_log_profile", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_monitor_log_profileHandler) Update(externalID string, desired *Azurerm_monitor_log_profile) (*Azurerm_monitor_log_profile, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_monitor_log_profile", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_monitor_log_profile", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_log_profile{Azurerm_monitor_log_profile_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_monitor_log_profile", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_monitor_log_profileHandler) Read(externalID string) (*Azurerm_monitor_log_profile, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_monitor_log_profile", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_monitor_log_profile", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_log_profile{Azurerm_monitor_log_profile_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_monitor_log_profile", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_monitor_log_profileHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_monitor_log_profile", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_monitor_log_profile", externalID)
}

type Azurerm_monitor_metric_alert_action_155 struct {
	Action_group_id string

	Webhook_properties *map[string]string
}

type Azurerm_monitor_metric_alert_criteria_156_dimension_157 struct {
	Name string

	Operator string

	Values []string
}

type Azurerm_monitor_metric_alert_criteria_156 struct {
	Aggregation string

	Dimension *[]Azurerm_monitor_metric_alert_criteria_156_dimension_157

	Metric_name string

	Metric_namespace string

	Operator string

	Threshold float64
}

type Azurerm_monitor_metric_alert struct {
	Azurerm_monitor_metric_alert_id *string `lyra:"ignore"`

	Action *[]Azurerm_monitor_metric_alert_action_155

	Auto_mitigate *bool

	Criteria []Azurerm_monitor_metric_alert_criteria_156

	Description *string

	Enabled *bool

	Frequency *string

	Name string

	Resource_group_name string

	Scopes []string

	Severity *int

	Tags *map[string]string

	Window_size *string
}

var Azurerm_monitor_metric_alert_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_monitor_metric_alert_id",

		"action",

		"auto_mitigate",

		"description",

		"enabled",

		"frequency",

		"severity",

		"tags",

		"window_size",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",
	)
}

// Azurerm_monitor_metric_alertHandler ...
type Azurerm_monitor_metric_alertHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_monitor_metric_alertHandler) Create(desired *Azurerm_monitor_metric_alert) (*Azurerm_monitor_metric_alert, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_monitor_metric_alert", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_monitor_metric_alert", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_monitor_metric_alertHandler) Update(externalID string, desired *Azurerm_monitor_metric_alert) (*Azurerm_monitor_metric_alert, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_monitor_metric_alert", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_monitor_metric_alert", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_metric_alert{Azurerm_monitor_metric_alert_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_monitor_metric_alert", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_monitor_metric_alertHandler) Read(externalID string) (*Azurerm_monitor_metric_alert, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_monitor_metric_alert", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_monitor_metric_alert", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_monitor_metric_alert{Azurerm_monitor_metric_alert_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_monitor_metric_alert", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_monitor_metric_alertHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_monitor_metric_alert", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_monitor_metric_alert", externalID)
}

type Azurerm_mssql_elasticpool_elastic_pool_properties_158 struct {
	Creation_date *string

	License_type *string

	Max_size_bytes *int

	State *string

	Zone_redundant *bool
}

type Azurerm_mssql_elasticpool_per_database_settings_159 struct {
	Max_capacity float64

	Min_capacity float64
}

type Azurerm_mssql_elasticpool_sku_160 struct {
	Capacity int

	Family *string

	Name string

	Tier string
}

type Azurerm_mssql_elasticpool struct {
	Azurerm_mssql_elasticpool_id *string `lyra:"ignore"`

	Elastic_pool_properties *[]Azurerm_mssql_elasticpool_elastic_pool_properties_158

	Location string

	Max_size_bytes *int

	Name string

	Per_database_settings []Azurerm_mssql_elasticpool_per_database_settings_159

	Resource_group_name string

	Server_name string

	Sku []Azurerm_mssql_elasticpool_sku_160

	Tags *map[string]string

	Zone_redundant *bool
}

var Azurerm_mssql_elasticpool_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_mssql_elasticpool_id",

		"elastic_pool_properties",

		"max_size_bytes",

		"tags",

		"zone_redundant",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"server_name",
	)
}

// Azurerm_mssql_elasticpoolHandler ...
type Azurerm_mssql_elasticpoolHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_mssql_elasticpoolHandler) Create(desired *Azurerm_mssql_elasticpool) (*Azurerm_mssql_elasticpool, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_mssql_elasticpool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_mssql_elasticpool", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_mssql_elasticpoolHandler) Update(externalID string, desired *Azurerm_mssql_elasticpool) (*Azurerm_mssql_elasticpool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_mssql_elasticpool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_mssql_elasticpool", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mssql_elasticpool{Azurerm_mssql_elasticpool_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_mssql_elasticpool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_mssql_elasticpoolHandler) Read(externalID string) (*Azurerm_mssql_elasticpool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_mssql_elasticpool", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_mssql_elasticpool", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mssql_elasticpool{Azurerm_mssql_elasticpool_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_mssql_elasticpool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_mssql_elasticpoolHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_mssql_elasticpool", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_mssql_elasticpool", externalID)
}

type Azurerm_mysql_configuration struct {
	Azurerm_mysql_configuration_id *string `lyra:"ignore"`

	Name string

	Resource_group_name string

	Server_name string

	Value string
}

var Azurerm_mysql_configuration_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_mysql_configuration_id",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"server_name",

		"value",
	)
}

// Azurerm_mysql_configurationHandler ...
type Azurerm_mysql_configurationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_mysql_configurationHandler) Create(desired *Azurerm_mysql_configuration) (*Azurerm_mysql_configuration, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_mysql_configuration", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_mysql_configuration", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_mysql_configurationHandler) Update(externalID string, desired *Azurerm_mysql_configuration) (*Azurerm_mysql_configuration, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_mysql_configuration", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_mysql_configuration", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_configuration{Azurerm_mysql_configuration_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_mysql_configuration", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_mysql_configurationHandler) Read(externalID string) (*Azurerm_mysql_configuration, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_mysql_configuration", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_mysql_configuration", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_configuration{Azurerm_mysql_configuration_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_mysql_configuration", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_mysql_configurationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_mysql_configuration", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_mysql_configuration", externalID)
}

type Azurerm_mysql_database struct {
	Azurerm_mysql_database_id *string `lyra:"ignore"`

	Charset string

	Collation string

	Name string

	Resource_group_name string

	Server_name string
}

var Azurerm_mysql_database_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_mysql_database_id",
	)
	rtb.ImmutableAttributes(

		"charset",

		"collation",

		"name",

		"resource_group_name",

		"server_name",
	)
}

// Azurerm_mysql_databaseHandler ...
type Azurerm_mysql_databaseHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_mysql_databaseHandler) Create(desired *Azurerm_mysql_database) (*Azurerm_mysql_database, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_mysql_database", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_mysql_database", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_mysql_databaseHandler) Update(externalID string, desired *Azurerm_mysql_database) (*Azurerm_mysql_database, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_mysql_database", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_mysql_database", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_database{Azurerm_mysql_database_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_mysql_database", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_mysql_databaseHandler) Read(externalID string) (*Azurerm_mysql_database, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_mysql_database", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_mysql_database", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_database{Azurerm_mysql_database_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_mysql_database", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_mysql_databaseHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_mysql_database", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_mysql_database", externalID)
}

type Azurerm_mysql_firewall_rule struct {
	Azurerm_mysql_firewall_rule_id *string `lyra:"ignore"`

	End_ip_address string

	Name string

	Resource_group_name string

	Server_name string

	Start_ip_address string
}

var Azurerm_mysql_firewall_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_mysql_firewall_rule_id",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"server_name",
	)
}

// Azurerm_mysql_firewall_ruleHandler ...
type Azurerm_mysql_firewall_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_mysql_firewall_ruleHandler) Create(desired *Azurerm_mysql_firewall_rule) (*Azurerm_mysql_firewall_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_mysql_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_mysql_firewall_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_mysql_firewall_ruleHandler) Update(externalID string, desired *Azurerm_mysql_firewall_rule) (*Azurerm_mysql_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_mysql_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_mysql_firewall_rule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_firewall_rule{Azurerm_mysql_firewall_rule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_mysql_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_mysql_firewall_ruleHandler) Read(externalID string) (*Azurerm_mysql_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_mysql_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_mysql_firewall_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_firewall_rule{Azurerm_mysql_firewall_rule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_mysql_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_mysql_firewall_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_mysql_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_mysql_firewall_rule", externalID)
}

type Azurerm_mysql_server_sku_161 struct {
	Capacity int

	Family string

	Name string

	Tier string
}

type Azurerm_mysql_server_storage_profile_162 struct {
	Backup_retention_days *int

	Geo_redundant_backup *string

	Storage_mb int
}

type Azurerm_mysql_server struct {
	Azurerm_mysql_server_id *string `lyra:"ignore"`

	Administrator_login string

	Administrator_login_password string

	Fqdn *string

	Location string

	Name string

	Resource_group_name string

	Sku []Azurerm_mysql_server_sku_161

	Ssl_enforcement string

	Storage_profile []Azurerm_mysql_server_storage_profile_162

	Tags *map[string]string

	Version string
}

var Azurerm_mysql_server_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_mysql_server_id",

		"fqdn",

		"tags",
	)
	rtb.ImmutableAttributes(

		"administrator_login",

		"location",

		"name",

		"resource_group_name",

		"version",
	)
}

// Azurerm_mysql_serverHandler ...
type Azurerm_mysql_serverHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_mysql_serverHandler) Create(desired *Azurerm_mysql_server) (*Azurerm_mysql_server, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_mysql_server", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_mysql_server", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_mysql_serverHandler) Update(externalID string, desired *Azurerm_mysql_server) (*Azurerm_mysql_server, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_mysql_server", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_mysql_server", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_server{Azurerm_mysql_server_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_mysql_server", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_mysql_serverHandler) Read(externalID string) (*Azurerm_mysql_server, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_mysql_server", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_mysql_server", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_server{Azurerm_mysql_server_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_mysql_server", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_mysql_serverHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_mysql_server", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_mysql_server", externalID)
}

type Azurerm_mysql_virtual_network_rule struct {
	Azurerm_mysql_virtual_network_rule_id *string `lyra:"ignore"`

	Name string

	Resource_group_name string

	Server_name string

	Subnet_id string
}

var Azurerm_mysql_virtual_network_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_mysql_virtual_network_rule_id",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"server_name",
	)
}

// Azurerm_mysql_virtual_network_ruleHandler ...
type Azurerm_mysql_virtual_network_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_mysql_virtual_network_ruleHandler) Create(desired *Azurerm_mysql_virtual_network_rule) (*Azurerm_mysql_virtual_network_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_mysql_virtual_network_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_mysql_virtual_network_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_mysql_virtual_network_ruleHandler) Update(externalID string, desired *Azurerm_mysql_virtual_network_rule) (*Azurerm_mysql_virtual_network_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_mysql_virtual_network_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_mysql_virtual_network_rule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_virtual_network_rule{Azurerm_mysql_virtual_network_rule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_mysql_virtual_network_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_mysql_virtual_network_ruleHandler) Read(externalID string) (*Azurerm_mysql_virtual_network_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_mysql_virtual_network_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_mysql_virtual_network_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_mysql_virtual_network_rule{Azurerm_mysql_virtual_network_rule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_mysql_virtual_network_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_mysql_virtual_network_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_mysql_virtual_network_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_mysql_virtual_network_rule", externalID)
}

type Azurerm_network_interface_ip_configuration_163 struct {
	Application_gateway_backend_address_pools_ids *[]string

	Application_security_group_ids *[]string

	Load_balancer_backend_address_pools_ids *[]string

	Load_balancer_inbound_nat_rules_ids *[]string

	Name string

	Primary *bool

	Private_ip_address *string

	Private_ip_address_allocation string

	Private_ip_address_version *string

	Public_ip_address_id *string

	Subnet_id *string
}

type Azurerm_network_interface struct {
	Azurerm_network_interface_id *string `lyra:"ignore"`

	Applied_dns_servers *[]string

	Dns_servers *[]string

	Enable_accelerated_networking *bool

	Enable_ip_forwarding *bool

	Internal_dns_name_label *string

	Internal_fqdn *string

	Ip_configuration []Azurerm_network_interface_ip_configuration_163

	Location string

	Mac_address *string

	Name string

	Network_security_group_id *string

	Private_ip_address *string

	Private_ip_addresses *[]string

	Resource_group_name string

	Tags *map[string]string

	Virtual_machine_id *string
}

var Azurerm_network_interface_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_network_interface_id",

		"applied_dns_servers",

		"dns_servers",

		"enable_accelerated_networking",

		"enable_ip_forwarding",

		"internal_dns_name_label",

		"internal_fqdn",

		"mac_address",

		"network_security_group_id",

		"private_ip_address",

		"private_ip_addresses",

		"tags",

		"virtual_machine_id",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_network_interfaceHandler ...
type Azurerm_network_interfaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_network_interfaceHandler) Create(desired *Azurerm_network_interface) (*Azurerm_network_interface, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_network_interface", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_network_interface", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_network_interfaceHandler) Update(externalID string, desired *Azurerm_network_interface) (*Azurerm_network_interface, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_network_interface", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_network_interface", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_interface{Azurerm_network_interface_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_network_interface", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_network_interfaceHandler) Read(externalID string) (*Azurerm_network_interface, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_network_interface", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_network_interface", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_interface{Azurerm_network_interface_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_network_interface", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_network_interfaceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_network_interface", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_network_interface", externalID)
}

type Azurerm_network_interface_application_gateway_backend_address_pool_association struct {
	Azurerm_network_interface_application_gateway_backend_address_pool_association_id *string `lyra:"ignore"`

	Backend_address_pool_id string

	Ip_configuration_name string

	Network_interface_id string
}

var Azurerm_network_interface_application_gateway_backend_address_pool_association_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_network_interface_application_gateway_backend_address_pool_association_id",
	)
	rtb.ImmutableAttributes(

		"backend_address_pool_id",

		"ip_configuration_name",

		"network_interface_id",
	)
}

// Azurerm_network_interface_application_gateway_backend_address_pool_associationHandler ...
type Azurerm_network_interface_application_gateway_backend_address_pool_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_network_interface_application_gateway_backend_address_pool_associationHandler) Create(desired *Azurerm_network_interface_application_gateway_backend_address_pool_association) (*Azurerm_network_interface_application_gateway_backend_address_pool_association, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_network_interface_application_gateway_backend_address_pool_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_network_interface_application_gateway_backend_address_pool_association", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_network_interface_application_gateway_backend_address_pool_associationHandler) Update(externalID string, desired *Azurerm_network_interface_application_gateway_backend_address_pool_association) (*Azurerm_network_interface_application_gateway_backend_address_pool_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_network_interface_application_gateway_backend_address_pool_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_network_interface_application_gateway_backend_address_pool_association", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_interface_application_gateway_backend_address_pool_association{Azurerm_network_interface_application_gateway_backend_address_pool_association_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_network_interface_application_gateway_backend_address_pool_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_network_interface_application_gateway_backend_address_pool_associationHandler) Read(externalID string) (*Azurerm_network_interface_application_gateway_backend_address_pool_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_network_interface_application_gateway_backend_address_pool_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_network_interface_application_gateway_backend_address_pool_association", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_interface_application_gateway_backend_address_pool_association{Azurerm_network_interface_application_gateway_backend_address_pool_association_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_network_interface_application_gateway_backend_address_pool_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_network_interface_application_gateway_backend_address_pool_associationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_network_interface_application_gateway_backend_address_pool_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_network_interface_application_gateway_backend_address_pool_association", externalID)
}

type Azurerm_network_interface_backend_address_pool_association struct {
	Azurerm_network_interface_backend_address_pool_association_id *string `lyra:"ignore"`

	Backend_address_pool_id string

	Ip_configuration_name string

	Network_interface_id string
}

var Azurerm_network_interface_backend_address_pool_association_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_network_interface_backend_address_pool_association_id",
	)
	rtb.ImmutableAttributes(

		"backend_address_pool_id",

		"ip_configuration_name",

		"network_interface_id",
	)
}

// Azurerm_network_interface_backend_address_pool_associationHandler ...
type Azurerm_network_interface_backend_address_pool_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_network_interface_backend_address_pool_associationHandler) Create(desired *Azurerm_network_interface_backend_address_pool_association) (*Azurerm_network_interface_backend_address_pool_association, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_network_interface_backend_address_pool_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_network_interface_backend_address_pool_association", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_network_interface_backend_address_pool_associationHandler) Update(externalID string, desired *Azurerm_network_interface_backend_address_pool_association) (*Azurerm_network_interface_backend_address_pool_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_network_interface_backend_address_pool_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_network_interface_backend_address_pool_association", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_interface_backend_address_pool_association{Azurerm_network_interface_backend_address_pool_association_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_network_interface_backend_address_pool_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_network_interface_backend_address_pool_associationHandler) Read(externalID string) (*Azurerm_network_interface_backend_address_pool_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_network_interface_backend_address_pool_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_network_interface_backend_address_pool_association", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_interface_backend_address_pool_association{Azurerm_network_interface_backend_address_pool_association_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_network_interface_backend_address_pool_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_network_interface_backend_address_pool_associationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_network_interface_backend_address_pool_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_network_interface_backend_address_pool_association", externalID)
}

type Azurerm_network_interface_nat_rule_association struct {
	Azurerm_network_interface_nat_rule_association_id *string `lyra:"ignore"`

	Ip_configuration_name string

	Nat_rule_id string

	Network_interface_id string
}

var Azurerm_network_interface_nat_rule_association_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_network_interface_nat_rule_association_id",
	)
	rtb.ImmutableAttributes(

		"ip_configuration_name",

		"nat_rule_id",

		"network_interface_id",
	)
}

// Azurerm_network_interface_nat_rule_associationHandler ...
type Azurerm_network_interface_nat_rule_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_network_interface_nat_rule_associationHandler) Create(desired *Azurerm_network_interface_nat_rule_association) (*Azurerm_network_interface_nat_rule_association, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_network_interface_nat_rule_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_network_interface_nat_rule_association", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_network_interface_nat_rule_associationHandler) Update(externalID string, desired *Azurerm_network_interface_nat_rule_association) (*Azurerm_network_interface_nat_rule_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_network_interface_nat_rule_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_network_interface_nat_rule_association", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_interface_nat_rule_association{Azurerm_network_interface_nat_rule_association_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_network_interface_nat_rule_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_network_interface_nat_rule_associationHandler) Read(externalID string) (*Azurerm_network_interface_nat_rule_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_network_interface_nat_rule_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_network_interface_nat_rule_association", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_interface_nat_rule_association{Azurerm_network_interface_nat_rule_association_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_network_interface_nat_rule_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_network_interface_nat_rule_associationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_network_interface_nat_rule_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_network_interface_nat_rule_association", externalID)
}

type Azurerm_network_security_group_security_rule_164 struct {
	Access string

	Description *string

	Destination_address_prefix *string

	Destination_address_prefixes *[]string

	Destination_application_security_group_ids *[]string

	Destination_port_range *string

	Destination_port_ranges *[]string

	Direction string

	Name string

	Priority int

	Protocol string

	Source_address_prefix *string

	Source_address_prefixes *[]string

	Source_application_security_group_ids *[]string

	Source_port_range *string

	Source_port_ranges *[]string
}

type Azurerm_network_security_group struct {
	Azurerm_network_security_group_id *string `lyra:"ignore"`

	Location string

	Name string

	Resource_group_name string

	Security_rule *[]Azurerm_network_security_group_security_rule_164

	Tags *map[string]string
}

var Azurerm_network_security_group_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_network_security_group_id",

		"security_rule",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_network_security_groupHandler ...
type Azurerm_network_security_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_network_security_groupHandler) Create(desired *Azurerm_network_security_group) (*Azurerm_network_security_group, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_network_security_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_network_security_group", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_network_security_groupHandler) Update(externalID string, desired *Azurerm_network_security_group) (*Azurerm_network_security_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_network_security_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_network_security_group", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_security_group{Azurerm_network_security_group_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_network_security_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_network_security_groupHandler) Read(externalID string) (*Azurerm_network_security_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_network_security_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_network_security_group", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_security_group{Azurerm_network_security_group_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_network_security_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_network_security_groupHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_network_security_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_network_security_group", externalID)
}

type Azurerm_network_security_rule struct {
	Azurerm_network_security_rule_id *string `lyra:"ignore"`

	Access string

	Description *string

	Destination_address_prefix *string

	Destination_address_prefixes *[]string

	Destination_application_security_group_ids *[]string

	Destination_port_range *string

	Destination_port_ranges *[]string

	Direction string

	Name string

	Network_security_group_name string

	Priority int

	Protocol string

	Resource_group_name string

	Source_address_prefix *string

	Source_address_prefixes *[]string

	Source_application_security_group_ids *[]string

	Source_port_range *string

	Source_port_ranges *[]string
}

var Azurerm_network_security_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_network_security_rule_id",

		"description",

		"destination_address_prefix",

		"destination_address_prefixes",

		"destination_application_security_group_ids",

		"destination_port_range",

		"destination_port_ranges",

		"source_address_prefix",

		"source_address_prefixes",

		"source_application_security_group_ids",

		"source_port_range",

		"source_port_ranges",
	)
	rtb.ImmutableAttributes(

		"name",

		"network_security_group_name",

		"resource_group_name",
	)
}

// Azurerm_network_security_ruleHandler ...
type Azurerm_network_security_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_network_security_ruleHandler) Create(desired *Azurerm_network_security_rule) (*Azurerm_network_security_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_network_security_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_network_security_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_network_security_ruleHandler) Update(externalID string, desired *Azurerm_network_security_rule) (*Azurerm_network_security_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_network_security_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_network_security_rule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_security_rule{Azurerm_network_security_rule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_network_security_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_network_security_ruleHandler) Read(externalID string) (*Azurerm_network_security_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_network_security_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_network_security_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_security_rule{Azurerm_network_security_rule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_network_security_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_network_security_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_network_security_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_network_security_rule", externalID)
}

type Azurerm_network_watcher struct {
	Azurerm_network_watcher_id *string `lyra:"ignore"`

	Location string

	Name string

	Resource_group_name string

	Tags *map[string]string
}

var Azurerm_network_watcher_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_network_watcher_id",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_network_watcherHandler ...
type Azurerm_network_watcherHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_network_watcherHandler) Create(desired *Azurerm_network_watcher) (*Azurerm_network_watcher, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_network_watcher", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_network_watcher", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_network_watcherHandler) Update(externalID string, desired *Azurerm_network_watcher) (*Azurerm_network_watcher, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_network_watcher", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_network_watcher", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_watcher{Azurerm_network_watcher_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_network_watcher", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_network_watcherHandler) Read(externalID string) (*Azurerm_network_watcher, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_network_watcher", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_network_watcher", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_network_watcher{Azurerm_network_watcher_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_network_watcher", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_network_watcherHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_network_watcher", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_network_watcher", externalID)
}

type Azurerm_notification_hub_apns_credential_165 struct {
	Application_mode string

	Bundle_id string

	Key_id string

	Team_id string

	Token string
}

type Azurerm_notification_hub_gcm_credential_166 struct {
	Api_key string
}

type Azurerm_notification_hub struct {
	Azurerm_notification_hub_id *string `lyra:"ignore"`

	Apns_credential *[]Azurerm_notification_hub_apns_credential_165

	Gcm_credential *[]Azurerm_notification_hub_gcm_credential_166

	Location string

	Name string

	Namespace_name string

	Resource_group_name string
}

var Azurerm_notification_hub_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_notification_hub_id",

		"apns_credential",

		"gcm_credential",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"namespace_name",

		"resource_group_name",
	)
}

// Azurerm_notification_hubHandler ...
type Azurerm_notification_hubHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_notification_hubHandler) Create(desired *Azurerm_notification_hub) (*Azurerm_notification_hub, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_notification_hub", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_notification_hub", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_notification_hubHandler) Update(externalID string, desired *Azurerm_notification_hub) (*Azurerm_notification_hub, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_notification_hub", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_notification_hub", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_notification_hub{Azurerm_notification_hub_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_notification_hub", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_notification_hubHandler) Read(externalID string) (*Azurerm_notification_hub, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_notification_hub", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_notification_hub", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_notification_hub{Azurerm_notification_hub_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_notification_hub", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_notification_hubHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_notification_hub", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_notification_hub", externalID)
}

type Azurerm_notification_hub_authorization_rule struct {
	Azurerm_notification_hub_authorization_rule_id *string `lyra:"ignore"`

	Listen *bool

	Manage *bool

	Name string

	Namespace_name string

	Notification_hub_name string

	Primary_access_key *string

	Resource_group_name string

	Secondary_access_key *string

	Send *bool
}

var Azurerm_notification_hub_authorization_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_notification_hub_authorization_rule_id",

		"listen",

		"manage",

		"primary_access_key",

		"secondary_access_key",

		"send",
	)
	rtb.ImmutableAttributes(

		"name",

		"namespace_name",

		"notification_hub_name",

		"resource_group_name",
	)
}

// Azurerm_notification_hub_authorization_ruleHandler ...
type Azurerm_notification_hub_authorization_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_notification_hub_authorization_ruleHandler) Create(desired *Azurerm_notification_hub_authorization_rule) (*Azurerm_notification_hub_authorization_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_notification_hub_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_notification_hub_authorization_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_notification_hub_authorization_ruleHandler) Update(externalID string, desired *Azurerm_notification_hub_authorization_rule) (*Azurerm_notification_hub_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_notification_hub_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_notification_hub_authorization_rule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_notification_hub_authorization_rule{Azurerm_notification_hub_authorization_rule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_notification_hub_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_notification_hub_authorization_ruleHandler) Read(externalID string) (*Azurerm_notification_hub_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_notification_hub_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_notification_hub_authorization_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_notification_hub_authorization_rule{Azurerm_notification_hub_authorization_rule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_notification_hub_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_notification_hub_authorization_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_notification_hub_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_notification_hub_authorization_rule", externalID)
}

type Azurerm_notification_hub_namespace_sku_167 struct {
	Name string
}

type Azurerm_notification_hub_namespace struct {
	Azurerm_notification_hub_namespace_id *string `lyra:"ignore"`

	Enabled *bool

	Location string

	Name string

	Namespace_type string

	Resource_group_name string

	Servicebus_endpoint *string

	Sku []Azurerm_notification_hub_namespace_sku_167
}

var Azurerm_notification_hub_namespace_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_notification_hub_namespace_id",

		"enabled",

		"servicebus_endpoint",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_notification_hub_namespaceHandler ...
type Azurerm_notification_hub_namespaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_notification_hub_namespaceHandler) Create(desired *Azurerm_notification_hub_namespace) (*Azurerm_notification_hub_namespace, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_notification_hub_namespace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_notification_hub_namespace", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_notification_hub_namespaceHandler) Update(externalID string, desired *Azurerm_notification_hub_namespace) (*Azurerm_notification_hub_namespace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_notification_hub_namespace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_notification_hub_namespace", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_notification_hub_namespace{Azurerm_notification_hub_namespace_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_notification_hub_namespace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_notification_hub_namespaceHandler) Read(externalID string) (*Azurerm_notification_hub_namespace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_notification_hub_namespace", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_notification_hub_namespace", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_notification_hub_namespace{Azurerm_notification_hub_namespace_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_notification_hub_namespace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_notification_hub_namespaceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_notification_hub_namespace", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_notification_hub_namespace", externalID)
}

type Azurerm_packet_capture_filter_168 struct {
	Local_ip_address *string

	Local_port *string

	Protocol string

	Remote_ip_address *string

	Remote_port *string
}

type Azurerm_packet_capture_storage_location_169 struct {
	File_path *string

	Storage_account_id *string

	Storage_path *string
}

type Azurerm_packet_capture struct {
	Azurerm_packet_capture_id *string `lyra:"ignore"`

	Filter *[]Azurerm_packet_capture_filter_168

	Maximum_bytes_per_packet *int

	Maximum_bytes_per_session *int

	Maximum_capture_duration *int

	Name string

	Network_watcher_name string

	Resource_group_name string

	Storage_location []Azurerm_packet_capture_storage_location_169

	Target_resource_id string
}

var Azurerm_packet_capture_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_packet_capture_id",

		"filter",

		"maximum_bytes_per_packet",

		"maximum_bytes_per_session",

		"maximum_capture_duration",
	)
	rtb.ImmutableAttributes(

		"filter",

		"maximum_bytes_per_packet",

		"maximum_bytes_per_session",

		"maximum_capture_duration",

		"name",

		"network_watcher_name",

		"resource_group_name",

		"storage_location",

		"target_resource_id",
	)
}

// Azurerm_packet_captureHandler ...
type Azurerm_packet_captureHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_packet_captureHandler) Create(desired *Azurerm_packet_capture) (*Azurerm_packet_capture, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_packet_capture", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_packet_capture", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_packet_captureHandler) Update(externalID string, desired *Azurerm_packet_capture) (*Azurerm_packet_capture, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_packet_capture", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_packet_capture", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_packet_capture{Azurerm_packet_capture_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_packet_capture", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_packet_captureHandler) Read(externalID string) (*Azurerm_packet_capture, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_packet_capture", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_packet_capture", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_packet_capture{Azurerm_packet_capture_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_packet_capture", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_packet_captureHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_packet_capture", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_packet_capture", externalID)
}

type Azurerm_policy_assignment_identity_170 struct {
	Principal_id *string

	Tenant_id *string

	Type *string
}

type Azurerm_policy_assignment struct {
	Azurerm_policy_assignment_id *string `lyra:"ignore"`

	Description *string

	Display_name *string

	Identity *[]Azurerm_policy_assignment_identity_170

	Location *string

	Name string

	Not_scopes *[]string

	Parameters *string

	Policy_definition_id string

	Scope string
}

var Azurerm_policy_assignment_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_policy_assignment_id",

		"description",

		"display_name",

		"identity",

		"location",

		"not_scopes",

		"parameters",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"parameters",

		"policy_definition_id",

		"scope",
	)
}

// Azurerm_policy_assignmentHandler ...
type Azurerm_policy_assignmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_policy_assignmentHandler) Create(desired *Azurerm_policy_assignment) (*Azurerm_policy_assignment, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_policy_assignment", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_policy_assignment", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_policy_assignmentHandler) Update(externalID string, desired *Azurerm_policy_assignment) (*Azurerm_policy_assignment, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_policy_assignment", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_policy_assignment", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_policy_assignment{Azurerm_policy_assignment_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_policy_assignment", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_policy_assignmentHandler) Read(externalID string) (*Azurerm_policy_assignment, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_policy_assignment", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_policy_assignment", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_policy_assignment{Azurerm_policy_assignment_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_policy_assignment", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_policy_assignmentHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_policy_assignment", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_policy_assignment", externalID)
}

type Azurerm_policy_definition struct {
	Azurerm_policy_definition_id *string `lyra:"ignore"`

	Description *string

	Display_name string

	Management_group_id *string

	Metadata *string

	Mode string

	Name string

	Parameters *string

	Policy_rule *string

	Policy_type string
}

var Azurerm_policy_definition_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_policy_definition_id",

		"description",

		"management_group_id",

		"metadata",

		"parameters",

		"policy_rule",
	)
	rtb.ImmutableAttributes(

		"management_group_id",

		"mode",

		"name",

		"policy_type",
	)
}

// Azurerm_policy_definitionHandler ...
type Azurerm_policy_definitionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_policy_definitionHandler) Create(desired *Azurerm_policy_definition) (*Azurerm_policy_definition, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_policy_definition", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_policy_definition", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_policy_definitionHandler) Update(externalID string, desired *Azurerm_policy_definition) (*Azurerm_policy_definition, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_policy_definition", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_policy_definition", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_policy_definition{Azurerm_policy_definition_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_policy_definition", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_policy_definitionHandler) Read(externalID string) (*Azurerm_policy_definition, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_policy_definition", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_policy_definition", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_policy_definition{Azurerm_policy_definition_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_policy_definition", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_policy_definitionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_policy_definition", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_policy_definition", externalID)
}

type Azurerm_policy_set_definition struct {
	Azurerm_policy_set_definition_id *string `lyra:"ignore"`

	Description *string

	Display_name string

	Management_group_id *string

	Metadata *string

	Name string

	Parameters *string

	Policy_definitions *string

	Policy_type string
}

var Azurerm_policy_set_definition_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_policy_set_definition_id",

		"description",

		"management_group_id",

		"metadata",

		"parameters",

		"policy_definitions",
	)
	rtb.ImmutableAttributes(

		"management_group_id",

		"name",

		"policy_type",
	)
}

// Azurerm_policy_set_definitionHandler ...
type Azurerm_policy_set_definitionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_policy_set_definitionHandler) Create(desired *Azurerm_policy_set_definition) (*Azurerm_policy_set_definition, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_policy_set_definition", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_policy_set_definition", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_policy_set_definitionHandler) Update(externalID string, desired *Azurerm_policy_set_definition) (*Azurerm_policy_set_definition, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_policy_set_definition", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_policy_set_definition", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_policy_set_definition{Azurerm_policy_set_definition_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_policy_set_definition", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_policy_set_definitionHandler) Read(externalID string) (*Azurerm_policy_set_definition, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_policy_set_definition", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_policy_set_definition", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_policy_set_definition{Azurerm_policy_set_definition_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_policy_set_definition", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_policy_set_definitionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_policy_set_definition", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_policy_set_definition", externalID)
}

type Azurerm_postgresql_configuration struct {
	Azurerm_postgresql_configuration_id *string `lyra:"ignore"`

	Name string

	Resource_group_name string

	Server_name string

	Value string
}

var Azurerm_postgresql_configuration_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_postgresql_configuration_id",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"server_name",

		"value",
	)
}

// Azurerm_postgresql_configurationHandler ...
type Azurerm_postgresql_configurationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_postgresql_configurationHandler) Create(desired *Azurerm_postgresql_configuration) (*Azurerm_postgresql_configuration, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_postgresql_configuration", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_postgresql_configuration", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_postgresql_configurationHandler) Update(externalID string, desired *Azurerm_postgresql_configuration) (*Azurerm_postgresql_configuration, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_postgresql_configuration", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_postgresql_configuration", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_configuration{Azurerm_postgresql_configuration_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_postgresql_configuration", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_postgresql_configurationHandler) Read(externalID string) (*Azurerm_postgresql_configuration, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_postgresql_configuration", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_postgresql_configuration", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_configuration{Azurerm_postgresql_configuration_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_postgresql_configuration", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_postgresql_configurationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_postgresql_configuration", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_postgresql_configuration", externalID)
}

type Azurerm_postgresql_database struct {
	Azurerm_postgresql_database_id *string `lyra:"ignore"`

	Charset string

	Collation string

	Name string

	Resource_group_name string

	Server_name string
}

var Azurerm_postgresql_database_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_postgresql_database_id",
	)
	rtb.ImmutableAttributes(

		"charset",

		"collation",

		"name",

		"resource_group_name",

		"server_name",
	)
}

// Azurerm_postgresql_databaseHandler ...
type Azurerm_postgresql_databaseHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_postgresql_databaseHandler) Create(desired *Azurerm_postgresql_database) (*Azurerm_postgresql_database, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_postgresql_database", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_postgresql_database", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_postgresql_databaseHandler) Update(externalID string, desired *Azurerm_postgresql_database) (*Azurerm_postgresql_database, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_postgresql_database", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_postgresql_database", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_database{Azurerm_postgresql_database_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_postgresql_database", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_postgresql_databaseHandler) Read(externalID string) (*Azurerm_postgresql_database, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_postgresql_database", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_postgresql_database", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_database{Azurerm_postgresql_database_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_postgresql_database", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_postgresql_databaseHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_postgresql_database", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_postgresql_database", externalID)
}

type Azurerm_postgresql_firewall_rule struct {
	Azurerm_postgresql_firewall_rule_id *string `lyra:"ignore"`

	End_ip_address string

	Name string

	Resource_group_name string

	Server_name string

	Start_ip_address string
}

var Azurerm_postgresql_firewall_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_postgresql_firewall_rule_id",
	)
	rtb.ImmutableAttributes(

		"end_ip_address",

		"name",

		"resource_group_name",

		"server_name",

		"start_ip_address",
	)
}

// Azurerm_postgresql_firewall_ruleHandler ...
type Azurerm_postgresql_firewall_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_postgresql_firewall_ruleHandler) Create(desired *Azurerm_postgresql_firewall_rule) (*Azurerm_postgresql_firewall_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_postgresql_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_postgresql_firewall_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_postgresql_firewall_ruleHandler) Update(externalID string, desired *Azurerm_postgresql_firewall_rule) (*Azurerm_postgresql_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_postgresql_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_postgresql_firewall_rule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_firewall_rule{Azurerm_postgresql_firewall_rule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_postgresql_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_postgresql_firewall_ruleHandler) Read(externalID string) (*Azurerm_postgresql_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_postgresql_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_postgresql_firewall_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_firewall_rule{Azurerm_postgresql_firewall_rule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_postgresql_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_postgresql_firewall_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_postgresql_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_postgresql_firewall_rule", externalID)
}

type Azurerm_postgresql_server_sku_171 struct {
	Capacity int

	Family string

	Name string

	Tier string
}

type Azurerm_postgresql_server_storage_profile_172 struct {
	Backup_retention_days *int

	Geo_redundant_backup *string

	Storage_mb int
}

type Azurerm_postgresql_server struct {
	Azurerm_postgresql_server_id *string `lyra:"ignore"`

	Administrator_login string

	Administrator_login_password string

	Fqdn *string

	Location string

	Name string

	Resource_group_name string

	Sku []Azurerm_postgresql_server_sku_171

	Ssl_enforcement string

	Storage_profile []Azurerm_postgresql_server_storage_profile_172

	Tags *map[string]string

	Version string
}

var Azurerm_postgresql_server_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_postgresql_server_id",

		"fqdn",

		"tags",
	)
	rtb.ImmutableAttributes(

		"administrator_login",

		"location",

		"name",

		"resource_group_name",

		"version",
	)
}

// Azurerm_postgresql_serverHandler ...
type Azurerm_postgresql_serverHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_postgresql_serverHandler) Create(desired *Azurerm_postgresql_server) (*Azurerm_postgresql_server, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_postgresql_server", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_postgresql_server", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_postgresql_serverHandler) Update(externalID string, desired *Azurerm_postgresql_server) (*Azurerm_postgresql_server, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_postgresql_server", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_postgresql_server", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_server{Azurerm_postgresql_server_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_postgresql_server", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_postgresql_serverHandler) Read(externalID string) (*Azurerm_postgresql_server, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_postgresql_server", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_postgresql_server", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_server{Azurerm_postgresql_server_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_postgresql_server", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_postgresql_serverHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_postgresql_server", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_postgresql_server", externalID)
}

type Azurerm_postgresql_virtual_network_rule struct {
	Azurerm_postgresql_virtual_network_rule_id *string `lyra:"ignore"`

	Ignore_missing_vnet_service_endpoint *bool

	Name string

	Resource_group_name string

	Server_name string

	Subnet_id string
}

var Azurerm_postgresql_virtual_network_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_postgresql_virtual_network_rule_id",

		"ignore_missing_vnet_service_endpoint",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"server_name",
	)
}

// Azurerm_postgresql_virtual_network_ruleHandler ...
type Azurerm_postgresql_virtual_network_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_postgresql_virtual_network_ruleHandler) Create(desired *Azurerm_postgresql_virtual_network_rule) (*Azurerm_postgresql_virtual_network_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_postgresql_virtual_network_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_postgresql_virtual_network_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_postgresql_virtual_network_ruleHandler) Update(externalID string, desired *Azurerm_postgresql_virtual_network_rule) (*Azurerm_postgresql_virtual_network_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_postgresql_virtual_network_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_postgresql_virtual_network_rule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_virtual_network_rule{Azurerm_postgresql_virtual_network_rule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_postgresql_virtual_network_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_postgresql_virtual_network_ruleHandler) Read(externalID string) (*Azurerm_postgresql_virtual_network_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_postgresql_virtual_network_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_postgresql_virtual_network_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_postgresql_virtual_network_rule{Azurerm_postgresql_virtual_network_rule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_postgresql_virtual_network_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_postgresql_virtual_network_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_postgresql_virtual_network_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_postgresql_virtual_network_rule", externalID)
}

type Azurerm_public_ip struct {
	Azurerm_public_ip_id *string `lyra:"ignore"`

	Allocation_method *string

	Domain_name_label *string

	Fqdn *string

	Idle_timeout_in_minutes *int

	Ip_address *string

	Ip_version *string

	Location string

	Name string

	Public_ip_address_allocation *string

	Resource_group_name string

	Reverse_fqdn *string

	Sku *string

	Tags *map[string]string

	Zones *[]string
}

var Azurerm_public_ip_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_public_ip_id",

		"allocation_method",

		"domain_name_label",

		"fqdn",

		"idle_timeout_in_minutes",

		"ip_address",

		"ip_version",

		"public_ip_address_allocation",

		"reverse_fqdn",

		"sku",

		"tags",

		"zones",
	)
	rtb.ImmutableAttributes(

		"ip_version",

		"location",

		"name",

		"resource_group_name",

		"sku",

		"zones",
	)
}

// Azurerm_public_ipHandler ...
type Azurerm_public_ipHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_public_ipHandler) Create(desired *Azurerm_public_ip) (*Azurerm_public_ip, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_public_ip", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_public_ip", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_public_ipHandler) Update(externalID string, desired *Azurerm_public_ip) (*Azurerm_public_ip, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_public_ip", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_public_ip", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_public_ip{Azurerm_public_ip_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_public_ip", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_public_ipHandler) Read(externalID string) (*Azurerm_public_ip, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_public_ip", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_public_ip", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_public_ip{Azurerm_public_ip_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_public_ip", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_public_ipHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_public_ip", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_public_ip", externalID)
}

type Azurerm_recovery_services_protected_vm struct {
	Azurerm_recovery_services_protected_vm_id *string `lyra:"ignore"`

	Backup_policy_id string

	Recovery_vault_name string

	Resource_group_name string

	Source_vm_id string

	Tags *map[string]string
}

var Azurerm_recovery_services_protected_vm_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_recovery_services_protected_vm_id",

		"tags",
	)
	rtb.ImmutableAttributes(

		"backup_policy_id",

		"recovery_vault_name",

		"resource_group_name",

		"source_vm_id",
	)
}

// Azurerm_recovery_services_protected_vmHandler ...
type Azurerm_recovery_services_protected_vmHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_recovery_services_protected_vmHandler) Create(desired *Azurerm_recovery_services_protected_vm) (*Azurerm_recovery_services_protected_vm, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_recovery_services_protected_vm", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_recovery_services_protected_vm", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_recovery_services_protected_vmHandler) Update(externalID string, desired *Azurerm_recovery_services_protected_vm) (*Azurerm_recovery_services_protected_vm, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_recovery_services_protected_vm", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_recovery_services_protected_vm", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_recovery_services_protected_vm{Azurerm_recovery_services_protected_vm_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_recovery_services_protected_vm", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_recovery_services_protected_vmHandler) Read(externalID string) (*Azurerm_recovery_services_protected_vm, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_recovery_services_protected_vm", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_recovery_services_protected_vm", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_recovery_services_protected_vm{Azurerm_recovery_services_protected_vm_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_recovery_services_protected_vm", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_recovery_services_protected_vmHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_recovery_services_protected_vm", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_recovery_services_protected_vm", externalID)
}

type Azurerm_recovery_services_protection_policy_vm_backup_173 struct {
	Frequency string

	Time string

	Weekdays *[]string
}

type Azurerm_recovery_services_protection_policy_vm_retention_daily_174 struct {
	Count int
}

type Azurerm_recovery_services_protection_policy_vm_retention_monthly_175 struct {
	Count int

	Weekdays []string

	Weeks []string
}

type Azurerm_recovery_services_protection_policy_vm_retention_weekly_176 struct {
	Count int

	Weekdays []string
}

type Azurerm_recovery_services_protection_policy_vm_retention_yearly_177 struct {
	Count int

	Months []string

	Weekdays []string

	Weeks []string
}

type Azurerm_recovery_services_protection_policy_vm struct {
	Azurerm_recovery_services_protection_policy_vm_id *string `lyra:"ignore"`

	Backup []Azurerm_recovery_services_protection_policy_vm_backup_173

	Name string

	Recovery_vault_name string

	Resource_group_name string

	Retention_daily *[]Azurerm_recovery_services_protection_policy_vm_retention_daily_174

	Retention_monthly *[]Azurerm_recovery_services_protection_policy_vm_retention_monthly_175

	Retention_weekly *[]Azurerm_recovery_services_protection_policy_vm_retention_weekly_176

	Retention_yearly *[]Azurerm_recovery_services_protection_policy_vm_retention_yearly_177

	Tags *map[string]string

	Timezone *string
}

var Azurerm_recovery_services_protection_policy_vm_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_recovery_services_protection_policy_vm_id",

		"retention_daily",

		"retention_monthly",

		"retention_weekly",

		"retention_yearly",

		"tags",

		"timezone",
	)
	rtb.ImmutableAttributes(

		"name",

		"recovery_vault_name",

		"resource_group_name",
	)
}

// Azurerm_recovery_services_protection_policy_vmHandler ...
type Azurerm_recovery_services_protection_policy_vmHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_recovery_services_protection_policy_vmHandler) Create(desired *Azurerm_recovery_services_protection_policy_vm) (*Azurerm_recovery_services_protection_policy_vm, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_recovery_services_protection_policy_vm", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_recovery_services_protection_policy_vm", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_recovery_services_protection_policy_vmHandler) Update(externalID string, desired *Azurerm_recovery_services_protection_policy_vm) (*Azurerm_recovery_services_protection_policy_vm, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_recovery_services_protection_policy_vm", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_recovery_services_protection_policy_vm", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_recovery_services_protection_policy_vm{Azurerm_recovery_services_protection_policy_vm_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_recovery_services_protection_policy_vm", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_recovery_services_protection_policy_vmHandler) Read(externalID string) (*Azurerm_recovery_services_protection_policy_vm, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_recovery_services_protection_policy_vm", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_recovery_services_protection_policy_vm", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_recovery_services_protection_policy_vm{Azurerm_recovery_services_protection_policy_vm_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_recovery_services_protection_policy_vm", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_recovery_services_protection_policy_vmHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_recovery_services_protection_policy_vm", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_recovery_services_protection_policy_vm", externalID)
}

type Azurerm_recovery_services_vault struct {
	Azurerm_recovery_services_vault_id *string `lyra:"ignore"`

	Location string

	Name string

	Resource_group_name string

	Sku string

	Tags *map[string]string
}

var Azurerm_recovery_services_vault_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_recovery_services_vault_id",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_recovery_services_vaultHandler ...
type Azurerm_recovery_services_vaultHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_recovery_services_vaultHandler) Create(desired *Azurerm_recovery_services_vault) (*Azurerm_recovery_services_vault, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_recovery_services_vault", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_recovery_services_vault", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_recovery_services_vaultHandler) Update(externalID string, desired *Azurerm_recovery_services_vault) (*Azurerm_recovery_services_vault, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_recovery_services_vault", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_recovery_services_vault", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_recovery_services_vault{Azurerm_recovery_services_vault_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_recovery_services_vault", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_recovery_services_vaultHandler) Read(externalID string) (*Azurerm_recovery_services_vault, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_recovery_services_vault", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_recovery_services_vault", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_recovery_services_vault{Azurerm_recovery_services_vault_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_recovery_services_vault", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_recovery_services_vaultHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_recovery_services_vault", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_recovery_services_vault", externalID)
}

type Azurerm_redis_cache_patch_schedule_178 struct {
	Day_of_week string

	Start_hour_utc *int
}

type Azurerm_redis_cache_redis_configuration_179 struct {
	Maxclients *int

	Maxmemory_delta *int

	Maxmemory_policy *string

	Maxmemory_reserved *int

	Notify_keyspace_events *string

	Rdb_backup_enabled *bool

	Rdb_backup_frequency *int

	Rdb_backup_max_snapshot_count *int

	Rdb_storage_connection_string *string
}

type Azurerm_redis_cache struct {
	Azurerm_redis_cache_id *string `lyra:"ignore"`

	Capacity int

	Enable_non_ssl_port *bool

	Family string

	Hostname *string

	Location string

	Name string

	Patch_schedule *[]Azurerm_redis_cache_patch_schedule_178

	Port *int

	Primary_access_key *string

	Private_static_ip_address *string

	Redis_configuration []Azurerm_redis_cache_redis_configuration_179

	Resource_group_name string

	Secondary_access_key *string

	Shard_count *int

	Sku_name string

	Ssl_port *int

	Subnet_id *string

	Tags *map[string]string

	Zones *[]string
}

var Azurerm_redis_cache_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_redis_cache_id",

		"enable_non_ssl_port",

		"hostname",

		"patch_schedule",

		"port",

		"primary_access_key",

		"private_static_ip_address",

		"secondary_access_key",

		"shard_count",

		"ssl_port",

		"subnet_id",

		"tags",

		"zones",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"private_static_ip_address",

		"resource_group_name",

		"subnet_id",

		"zones",
	)
}

// Azurerm_redis_cacheHandler ...
type Azurerm_redis_cacheHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_redis_cacheHandler) Create(desired *Azurerm_redis_cache) (*Azurerm_redis_cache, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_redis_cache", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_redis_cache", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_redis_cacheHandler) Update(externalID string, desired *Azurerm_redis_cache) (*Azurerm_redis_cache, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_redis_cache", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_redis_cache", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_redis_cache{Azurerm_redis_cache_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_redis_cache", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_redis_cacheHandler) Read(externalID string) (*Azurerm_redis_cache, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_redis_cache", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_redis_cache", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_redis_cache{Azurerm_redis_cache_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_redis_cache", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_redis_cacheHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_redis_cache", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_redis_cache", externalID)
}

type Azurerm_redis_firewall_rule struct {
	Azurerm_redis_firewall_rule_id *string `lyra:"ignore"`

	End_ip string

	Name string

	Redis_cache_name string

	Resource_group_name string

	Start_ip string
}

var Azurerm_redis_firewall_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_redis_firewall_rule_id",
	)
	rtb.ImmutableAttributes(

		"name",

		"redis_cache_name",

		"resource_group_name",
	)
}

// Azurerm_redis_firewall_ruleHandler ...
type Azurerm_redis_firewall_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_redis_firewall_ruleHandler) Create(desired *Azurerm_redis_firewall_rule) (*Azurerm_redis_firewall_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_redis_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_redis_firewall_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_redis_firewall_ruleHandler) Update(externalID string, desired *Azurerm_redis_firewall_rule) (*Azurerm_redis_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_redis_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_redis_firewall_rule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_redis_firewall_rule{Azurerm_redis_firewall_rule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_redis_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_redis_firewall_ruleHandler) Read(externalID string) (*Azurerm_redis_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_redis_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_redis_firewall_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_redis_firewall_rule{Azurerm_redis_firewall_rule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_redis_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_redis_firewall_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_redis_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_redis_firewall_rule", externalID)
}

type Azurerm_relay_namespace_sku_180 struct {
	Name string
}

type Azurerm_relay_namespace struct {
	Azurerm_relay_namespace_id *string `lyra:"ignore"`

	Location string

	Metric_id *string

	Name string

	Primary_connection_string *string

	Primary_key *string

	Resource_group_name string

	Secondary_connection_string *string

	Secondary_key *string

	Sku []Azurerm_relay_namespace_sku_180

	Tags *map[string]string
}

var Azurerm_relay_namespace_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_relay_namespace_id",

		"metric_id",

		"primary_connection_string",

		"primary_key",

		"secondary_connection_string",

		"secondary_key",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_relay_namespaceHandler ...
type Azurerm_relay_namespaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_relay_namespaceHandler) Create(desired *Azurerm_relay_namespace) (*Azurerm_relay_namespace, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_relay_namespace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_relay_namespace", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_relay_namespaceHandler) Update(externalID string, desired *Azurerm_relay_namespace) (*Azurerm_relay_namespace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_relay_namespace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_relay_namespace", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_relay_namespace{Azurerm_relay_namespace_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_relay_namespace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_relay_namespaceHandler) Read(externalID string) (*Azurerm_relay_namespace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_relay_namespace", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_relay_namespace", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_relay_namespace{Azurerm_relay_namespace_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_relay_namespace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_relay_namespaceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_relay_namespace", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_relay_namespace", externalID)
}

type Azurerm_resource_group struct {
	Azurerm_resource_group_id *string `lyra:"ignore"`

	Location string

	Name string

	Tags *map[string]string
}

var Azurerm_resource_group_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_resource_group_id",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",
	)
}

// Azurerm_resource_groupHandler ...
type Azurerm_resource_groupHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_resource_groupHandler) Create(desired *Azurerm_resource_group) (*Azurerm_resource_group, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_resource_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_resource_group", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_resource_groupHandler) Update(externalID string, desired *Azurerm_resource_group) (*Azurerm_resource_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_resource_group", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_resource_group", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_resource_group{Azurerm_resource_group_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_resource_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_resource_groupHandler) Read(externalID string) (*Azurerm_resource_group, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_resource_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_resource_group", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_resource_group{Azurerm_resource_group_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_resource_group", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_resource_groupHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_resource_group", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_resource_group", externalID)
}

type Azurerm_role_assignment struct {
	Azurerm_role_assignment_id *string `lyra:"ignore"`

	Name *string

	Principal_id string

	Role_definition_id *string

	Role_definition_name *string

	Scope string
}

var Azurerm_role_assignment_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_role_assignment_id",

		"name",

		"role_definition_id",

		"role_definition_name",
	)
	rtb.ImmutableAttributes(

		"name",

		"principal_id",

		"role_definition_id",

		"role_definition_name",

		"scope",
	)
}

// Azurerm_role_assignmentHandler ...
type Azurerm_role_assignmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_role_assignmentHandler) Create(desired *Azurerm_role_assignment) (*Azurerm_role_assignment, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_role_assignment", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_role_assignment", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_role_assignmentHandler) Update(externalID string, desired *Azurerm_role_assignment) (*Azurerm_role_assignment, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_role_assignment", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_role_assignment", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_role_assignment{Azurerm_role_assignment_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_role_assignment", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_role_assignmentHandler) Read(externalID string) (*Azurerm_role_assignment, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_role_assignment", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_role_assignment", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_role_assignment{Azurerm_role_assignment_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_role_assignment", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_role_assignmentHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_role_assignment", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_role_assignment", externalID)
}

type Azurerm_role_definition_permissions_181 struct {
	Actions *[]string

	Data_actions *[]string

	Not_actions *[]string

	Not_data_actions *[]string
}

type Azurerm_role_definition struct {
	Azurerm_role_definition_id *string `lyra:"ignore"`

	Assignable_scopes []string

	Description *string

	Name string

	Permissions []Azurerm_role_definition_permissions_181

	Role_definition_id *string

	Scope string
}

var Azurerm_role_definition_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_role_definition_id",

		"description",

		"role_definition_id",
	)
	rtb.ImmutableAttributes(

		"role_definition_id",

		"scope",
	)
}

// Azurerm_role_definitionHandler ...
type Azurerm_role_definitionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_role_definitionHandler) Create(desired *Azurerm_role_definition) (*Azurerm_role_definition, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_role_definition", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_role_definition", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_role_definitionHandler) Update(externalID string, desired *Azurerm_role_definition) (*Azurerm_role_definition, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_role_definition", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_role_definition", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_role_definition{Azurerm_role_definition_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_role_definition", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_role_definitionHandler) Read(externalID string) (*Azurerm_role_definition, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_role_definition", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_role_definition", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_role_definition{Azurerm_role_definition_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_role_definition", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_role_definitionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_role_definition", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_role_definition", externalID)
}

type Azurerm_route struct {
	Azurerm_route_id *string `lyra:"ignore"`

	Address_prefix string

	Name string

	Next_hop_in_ip_address *string

	Next_hop_type string

	Resource_group_name string

	Route_table_name string
}

var Azurerm_route_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_route_id",

		"next_hop_in_ip_address",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"route_table_name",
	)
}

// Azurerm_routeHandler ...
type Azurerm_routeHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_routeHandler) Create(desired *Azurerm_route) (*Azurerm_route, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_route", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_route", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_routeHandler) Update(externalID string, desired *Azurerm_route) (*Azurerm_route, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_route", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_route", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_route{Azurerm_route_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_route", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_routeHandler) Read(externalID string) (*Azurerm_route, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_route", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_route", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_route{Azurerm_route_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_route", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_routeHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_route", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_route", externalID)
}

type Azurerm_route_table_route_182 struct {
	Address_prefix string

	Name string

	Next_hop_in_ip_address *string

	Next_hop_type string
}

type Azurerm_route_table struct {
	Azurerm_route_table_id *string `lyra:"ignore"`

	Disable_bgp_route_propagation *bool

	Location string

	Name string

	Resource_group_name string

	Route *[]Azurerm_route_table_route_182

	Subnets *[]string

	Tags *map[string]string
}

var Azurerm_route_table_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_route_table_id",

		"disable_bgp_route_propagation",

		"route",

		"subnets",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_route_tableHandler ...
type Azurerm_route_tableHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_route_tableHandler) Create(desired *Azurerm_route_table) (*Azurerm_route_table, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_route_table", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_route_table", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_route_tableHandler) Update(externalID string, desired *Azurerm_route_table) (*Azurerm_route_table, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_route_table", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_route_table", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_route_table{Azurerm_route_table_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_route_table", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_route_tableHandler) Read(externalID string) (*Azurerm_route_table, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_route_table", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_route_table", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_route_table{Azurerm_route_table_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_route_table", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_route_tableHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_route_table", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_route_table", externalID)
}

type Azurerm_scheduler_job_action_storage_queue_183 struct {
	Message string

	Sas_token string

	Storage_account_name string

	Storage_queue_name string
}

type Azurerm_scheduler_job_action_web_184_authentication_active_directory_185 struct {
	Audience *string

	Client_id string

	Secret string

	Tenant_id string
}

type Azurerm_scheduler_job_action_web_184_authentication_basic_186 struct {
	Password string

	Username string
}

type Azurerm_scheduler_job_action_web_184_authentication_certificate_187 struct {
	Expiration *string

	Password string

	Pfx string

	Subject_name *string

	Thumbprint *string
}

type Azurerm_scheduler_job_action_web_184 struct {
	Authentication_active_directory *[]Azurerm_scheduler_job_action_web_184_authentication_active_directory_185

	Authentication_basic *[]Azurerm_scheduler_job_action_web_184_authentication_basic_186

	Authentication_certificate *[]Azurerm_scheduler_job_action_web_184_authentication_certificate_187

	Body *string

	Headers *map[string]string

	Method string

	Url string
}

type Azurerm_scheduler_job_error_action_storage_queue_188 struct {
	Message string

	Sas_token string

	Storage_account_name string

	Storage_queue_name string
}

type Azurerm_scheduler_job_error_action_web_189_authentication_active_directory_190 struct {
	Audience *string

	Client_id string

	Secret string

	Tenant_id string
}

type Azurerm_scheduler_job_error_action_web_189_authentication_basic_191 struct {
	Password string

	Username string
}

type Azurerm_scheduler_job_error_action_web_189_authentication_certificate_192 struct {
	Expiration *string

	Password string

	Pfx string

	Subject_name *string

	Thumbprint *string
}

type Azurerm_scheduler_job_error_action_web_189 struct {
	Authentication_active_directory *[]Azurerm_scheduler_job_error_action_web_189_authentication_active_directory_190

	Authentication_basic *[]Azurerm_scheduler_job_error_action_web_189_authentication_basic_191

	Authentication_certificate *[]Azurerm_scheduler_job_error_action_web_189_authentication_certificate_192

	Body *string

	Headers *map[string]string

	Method string

	Url string
}

type Azurerm_scheduler_job_recurrence_193_monthly_occurrences_194 struct {
	Day string

	Occurrence int
}

type Azurerm_scheduler_job_recurrence_193 struct {
	Count *int

	End_time *string

	Frequency string

	Hours *[]int

	Interval *int

	Minutes *[]int

	Month_days *[]int

	Monthly_occurrences *[]Azurerm_scheduler_job_recurrence_193_monthly_occurrences_194

	Week_days *[]string
}

type Azurerm_scheduler_job_retry_195 struct {
	Count *int

	Interval *string
}

type Azurerm_scheduler_job struct {
	Azurerm_scheduler_job_id *string `lyra:"ignore"`

	Action_storage_queue *[]Azurerm_scheduler_job_action_storage_queue_183

	Action_web *[]Azurerm_scheduler_job_action_web_184

	Error_action_storage_queue *[]Azurerm_scheduler_job_error_action_storage_queue_188

	Error_action_web *[]Azurerm_scheduler_job_error_action_web_189

	Job_collection_name string

	Name string

	Recurrence *[]Azurerm_scheduler_job_recurrence_193

	Resource_group_name string

	Retry *[]Azurerm_scheduler_job_retry_195

	Start_time *string

	State *string
}

var Azurerm_scheduler_job_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_scheduler_job_id",

		"action_storage_queue",

		"action_web",

		"error_action_storage_queue",

		"error_action_web",

		"recurrence",

		"retry",

		"start_time",

		"state",
	)
	rtb.ImmutableAttributes(

		"job_collection_name",

		"name",

		"resource_group_name",
	)
}

// Azurerm_scheduler_jobHandler ...
type Azurerm_scheduler_jobHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_scheduler_jobHandler) Create(desired *Azurerm_scheduler_job) (*Azurerm_scheduler_job, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_scheduler_job", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_scheduler_job", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_scheduler_jobHandler) Update(externalID string, desired *Azurerm_scheduler_job) (*Azurerm_scheduler_job, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_scheduler_job", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_scheduler_job", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_scheduler_job{Azurerm_scheduler_job_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_scheduler_job", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_scheduler_jobHandler) Read(externalID string) (*Azurerm_scheduler_job, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_scheduler_job", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_scheduler_job", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_scheduler_job{Azurerm_scheduler_job_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_scheduler_job", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_scheduler_jobHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_scheduler_job", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_scheduler_job", externalID)
}

type Azurerm_scheduler_job_collection_quota_196 struct {
	Max_job_count *int

	Max_recurrence_frequency string

	Max_recurrence_interval *int

	Max_retry_interval *int
}

type Azurerm_scheduler_job_collection struct {
	Azurerm_scheduler_job_collection_id *string `lyra:"ignore"`

	Location string

	Name string

	Quota *[]Azurerm_scheduler_job_collection_quota_196

	Resource_group_name string

	Sku string

	State *string

	Tags *map[string]string
}

var Azurerm_scheduler_job_collection_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_scheduler_job_collection_id",

		"quota",

		"state",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_scheduler_job_collectionHandler ...
type Azurerm_scheduler_job_collectionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_scheduler_job_collectionHandler) Create(desired *Azurerm_scheduler_job_collection) (*Azurerm_scheduler_job_collection, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_scheduler_job_collection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_scheduler_job_collection", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_scheduler_job_collectionHandler) Update(externalID string, desired *Azurerm_scheduler_job_collection) (*Azurerm_scheduler_job_collection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_scheduler_job_collection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_scheduler_job_collection", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_scheduler_job_collection{Azurerm_scheduler_job_collection_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_scheduler_job_collection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_scheduler_job_collectionHandler) Read(externalID string) (*Azurerm_scheduler_job_collection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_scheduler_job_collection", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_scheduler_job_collection", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_scheduler_job_collection{Azurerm_scheduler_job_collection_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_scheduler_job_collection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_scheduler_job_collectionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_scheduler_job_collection", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_scheduler_job_collection", externalID)
}

type Azurerm_search_service struct {
	Azurerm_search_service_id *string `lyra:"ignore"`

	Location string

	Name string

	Partition_count *int

	Primary_key *string

	Replica_count *int

	Resource_group_name string

	Secondary_key *string

	Sku string

	Tags *map[string]string
}

var Azurerm_search_service_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_search_service_id",

		"partition_count",

		"primary_key",

		"replica_count",

		"secondary_key",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"partition_count",

		"replica_count",

		"resource_group_name",

		"sku",

		"tags",
	)
}

// Azurerm_search_serviceHandler ...
type Azurerm_search_serviceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_search_serviceHandler) Create(desired *Azurerm_search_service) (*Azurerm_search_service, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_search_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_search_service", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_search_serviceHandler) Update(externalID string, desired *Azurerm_search_service) (*Azurerm_search_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_search_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_search_service", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_search_service{Azurerm_search_service_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_search_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_search_serviceHandler) Read(externalID string) (*Azurerm_search_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_search_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_search_service", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_search_service{Azurerm_search_service_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_search_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_search_serviceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_search_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_search_service", externalID)
}

type Azurerm_security_center_contact struct {
	Azurerm_security_center_contact_id *string `lyra:"ignore"`

	Alert_notifications bool

	Alerts_to_admins bool

	Email string

	Phone string
}

var Azurerm_security_center_contact_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_security_center_contact_id",
	)
	rtb.ImmutableAttributes()
}

// Azurerm_security_center_contactHandler ...
type Azurerm_security_center_contactHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_security_center_contactHandler) Create(desired *Azurerm_security_center_contact) (*Azurerm_security_center_contact, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_security_center_contact", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_security_center_contact", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_security_center_contactHandler) Update(externalID string, desired *Azurerm_security_center_contact) (*Azurerm_security_center_contact, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_security_center_contact", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_security_center_contact", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_security_center_contact{Azurerm_security_center_contact_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_security_center_contact", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_security_center_contactHandler) Read(externalID string) (*Azurerm_security_center_contact, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_security_center_contact", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_security_center_contact", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_security_center_contact{Azurerm_security_center_contact_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_security_center_contact", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_security_center_contactHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_security_center_contact", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_security_center_contact", externalID)
}

type Azurerm_security_center_subscription_pricing struct {
	Azurerm_security_center_subscription_pricing_id *string `lyra:"ignore"`

	Tier string
}

var Azurerm_security_center_subscription_pricing_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_security_center_subscription_pricing_id",
	)
	rtb.ImmutableAttributes()
}

// Azurerm_security_center_subscription_pricingHandler ...
type Azurerm_security_center_subscription_pricingHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_security_center_subscription_pricingHandler) Create(desired *Azurerm_security_center_subscription_pricing) (*Azurerm_security_center_subscription_pricing, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_security_center_subscription_pricing", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_security_center_subscription_pricing", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_security_center_subscription_pricingHandler) Update(externalID string, desired *Azurerm_security_center_subscription_pricing) (*Azurerm_security_center_subscription_pricing, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_security_center_subscription_pricing", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_security_center_subscription_pricing", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_security_center_subscription_pricing{Azurerm_security_center_subscription_pricing_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_security_center_subscription_pricing", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_security_center_subscription_pricingHandler) Read(externalID string) (*Azurerm_security_center_subscription_pricing, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_security_center_subscription_pricing", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_security_center_subscription_pricing", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_security_center_subscription_pricing{Azurerm_security_center_subscription_pricing_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_security_center_subscription_pricing", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_security_center_subscription_pricingHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_security_center_subscription_pricing", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_security_center_subscription_pricing", externalID)
}

type Azurerm_security_center_workspace struct {
	Azurerm_security_center_workspace_id *string `lyra:"ignore"`

	Scope string

	Workspace_id string
}

var Azurerm_security_center_workspace_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_security_center_workspace_id",
	)
	rtb.ImmutableAttributes()
}

// Azurerm_security_center_workspaceHandler ...
type Azurerm_security_center_workspaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_security_center_workspaceHandler) Create(desired *Azurerm_security_center_workspace) (*Azurerm_security_center_workspace, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_security_center_workspace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_security_center_workspace", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_security_center_workspaceHandler) Update(externalID string, desired *Azurerm_security_center_workspace) (*Azurerm_security_center_workspace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_security_center_workspace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_security_center_workspace", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_security_center_workspace{Azurerm_security_center_workspace_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_security_center_workspace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_security_center_workspaceHandler) Read(externalID string) (*Azurerm_security_center_workspace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_security_center_workspace", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_security_center_workspace", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_security_center_workspace{Azurerm_security_center_workspace_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_security_center_workspace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_security_center_workspaceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_security_center_workspace", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_security_center_workspace", externalID)
}

type Azurerm_service_fabric_cluster_azure_active_directory_197 struct {
	Client_application_id string

	Cluster_application_id string

	Tenant_id string
}

type Azurerm_service_fabric_cluster_certificate_198 struct {
	Thumbprint string

	Thumbprint_secondary *string

	X509_store_name string
}

type Azurerm_service_fabric_cluster_client_certificate_thumbprint_199 struct {
	Is_admin bool

	Thumbprint string
}

type Azurerm_service_fabric_cluster_diagnostics_config_200 struct {
	Blob_endpoint string

	Protected_account_key_name string

	Queue_endpoint string

	Storage_account_name string

	Table_endpoint string
}

type Azurerm_service_fabric_cluster_fabric_settings_201 struct {
	Name string

	Parameters *map[string]string
}

type Azurerm_service_fabric_cluster_node_type_202_application_ports_203 struct {
	End_port int

	Start_port int
}

type Azurerm_service_fabric_cluster_node_type_202_ephemeral_ports_204 struct {
	End_port int

	Start_port int
}

type Azurerm_service_fabric_cluster_node_type_202 struct {
	Application_ports *[]Azurerm_service_fabric_cluster_node_type_202_application_ports_203

	Client_endpoint_port int

	Durability_level *string

	Ephemeral_ports *[]Azurerm_service_fabric_cluster_node_type_202_ephemeral_ports_204

	Http_endpoint_port int

	Instance_count int

	Is_primary bool

	Name string

	Reverse_proxy_endpoint_port *int
}

type Azurerm_service_fabric_cluster_reverse_proxy_certificate_205 struct {
	Thumbprint string

	Thumbprint_secondary *string

	X509_store_name string
}

type Azurerm_service_fabric_cluster struct {
	Azurerm_service_fabric_cluster_id *string `lyra:"ignore"`

	Add_on_features *[]string

	Azure_active_directory *[]Azurerm_service_fabric_cluster_azure_active_directory_197

	Certificate *[]Azurerm_service_fabric_cluster_certificate_198

	Client_certificate_thumbprint *[]Azurerm_service_fabric_cluster_client_certificate_thumbprint_199

	Cluster_code_version *string

	Cluster_endpoint *string

	Diagnostics_config *[]Azurerm_service_fabric_cluster_diagnostics_config_200

	Fabric_settings *[]Azurerm_service_fabric_cluster_fabric_settings_201

	Location string

	Management_endpoint string

	Name string

	Node_type []Azurerm_service_fabric_cluster_node_type_202

	Reliability_level string

	Resource_group_name string

	Reverse_proxy_certificate *[]Azurerm_service_fabric_cluster_reverse_proxy_certificate_205

	Tags *map[string]string

	Upgrade_mode string

	Vm_image string
}

var Azurerm_service_fabric_cluster_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_service_fabric_cluster_id",

		"add_on_features",

		"azure_active_directory",

		"certificate",

		"client_certificate_thumbprint",

		"cluster_code_version",

		"cluster_endpoint",

		"diagnostics_config",

		"fabric_settings",

		"reverse_proxy_certificate",

		"tags",
	)
	rtb.ImmutableAttributes(

		"azure_active_directory",

		"diagnostics_config",

		"location",

		"management_endpoint",

		"name",

		"resource_group_name",

		"vm_image",
	)
}

// Azurerm_service_fabric_clusterHandler ...
type Azurerm_service_fabric_clusterHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_service_fabric_clusterHandler) Create(desired *Azurerm_service_fabric_cluster) (*Azurerm_service_fabric_cluster, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_service_fabric_cluster", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_service_fabric_cluster", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_service_fabric_clusterHandler) Update(externalID string, desired *Azurerm_service_fabric_cluster) (*Azurerm_service_fabric_cluster, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_service_fabric_cluster", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_service_fabric_cluster", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_service_fabric_cluster{Azurerm_service_fabric_cluster_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_service_fabric_cluster", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_service_fabric_clusterHandler) Read(externalID string) (*Azurerm_service_fabric_cluster, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_service_fabric_cluster", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_service_fabric_cluster", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_service_fabric_cluster{Azurerm_service_fabric_cluster_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_service_fabric_cluster", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_service_fabric_clusterHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_service_fabric_cluster", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_service_fabric_cluster", externalID)
}

type Azurerm_servicebus_namespace struct {
	Azurerm_servicebus_namespace_id *string `lyra:"ignore"`

	Capacity *int

	Default_primary_connection_string *string

	Default_primary_key *string

	Default_secondary_connection_string *string

	Default_secondary_key *string

	Location string

	Name string

	Resource_group_name string

	Sku string

	Tags *map[string]string
}

var Azurerm_servicebus_namespace_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_servicebus_namespace_id",

		"capacity",

		"default_primary_connection_string",

		"default_primary_key",

		"default_secondary_connection_string",

		"default_secondary_key",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"sku",
	)
}

// Azurerm_servicebus_namespaceHandler ...
type Azurerm_servicebus_namespaceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_servicebus_namespaceHandler) Create(desired *Azurerm_servicebus_namespace) (*Azurerm_servicebus_namespace, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_servicebus_namespace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_servicebus_namespace", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_servicebus_namespaceHandler) Update(externalID string, desired *Azurerm_servicebus_namespace) (*Azurerm_servicebus_namespace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_servicebus_namespace", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_servicebus_namespace", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_namespace{Azurerm_servicebus_namespace_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_servicebus_namespace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_servicebus_namespaceHandler) Read(externalID string) (*Azurerm_servicebus_namespace, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_servicebus_namespace", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_servicebus_namespace", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_namespace{Azurerm_servicebus_namespace_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_servicebus_namespace", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_servicebus_namespaceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_servicebus_namespace", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_servicebus_namespace", externalID)
}

type Azurerm_servicebus_namespace_authorization_rule struct {
	Azurerm_servicebus_namespace_authorization_rule_id *string `lyra:"ignore"`

	Listen *bool

	Manage *bool

	Name string

	Namespace_name string

	Primary_connection_string *string

	Primary_key *string

	Resource_group_name string

	Secondary_connection_string *string

	Secondary_key *string

	Send *bool
}

var Azurerm_servicebus_namespace_authorization_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_servicebus_namespace_authorization_rule_id",

		"listen",

		"manage",

		"primary_connection_string",

		"primary_key",

		"secondary_connection_string",

		"secondary_key",

		"send",
	)
	rtb.ImmutableAttributes(

		"name",

		"namespace_name",

		"resource_group_name",
	)
}

// Azurerm_servicebus_namespace_authorization_ruleHandler ...
type Azurerm_servicebus_namespace_authorization_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_servicebus_namespace_authorization_ruleHandler) Create(desired *Azurerm_servicebus_namespace_authorization_rule) (*Azurerm_servicebus_namespace_authorization_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_servicebus_namespace_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_servicebus_namespace_authorization_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_servicebus_namespace_authorization_ruleHandler) Update(externalID string, desired *Azurerm_servicebus_namespace_authorization_rule) (*Azurerm_servicebus_namespace_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_servicebus_namespace_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_servicebus_namespace_authorization_rule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_namespace_authorization_rule{Azurerm_servicebus_namespace_authorization_rule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_servicebus_namespace_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_servicebus_namespace_authorization_ruleHandler) Read(externalID string) (*Azurerm_servicebus_namespace_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_servicebus_namespace_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_servicebus_namespace_authorization_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_namespace_authorization_rule{Azurerm_servicebus_namespace_authorization_rule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_servicebus_namespace_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_servicebus_namespace_authorization_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_servicebus_namespace_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_servicebus_namespace_authorization_rule", externalID)
}

type Azurerm_servicebus_queue struct {
	Azurerm_servicebus_queue_id *string `lyra:"ignore"`

	Auto_delete_on_idle *string

	Dead_lettering_on_message_expiration *bool

	Default_message_ttl *string

	Duplicate_detection_history_time_window *string

	Enable_batched_operations *bool

	Enable_express *bool

	Enable_partitioning *bool

	Location *string

	Lock_duration *string

	Max_delivery_count *int

	Max_size_in_megabytes *int

	Name string

	Namespace_name string

	Requires_duplicate_detection *bool

	Requires_session *bool

	Resource_group_name string

	Support_ordering *bool
}

var Azurerm_servicebus_queue_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_servicebus_queue_id",

		"auto_delete_on_idle",

		"dead_lettering_on_message_expiration",

		"default_message_ttl",

		"duplicate_detection_history_time_window",

		"enable_batched_operations",

		"enable_express",

		"enable_partitioning",

		"location",

		"lock_duration",

		"max_delivery_count",

		"max_size_in_megabytes",

		"requires_duplicate_detection",

		"requires_session",

		"support_ordering",
	)
	rtb.ImmutableAttributes(

		"enable_partitioning",

		"location",

		"name",

		"namespace_name",

		"requires_duplicate_detection",

		"requires_session",

		"resource_group_name",
	)
}

// Azurerm_servicebus_queueHandler ...
type Azurerm_servicebus_queueHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_servicebus_queueHandler) Create(desired *Azurerm_servicebus_queue) (*Azurerm_servicebus_queue, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_servicebus_queue", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_servicebus_queue", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_servicebus_queueHandler) Update(externalID string, desired *Azurerm_servicebus_queue) (*Azurerm_servicebus_queue, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_servicebus_queue", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_servicebus_queue", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_queue{Azurerm_servicebus_queue_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_servicebus_queue", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_servicebus_queueHandler) Read(externalID string) (*Azurerm_servicebus_queue, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_servicebus_queue", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_servicebus_queue", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_queue{Azurerm_servicebus_queue_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_servicebus_queue", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_servicebus_queueHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_servicebus_queue", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_servicebus_queue", externalID)
}

type Azurerm_servicebus_queue_authorization_rule struct {
	Azurerm_servicebus_queue_authorization_rule_id *string `lyra:"ignore"`

	Listen *bool

	Manage *bool

	Name string

	Namespace_name string

	Primary_connection_string *string

	Primary_key *string

	Queue_name string

	Resource_group_name string

	Secondary_connection_string *string

	Secondary_key *string

	Send *bool
}

var Azurerm_servicebus_queue_authorization_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_servicebus_queue_authorization_rule_id",

		"listen",

		"manage",

		"primary_connection_string",

		"primary_key",

		"secondary_connection_string",

		"secondary_key",

		"send",
	)
	rtb.ImmutableAttributes(

		"name",

		"namespace_name",

		"queue_name",

		"resource_group_name",
	)
}

// Azurerm_servicebus_queue_authorization_ruleHandler ...
type Azurerm_servicebus_queue_authorization_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_servicebus_queue_authorization_ruleHandler) Create(desired *Azurerm_servicebus_queue_authorization_rule) (*Azurerm_servicebus_queue_authorization_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_servicebus_queue_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_servicebus_queue_authorization_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_servicebus_queue_authorization_ruleHandler) Update(externalID string, desired *Azurerm_servicebus_queue_authorization_rule) (*Azurerm_servicebus_queue_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_servicebus_queue_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_servicebus_queue_authorization_rule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_queue_authorization_rule{Azurerm_servicebus_queue_authorization_rule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_servicebus_queue_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_servicebus_queue_authorization_ruleHandler) Read(externalID string) (*Azurerm_servicebus_queue_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_servicebus_queue_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_servicebus_queue_authorization_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_queue_authorization_rule{Azurerm_servicebus_queue_authorization_rule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_servicebus_queue_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_servicebus_queue_authorization_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_servicebus_queue_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_servicebus_queue_authorization_rule", externalID)
}

type Azurerm_servicebus_subscription struct {
	Azurerm_servicebus_subscription_id *string `lyra:"ignore"`

	Auto_delete_on_idle *string

	Dead_lettering_on_filter_evaluation_exceptions *bool

	Dead_lettering_on_message_expiration *bool

	Default_message_ttl *string

	Enable_batched_operations *bool

	Forward_to *string

	Location *string

	Lock_duration *string

	Max_delivery_count int

	Name string

	Namespace_name string

	Requires_session *bool

	Resource_group_name string

	Topic_name string
}

var Azurerm_servicebus_subscription_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_servicebus_subscription_id",

		"auto_delete_on_idle",

		"dead_lettering_on_filter_evaluation_exceptions",

		"dead_lettering_on_message_expiration",

		"default_message_ttl",

		"enable_batched_operations",

		"forward_to",

		"location",

		"lock_duration",

		"requires_session",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"namespace_name",

		"requires_session",

		"resource_group_name",

		"topic_name",
	)
}

// Azurerm_servicebus_subscriptionHandler ...
type Azurerm_servicebus_subscriptionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_servicebus_subscriptionHandler) Create(desired *Azurerm_servicebus_subscription) (*Azurerm_servicebus_subscription, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_servicebus_subscription", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_servicebus_subscription", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_servicebus_subscriptionHandler) Update(externalID string, desired *Azurerm_servicebus_subscription) (*Azurerm_servicebus_subscription, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_servicebus_subscription", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_servicebus_subscription", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_subscription{Azurerm_servicebus_subscription_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_servicebus_subscription", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_servicebus_subscriptionHandler) Read(externalID string) (*Azurerm_servicebus_subscription, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_servicebus_subscription", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_servicebus_subscription", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_subscription{Azurerm_servicebus_subscription_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_servicebus_subscription", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_servicebus_subscriptionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_servicebus_subscription", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_servicebus_subscription", externalID)
}

type Azurerm_servicebus_subscription_rule_correlation_filter_206 struct {
	Content_type *string

	Correlation_id *string

	Label *string

	Message_id *string

	Reply_to *string

	Reply_to_session_id *string

	Session_id *string

	To *string
}

type Azurerm_servicebus_subscription_rule struct {
	Azurerm_servicebus_subscription_rule_id *string `lyra:"ignore"`

	Action *string

	Correlation_filter *[]Azurerm_servicebus_subscription_rule_correlation_filter_206

	Filter_type string

	Name string

	Namespace_name string

	Resource_group_name string

	Sql_filter *string

	Subscription_name string

	Topic_name string
}

var Azurerm_servicebus_subscription_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_servicebus_subscription_rule_id",

		"action",

		"correlation_filter",

		"sql_filter",
	)
	rtb.ImmutableAttributes(

		"name",

		"namespace_name",

		"resource_group_name",

		"subscription_name",

		"topic_name",
	)
}

// Azurerm_servicebus_subscription_ruleHandler ...
type Azurerm_servicebus_subscription_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_servicebus_subscription_ruleHandler) Create(desired *Azurerm_servicebus_subscription_rule) (*Azurerm_servicebus_subscription_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_servicebus_subscription_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_servicebus_subscription_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_servicebus_subscription_ruleHandler) Update(externalID string, desired *Azurerm_servicebus_subscription_rule) (*Azurerm_servicebus_subscription_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_servicebus_subscription_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_servicebus_subscription_rule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_subscription_rule{Azurerm_servicebus_subscription_rule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_servicebus_subscription_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_servicebus_subscription_ruleHandler) Read(externalID string) (*Azurerm_servicebus_subscription_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_servicebus_subscription_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_servicebus_subscription_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_subscription_rule{Azurerm_servicebus_subscription_rule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_servicebus_subscription_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_servicebus_subscription_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_servicebus_subscription_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_servicebus_subscription_rule", externalID)
}

type Azurerm_servicebus_topic struct {
	Azurerm_servicebus_topic_id *string `lyra:"ignore"`

	Auto_delete_on_idle *string

	Default_message_ttl *string

	Duplicate_detection_history_time_window *string

	Enable_batched_operations *bool

	Enable_express *bool

	Enable_filtering_messages_before_publishing *bool

	Enable_partitioning *bool

	Location *string

	Max_size_in_megabytes *int

	Name string

	Namespace_name string

	Requires_duplicate_detection *bool

	Resource_group_name string

	Status *string

	Support_ordering *bool
}

var Azurerm_servicebus_topic_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_servicebus_topic_id",

		"auto_delete_on_idle",

		"default_message_ttl",

		"duplicate_detection_history_time_window",

		"enable_batched_operations",

		"enable_express",

		"enable_filtering_messages_before_publishing",

		"enable_partitioning",

		"location",

		"max_size_in_megabytes",

		"requires_duplicate_detection",

		"status",

		"support_ordering",
	)
	rtb.ImmutableAttributes(

		"enable_partitioning",

		"location",

		"name",

		"namespace_name",

		"requires_duplicate_detection",

		"resource_group_name",
	)
}

// Azurerm_servicebus_topicHandler ...
type Azurerm_servicebus_topicHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_servicebus_topicHandler) Create(desired *Azurerm_servicebus_topic) (*Azurerm_servicebus_topic, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_servicebus_topic", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_servicebus_topic", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_servicebus_topicHandler) Update(externalID string, desired *Azurerm_servicebus_topic) (*Azurerm_servicebus_topic, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_servicebus_topic", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_servicebus_topic", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_topic{Azurerm_servicebus_topic_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_servicebus_topic", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_servicebus_topicHandler) Read(externalID string) (*Azurerm_servicebus_topic, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_servicebus_topic", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_servicebus_topic", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_topic{Azurerm_servicebus_topic_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_servicebus_topic", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_servicebus_topicHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_servicebus_topic", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_servicebus_topic", externalID)
}

type Azurerm_servicebus_topic_authorization_rule struct {
	Azurerm_servicebus_topic_authorization_rule_id *string `lyra:"ignore"`

	Listen *bool

	Manage *bool

	Name string

	Namespace_name string

	Primary_connection_string *string

	Primary_key *string

	Resource_group_name string

	Secondary_connection_string *string

	Secondary_key *string

	Send *bool

	Topic_name string
}

var Azurerm_servicebus_topic_authorization_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_servicebus_topic_authorization_rule_id",

		"listen",

		"manage",

		"primary_connection_string",

		"primary_key",

		"secondary_connection_string",

		"secondary_key",

		"send",
	)
	rtb.ImmutableAttributes(

		"name",

		"namespace_name",

		"resource_group_name",

		"topic_name",
	)
}

// Azurerm_servicebus_topic_authorization_ruleHandler ...
type Azurerm_servicebus_topic_authorization_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_servicebus_topic_authorization_ruleHandler) Create(desired *Azurerm_servicebus_topic_authorization_rule) (*Azurerm_servicebus_topic_authorization_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_servicebus_topic_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_servicebus_topic_authorization_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_servicebus_topic_authorization_ruleHandler) Update(externalID string, desired *Azurerm_servicebus_topic_authorization_rule) (*Azurerm_servicebus_topic_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_servicebus_topic_authorization_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_servicebus_topic_authorization_rule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_topic_authorization_rule{Azurerm_servicebus_topic_authorization_rule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_servicebus_topic_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_servicebus_topic_authorization_ruleHandler) Read(externalID string) (*Azurerm_servicebus_topic_authorization_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_servicebus_topic_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_servicebus_topic_authorization_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_servicebus_topic_authorization_rule{Azurerm_servicebus_topic_authorization_rule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_servicebus_topic_authorization_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_servicebus_topic_authorization_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_servicebus_topic_authorization_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_servicebus_topic_authorization_rule", externalID)
}

type Azurerm_shared_image_identifier_207 struct {
	Offer string

	Publisher string

	Sku string
}

type Azurerm_shared_image struct {
	Azurerm_shared_image_id *string `lyra:"ignore"`

	Description *string

	Eula *string

	Gallery_name string

	Identifier []Azurerm_shared_image_identifier_207

	Location string

	Name string

	Os_type string

	Privacy_statement_uri *string

	Release_note_uri *string

	Resource_group_name string

	Tags *map[string]string
}

var Azurerm_shared_image_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_shared_image_id",

		"description",

		"eula",

		"privacy_statement_uri",

		"release_note_uri",

		"tags",
	)
	rtb.ImmutableAttributes(

		"gallery_name",

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_shared_imageHandler ...
type Azurerm_shared_imageHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_shared_imageHandler) Create(desired *Azurerm_shared_image) (*Azurerm_shared_image, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_shared_image", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_shared_image", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_shared_imageHandler) Update(externalID string, desired *Azurerm_shared_image) (*Azurerm_shared_image, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_shared_image", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_shared_image", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_shared_image{Azurerm_shared_image_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_shared_image", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_shared_imageHandler) Read(externalID string) (*Azurerm_shared_image, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_shared_image", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_shared_image", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_shared_image{Azurerm_shared_image_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_shared_image", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_shared_imageHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_shared_image", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_shared_image", externalID)
}

type Azurerm_shared_image_gallery struct {
	Azurerm_shared_image_gallery_id *string `lyra:"ignore"`

	Description *string

	Location string

	Name string

	Resource_group_name string

	Tags *map[string]string

	Unique_name *string
}

var Azurerm_shared_image_gallery_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_shared_image_gallery_id",

		"description",

		"tags",

		"unique_name",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_shared_image_galleryHandler ...
type Azurerm_shared_image_galleryHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_shared_image_galleryHandler) Create(desired *Azurerm_shared_image_gallery) (*Azurerm_shared_image_gallery, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_shared_image_gallery", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_shared_image_gallery", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_shared_image_galleryHandler) Update(externalID string, desired *Azurerm_shared_image_gallery) (*Azurerm_shared_image_gallery, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_shared_image_gallery", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_shared_image_gallery", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_shared_image_gallery{Azurerm_shared_image_gallery_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_shared_image_gallery", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_shared_image_galleryHandler) Read(externalID string) (*Azurerm_shared_image_gallery, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_shared_image_gallery", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_shared_image_gallery", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_shared_image_gallery{Azurerm_shared_image_gallery_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_shared_image_gallery", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_shared_image_galleryHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_shared_image_gallery", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_shared_image_gallery", externalID)
}

type Azurerm_shared_image_version_target_region_208 struct {
	Name string

	Regional_replica_count int
}

type Azurerm_shared_image_version struct {
	Azurerm_shared_image_version_id *string `lyra:"ignore"`

	Exclude_from_latest *bool

	Gallery_name string

	Image_name string

	Location string

	Managed_image_id string

	Name string

	Resource_group_name string

	Tags *map[string]string

	Target_region []Azurerm_shared_image_version_target_region_208
}

var Azurerm_shared_image_version_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_shared_image_version_id",

		"exclude_from_latest",

		"tags",
	)
	rtb.ImmutableAttributes(

		"gallery_name",

		"image_name",

		"location",

		"managed_image_id",

		"name",

		"resource_group_name",
	)
}

// Azurerm_shared_image_versionHandler ...
type Azurerm_shared_image_versionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_shared_image_versionHandler) Create(desired *Azurerm_shared_image_version) (*Azurerm_shared_image_version, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_shared_image_version", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_shared_image_version", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_shared_image_versionHandler) Update(externalID string, desired *Azurerm_shared_image_version) (*Azurerm_shared_image_version, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_shared_image_version", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_shared_image_version", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_shared_image_version{Azurerm_shared_image_version_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_shared_image_version", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_shared_image_versionHandler) Read(externalID string) (*Azurerm_shared_image_version, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_shared_image_version", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_shared_image_version", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_shared_image_version{Azurerm_shared_image_version_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_shared_image_version", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_shared_image_versionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_shared_image_version", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_shared_image_version", externalID)
}

type Azurerm_signalr_service_sku_209 struct {
	Capacity int

	Name string
}

type Azurerm_signalr_service struct {
	Azurerm_signalr_service_id *string `lyra:"ignore"`

	Hostname *string

	Ip_address *string

	Location string

	Name string

	Public_port *int

	Resource_group_name string

	Server_port *int

	Sku []Azurerm_signalr_service_sku_209

	Tags *map[string]string
}

var Azurerm_signalr_service_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_signalr_service_id",

		"hostname",

		"ip_address",

		"public_port",

		"server_port",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_signalr_serviceHandler ...
type Azurerm_signalr_serviceHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_signalr_serviceHandler) Create(desired *Azurerm_signalr_service) (*Azurerm_signalr_service, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_signalr_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_signalr_service", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_signalr_serviceHandler) Update(externalID string, desired *Azurerm_signalr_service) (*Azurerm_signalr_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_signalr_service", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_signalr_service", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_signalr_service{Azurerm_signalr_service_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_signalr_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_signalr_serviceHandler) Read(externalID string) (*Azurerm_signalr_service, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_signalr_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_signalr_service", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_signalr_service{Azurerm_signalr_service_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_signalr_service", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_signalr_serviceHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_signalr_service", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_signalr_service", externalID)
}

type Azurerm_snapshot_encryption_settings_210_disk_encryption_key_211 struct {
	Secret_url string

	Source_vault_id string
}

type Azurerm_snapshot_encryption_settings_210_key_encryption_key_212 struct {
	Key_url string

	Source_vault_id string
}

type Azurerm_snapshot_encryption_settings_210 struct {
	Disk_encryption_key *[]Azurerm_snapshot_encryption_settings_210_disk_encryption_key_211

	Enabled bool

	Key_encryption_key *[]Azurerm_snapshot_encryption_settings_210_key_encryption_key_212
}

type Azurerm_snapshot struct {
	Azurerm_snapshot_id *string `lyra:"ignore"`

	Create_option string

	Disk_size_gb *int

	Encryption_settings *[]Azurerm_snapshot_encryption_settings_210

	Location string

	Name string

	Resource_group_name string

	Source_resource_id *string

	Source_uri *string

	Storage_account_id *string

	Tags *map[string]string
}

var Azurerm_snapshot_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_snapshot_id",

		"disk_size_gb",

		"encryption_settings",

		"source_resource_id",

		"source_uri",

		"storage_account_id",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"source_resource_id",

		"source_uri",

		"storage_account_id",
	)
}

// Azurerm_snapshotHandler ...
type Azurerm_snapshotHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_snapshotHandler) Create(desired *Azurerm_snapshot) (*Azurerm_snapshot, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_snapshot", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_snapshot", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_snapshotHandler) Update(externalID string, desired *Azurerm_snapshot) (*Azurerm_snapshot, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_snapshot", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_snapshot", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_snapshot{Azurerm_snapshot_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_snapshot", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_snapshotHandler) Read(externalID string) (*Azurerm_snapshot, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_snapshot", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_snapshot", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_snapshot{Azurerm_snapshot_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_snapshot", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_snapshotHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_snapshot", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_snapshot", externalID)
}

type Azurerm_sql_active_directory_administrator struct {
	Azurerm_sql_active_directory_administrator_id *string `lyra:"ignore"`

	Login string

	Object_id string

	Resource_group_name string

	Server_name string

	Tenant_id string
}

var Azurerm_sql_active_directory_administrator_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_sql_active_directory_administrator_id",
	)
	rtb.ImmutableAttributes(

		"resource_group_name",

		"server_name",
	)
}

// Azurerm_sql_active_directory_administratorHandler ...
type Azurerm_sql_active_directory_administratorHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_sql_active_directory_administratorHandler) Create(desired *Azurerm_sql_active_directory_administrator) (*Azurerm_sql_active_directory_administrator, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_sql_active_directory_administrator", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_sql_active_directory_administrator", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_sql_active_directory_administratorHandler) Update(externalID string, desired *Azurerm_sql_active_directory_administrator) (*Azurerm_sql_active_directory_administrator, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_sql_active_directory_administrator", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_sql_active_directory_administrator", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_active_directory_administrator{Azurerm_sql_active_directory_administrator_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_sql_active_directory_administrator", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_sql_active_directory_administratorHandler) Read(externalID string) (*Azurerm_sql_active_directory_administrator, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_sql_active_directory_administrator", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_sql_active_directory_administrator", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_active_directory_administrator{Azurerm_sql_active_directory_administrator_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_sql_active_directory_administrator", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_sql_active_directory_administratorHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_sql_active_directory_administrator", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_sql_active_directory_administrator", externalID)
}

type Azurerm_sql_database_import_213 struct {
	Administrator_login string

	Administrator_login_password string

	Authentication_type string

	Operation_mode *string

	Storage_key string

	Storage_key_type string

	Storage_uri string
}

type Azurerm_sql_database_threat_detection_policy_214 struct {
	Disabled_alerts *[]string

	Email_account_admins *string

	Email_addresses *[]string

	Retention_days *int

	State *string

	Storage_account_access_key *string

	Storage_endpoint *string

	Use_server_default *string
}

type Azurerm_sql_database struct {
	Azurerm_sql_database_id *string `lyra:"ignore"`

	Collation *string

	Create_mode *string

	Creation_date *string

	Default_secondary_location *string

	Edition *string

	Elastic_pool_name *string

	Encryption *string

	Import *[]Azurerm_sql_database_import_213

	Location string

	Max_size_bytes *string

	Name string

	Requested_service_objective_id *string

	Requested_service_objective_name *string

	Resource_group_name string

	Restore_point_in_time *string

	Server_name string

	Source_database_deletion_date *string

	Source_database_id *string

	Tags *map[string]string

	Threat_detection_policy *[]Azurerm_sql_database_threat_detection_policy_214
}

var Azurerm_sql_database_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_sql_database_id",

		"collation",

		"create_mode",

		"creation_date",

		"default_secondary_location",

		"edition",

		"elastic_pool_name",

		"encryption",

		"import",

		"max_size_bytes",

		"requested_service_objective_id",

		"requested_service_objective_name",

		"restore_point_in_time",

		"source_database_deletion_date",

		"source_database_id",

		"tags",

		"threat_detection_policy",
	)
	rtb.ImmutableAttributes(

		"collation",

		"location",

		"name",

		"resource_group_name",

		"server_name",
	)
}

// Azurerm_sql_databaseHandler ...
type Azurerm_sql_databaseHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_sql_databaseHandler) Create(desired *Azurerm_sql_database) (*Azurerm_sql_database, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_sql_database", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_sql_database", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_sql_databaseHandler) Update(externalID string, desired *Azurerm_sql_database) (*Azurerm_sql_database, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_sql_database", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_sql_database", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_database{Azurerm_sql_database_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_sql_database", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_sql_databaseHandler) Read(externalID string) (*Azurerm_sql_database, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_sql_database", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_sql_database", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_database{Azurerm_sql_database_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_sql_database", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_sql_databaseHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_sql_database", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_sql_database", externalID)
}

type Azurerm_sql_elasticpool struct {
	Azurerm_sql_elasticpool_id *string `lyra:"ignore"`

	Creation_date *string

	Db_dtu_max *int

	Db_dtu_min *int

	Dtu int

	Edition string

	Location string

	Name string

	Pool_size *int

	Resource_group_name string

	Server_name string

	Tags *map[string]string
}

var Azurerm_sql_elasticpool_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_sql_elasticpool_id",

		"creation_date",

		"db_dtu_max",

		"db_dtu_min",

		"pool_size",

		"tags",
	)
	rtb.ImmutableAttributes(

		"edition",

		"location",

		"name",

		"resource_group_name",

		"server_name",
	)
}

// Azurerm_sql_elasticpoolHandler ...
type Azurerm_sql_elasticpoolHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_sql_elasticpoolHandler) Create(desired *Azurerm_sql_elasticpool) (*Azurerm_sql_elasticpool, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_sql_elasticpool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_sql_elasticpool", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_sql_elasticpoolHandler) Update(externalID string, desired *Azurerm_sql_elasticpool) (*Azurerm_sql_elasticpool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_sql_elasticpool", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_sql_elasticpool", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_elasticpool{Azurerm_sql_elasticpool_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_sql_elasticpool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_sql_elasticpoolHandler) Read(externalID string) (*Azurerm_sql_elasticpool, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_sql_elasticpool", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_sql_elasticpool", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_elasticpool{Azurerm_sql_elasticpool_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_sql_elasticpool", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_sql_elasticpoolHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_sql_elasticpool", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_sql_elasticpool", externalID)
}

type Azurerm_sql_firewall_rule struct {
	Azurerm_sql_firewall_rule_id *string `lyra:"ignore"`

	End_ip_address string

	Name string

	Resource_group_name string

	Server_name string

	Start_ip_address string
}

var Azurerm_sql_firewall_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_sql_firewall_rule_id",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"server_name",
	)
}

// Azurerm_sql_firewall_ruleHandler ...
type Azurerm_sql_firewall_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_sql_firewall_ruleHandler) Create(desired *Azurerm_sql_firewall_rule) (*Azurerm_sql_firewall_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_sql_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_sql_firewall_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_sql_firewall_ruleHandler) Update(externalID string, desired *Azurerm_sql_firewall_rule) (*Azurerm_sql_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_sql_firewall_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_sql_firewall_rule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_firewall_rule{Azurerm_sql_firewall_rule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_sql_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_sql_firewall_ruleHandler) Read(externalID string) (*Azurerm_sql_firewall_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_sql_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_sql_firewall_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_firewall_rule{Azurerm_sql_firewall_rule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_sql_firewall_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_sql_firewall_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_sql_firewall_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_sql_firewall_rule", externalID)
}

type Azurerm_sql_server struct {
	Azurerm_sql_server_id *string `lyra:"ignore"`

	Administrator_login string

	Administrator_login_password string

	Fully_qualified_domain_name *string

	Location string

	Name string

	Resource_group_name string

	Tags *map[string]string

	Version string
}

var Azurerm_sql_server_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_sql_server_id",

		"fully_qualified_domain_name",

		"tags",
	)
	rtb.ImmutableAttributes(

		"administrator_login",

		"location",

		"name",

		"resource_group_name",

		"version",
	)
}

// Azurerm_sql_serverHandler ...
type Azurerm_sql_serverHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_sql_serverHandler) Create(desired *Azurerm_sql_server) (*Azurerm_sql_server, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_sql_server", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_sql_server", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_sql_serverHandler) Update(externalID string, desired *Azurerm_sql_server) (*Azurerm_sql_server, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_sql_server", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_sql_server", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_server{Azurerm_sql_server_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_sql_server", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_sql_serverHandler) Read(externalID string) (*Azurerm_sql_server, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_sql_server", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_sql_server", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_server{Azurerm_sql_server_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_sql_server", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_sql_serverHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_sql_server", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_sql_server", externalID)
}

type Azurerm_sql_virtual_network_rule struct {
	Azurerm_sql_virtual_network_rule_id *string `lyra:"ignore"`

	Ignore_missing_vnet_service_endpoint *bool

	Name string

	Resource_group_name string

	Server_name string

	Subnet_id string
}

var Azurerm_sql_virtual_network_rule_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_sql_virtual_network_rule_id",

		"ignore_missing_vnet_service_endpoint",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"server_name",
	)
}

// Azurerm_sql_virtual_network_ruleHandler ...
type Azurerm_sql_virtual_network_ruleHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_sql_virtual_network_ruleHandler) Create(desired *Azurerm_sql_virtual_network_rule) (*Azurerm_sql_virtual_network_rule, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_sql_virtual_network_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_sql_virtual_network_rule", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_sql_virtual_network_ruleHandler) Update(externalID string, desired *Azurerm_sql_virtual_network_rule) (*Azurerm_sql_virtual_network_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_sql_virtual_network_rule", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_sql_virtual_network_rule", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_virtual_network_rule{Azurerm_sql_virtual_network_rule_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_sql_virtual_network_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_sql_virtual_network_ruleHandler) Read(externalID string) (*Azurerm_sql_virtual_network_rule, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_sql_virtual_network_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_sql_virtual_network_rule", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_sql_virtual_network_rule{Azurerm_sql_virtual_network_rule_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_sql_virtual_network_rule", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_sql_virtual_network_ruleHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_sql_virtual_network_rule", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_sql_virtual_network_rule", externalID)
}

type Azurerm_storage_account_custom_domain_215 struct {
	Name string

	Use_subdomain *bool
}

type Azurerm_storage_account_identity_216 struct {
	Principal_id *string

	Tenant_id *string

	Type string
}

type Azurerm_storage_account_network_rules_217 struct {
	Bypass *[]string

	Ip_rules *[]string

	Virtual_network_subnet_ids *[]string
}

type Azurerm_storage_account struct {
	Azurerm_storage_account_id *string `lyra:"ignore"`

	Access_tier *string

	Account_encryption_source *string

	Account_kind *string

	Account_replication_type string

	Account_tier string

	Account_type *string

	Custom_domain *[]Azurerm_storage_account_custom_domain_215

	Enable_blob_encryption *bool

	Enable_file_encryption *bool

	Enable_https_traffic_only *bool

	Identity *[]Azurerm_storage_account_identity_216

	Location string

	Name string

	Network_rules *[]Azurerm_storage_account_network_rules_217

	Primary_access_key *string

	Primary_blob_connection_string *string

	Primary_blob_endpoint *string

	Primary_connection_string *string

	Primary_file_endpoint *string

	Primary_location *string

	Primary_queue_endpoint *string

	Primary_table_endpoint *string

	Resource_group_name string

	Secondary_access_key *string

	Secondary_blob_connection_string *string

	Secondary_blob_endpoint *string

	Secondary_connection_string *string

	Secondary_location *string

	Secondary_queue_endpoint *string

	Secondary_table_endpoint *string

	Tags *map[string]string
}

var Azurerm_storage_account_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_storage_account_id",

		"access_tier",

		"account_encryption_source",

		"account_kind",

		"account_type",

		"custom_domain",

		"enable_blob_encryption",

		"enable_file_encryption",

		"enable_https_traffic_only",

		"identity",

		"network_rules",

		"primary_access_key",

		"primary_blob_connection_string",

		"primary_blob_endpoint",

		"primary_connection_string",

		"primary_file_endpoint",

		"primary_location",

		"primary_queue_endpoint",

		"primary_table_endpoint",

		"secondary_access_key",

		"secondary_blob_connection_string",

		"secondary_blob_endpoint",

		"secondary_connection_string",

		"secondary_location",

		"secondary_queue_endpoint",

		"secondary_table_endpoint",

		"tags",
	)
	rtb.ImmutableAttributes(

		"account_kind",

		"account_tier",

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_storage_accountHandler ...
type Azurerm_storage_accountHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_storage_accountHandler) Create(desired *Azurerm_storage_account) (*Azurerm_storage_account, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_storage_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_storage_account", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_storage_accountHandler) Update(externalID string, desired *Azurerm_storage_account) (*Azurerm_storage_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_storage_account", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_storage_account", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_account{Azurerm_storage_account_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_storage_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_storage_accountHandler) Read(externalID string) (*Azurerm_storage_account, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_storage_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_storage_account", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_account{Azurerm_storage_account_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_storage_account", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_storage_accountHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_storage_account", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_storage_account", externalID)
}

type Azurerm_storage_blob struct {
	Azurerm_storage_blob_id *string `lyra:"ignore"`

	Attempts *int

	Content_type *string

	Name string

	Parallelism *int

	Resource_group_name string

	Size *int

	Source *string

	Source_uri *string

	Storage_account_name string

	Storage_container_name string

	Type *string

	Url *string
}

var Azurerm_storage_blob_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_storage_blob_id",

		"attempts",

		"content_type",

		"parallelism",

		"size",

		"source",

		"source_uri",

		"type",

		"url",
	)
	rtb.ImmutableAttributes(

		"attempts",

		"name",

		"parallelism",

		"resource_group_name",

		"size",

		"source",

		"source_uri",

		"storage_account_name",

		"storage_container_name",

		"type",
	)
}

// Azurerm_storage_blobHandler ...
type Azurerm_storage_blobHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_storage_blobHandler) Create(desired *Azurerm_storage_blob) (*Azurerm_storage_blob, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_storage_blob", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_storage_blob", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_storage_blobHandler) Update(externalID string, desired *Azurerm_storage_blob) (*Azurerm_storage_blob, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_storage_blob", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_storage_blob", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_blob{Azurerm_storage_blob_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_storage_blob", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_storage_blobHandler) Read(externalID string) (*Azurerm_storage_blob, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_storage_blob", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_storage_blob", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_blob{Azurerm_storage_blob_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_storage_blob", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_storage_blobHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_storage_blob", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_storage_blob", externalID)
}

type Azurerm_storage_container struct {
	Azurerm_storage_container_id *string `lyra:"ignore"`

	Container_access_type *string

	Name string

	Properties *map[string]string

	Resource_group_name string

	Storage_account_name string
}

var Azurerm_storage_container_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_storage_container_id",

		"container_access_type",

		"properties",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"storage_account_name",
	)
}

// Azurerm_storage_containerHandler ...
type Azurerm_storage_containerHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_storage_containerHandler) Create(desired *Azurerm_storage_container) (*Azurerm_storage_container, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_storage_container", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_storage_container", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_storage_containerHandler) Update(externalID string, desired *Azurerm_storage_container) (*Azurerm_storage_container, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_storage_container", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_storage_container", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_container{Azurerm_storage_container_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_storage_container", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_storage_containerHandler) Read(externalID string) (*Azurerm_storage_container, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_storage_container", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_storage_container", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_container{Azurerm_storage_container_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_storage_container", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_storage_containerHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_storage_container", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_storage_container", externalID)
}

type Azurerm_storage_queue struct {
	Azurerm_storage_queue_id *string `lyra:"ignore"`

	Name string

	Resource_group_name string

	Storage_account_name string
}

var Azurerm_storage_queue_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_storage_queue_id",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"storage_account_name",
	)
}

// Azurerm_storage_queueHandler ...
type Azurerm_storage_queueHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_storage_queueHandler) Create(desired *Azurerm_storage_queue) (*Azurerm_storage_queue, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_storage_queue", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_storage_queue", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_storage_queueHandler) Update(externalID string, desired *Azurerm_storage_queue) (*Azurerm_storage_queue, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_storage_queue", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_storage_queue", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_queue{Azurerm_storage_queue_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_storage_queue", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_storage_queueHandler) Read(externalID string) (*Azurerm_storage_queue, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_storage_queue", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_storage_queue", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_queue{Azurerm_storage_queue_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_storage_queue", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_storage_queueHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_storage_queue", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_storage_queue", externalID)
}

type Azurerm_storage_share struct {
	Azurerm_storage_share_id *string `lyra:"ignore"`

	Name string

	Quota *int

	Resource_group_name string

	Storage_account_name string

	Url *string
}

var Azurerm_storage_share_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_storage_share_id",

		"quota",

		"url",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"storage_account_name",
	)
}

// Azurerm_storage_shareHandler ...
type Azurerm_storage_shareHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_storage_shareHandler) Create(desired *Azurerm_storage_share) (*Azurerm_storage_share, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_storage_share", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_storage_share", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_storage_shareHandler) Update(externalID string, desired *Azurerm_storage_share) (*Azurerm_storage_share, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_storage_share", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_storage_share", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_share{Azurerm_storage_share_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_storage_share", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_storage_shareHandler) Read(externalID string) (*Azurerm_storage_share, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_storage_share", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_storage_share", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_share{Azurerm_storage_share_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_storage_share", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_storage_shareHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_storage_share", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_storage_share", externalID)
}

type Azurerm_storage_table struct {
	Azurerm_storage_table_id *string `lyra:"ignore"`

	Name string

	Resource_group_name string

	Storage_account_name string
}

var Azurerm_storage_table_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_storage_table_id",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"storage_account_name",
	)
}

// Azurerm_storage_tableHandler ...
type Azurerm_storage_tableHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_storage_tableHandler) Create(desired *Azurerm_storage_table) (*Azurerm_storage_table, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_storage_table", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_storage_table", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_storage_tableHandler) Update(externalID string, desired *Azurerm_storage_table) (*Azurerm_storage_table, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_storage_table", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_storage_table", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_table{Azurerm_storage_table_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_storage_table", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_storage_tableHandler) Read(externalID string) (*Azurerm_storage_table, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_storage_table", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_storage_table", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_storage_table{Azurerm_storage_table_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_storage_table", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_storage_tableHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_storage_table", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_storage_table", externalID)
}

type Azurerm_subnet_delegation_218_service_delegation_219 struct {
	Actions *[]string

	Name string
}

type Azurerm_subnet_delegation_218 struct {
	Name string

	Service_delegation []Azurerm_subnet_delegation_218_service_delegation_219
}

type Azurerm_subnet struct {
	Azurerm_subnet_id *string `lyra:"ignore"`

	Address_prefix string

	Delegation *[]Azurerm_subnet_delegation_218

	Ip_configurations *[]string

	Name string

	Network_security_group_id *string

	Resource_group_name string

	Route_table_id *string

	Service_endpoints *[]string

	Virtual_network_name string
}

var Azurerm_subnet_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_subnet_id",

		"delegation",

		"ip_configurations",

		"network_security_group_id",

		"route_table_id",

		"service_endpoints",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",

		"virtual_network_name",
	)
}

// Azurerm_subnetHandler ...
type Azurerm_subnetHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_subnetHandler) Create(desired *Azurerm_subnet) (*Azurerm_subnet, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_subnet", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_subnet", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_subnetHandler) Update(externalID string, desired *Azurerm_subnet) (*Azurerm_subnet, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_subnet", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_subnet", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_subnet{Azurerm_subnet_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_subnet", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_subnetHandler) Read(externalID string) (*Azurerm_subnet, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_subnet", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_subnet", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_subnet{Azurerm_subnet_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_subnet", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_subnetHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_subnet", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_subnet", externalID)
}

type Azurerm_subnet_network_security_group_association struct {
	Azurerm_subnet_network_security_group_association_id *string `lyra:"ignore"`

	Network_security_group_id string

	Subnet_id string
}

var Azurerm_subnet_network_security_group_association_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_subnet_network_security_group_association_id",
	)
	rtb.ImmutableAttributes(

		"network_security_group_id",

		"subnet_id",
	)
}

// Azurerm_subnet_network_security_group_associationHandler ...
type Azurerm_subnet_network_security_group_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_subnet_network_security_group_associationHandler) Create(desired *Azurerm_subnet_network_security_group_association) (*Azurerm_subnet_network_security_group_association, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_subnet_network_security_group_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_subnet_network_security_group_association", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_subnet_network_security_group_associationHandler) Update(externalID string, desired *Azurerm_subnet_network_security_group_association) (*Azurerm_subnet_network_security_group_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_subnet_network_security_group_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_subnet_network_security_group_association", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_subnet_network_security_group_association{Azurerm_subnet_network_security_group_association_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_subnet_network_security_group_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_subnet_network_security_group_associationHandler) Read(externalID string) (*Azurerm_subnet_network_security_group_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_subnet_network_security_group_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_subnet_network_security_group_association", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_subnet_network_security_group_association{Azurerm_subnet_network_security_group_association_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_subnet_network_security_group_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_subnet_network_security_group_associationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_subnet_network_security_group_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_subnet_network_security_group_association", externalID)
}

type Azurerm_subnet_route_table_association struct {
	Azurerm_subnet_route_table_association_id *string `lyra:"ignore"`

	Route_table_id string

	Subnet_id string
}

var Azurerm_subnet_route_table_association_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_subnet_route_table_association_id",
	)
	rtb.ImmutableAttributes(

		"route_table_id",

		"subnet_id",
	)
}

// Azurerm_subnet_route_table_associationHandler ...
type Azurerm_subnet_route_table_associationHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_subnet_route_table_associationHandler) Create(desired *Azurerm_subnet_route_table_association) (*Azurerm_subnet_route_table_association, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_subnet_route_table_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_subnet_route_table_association", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_subnet_route_table_associationHandler) Update(externalID string, desired *Azurerm_subnet_route_table_association) (*Azurerm_subnet_route_table_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_subnet_route_table_association", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_subnet_route_table_association", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_subnet_route_table_association{Azurerm_subnet_route_table_association_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_subnet_route_table_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_subnet_route_table_associationHandler) Read(externalID string) (*Azurerm_subnet_route_table_association, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_subnet_route_table_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_subnet_route_table_association", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_subnet_route_table_association{Azurerm_subnet_route_table_association_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_subnet_route_table_association", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_subnet_route_table_associationHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_subnet_route_table_association", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_subnet_route_table_association", externalID)
}

type Azurerm_template_deployment struct {
	Azurerm_template_deployment_id *string `lyra:"ignore"`

	Deployment_mode string

	Name string

	Outputs *map[string]string

	Parameters *map[string]string

	Parameters_body *string

	Resource_group_name string

	Template_body *string
}

var Azurerm_template_deployment_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_template_deployment_id",

		"outputs",

		"parameters",

		"parameters_body",

		"template_body",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",
	)
}

// Azurerm_template_deploymentHandler ...
type Azurerm_template_deploymentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_template_deploymentHandler) Create(desired *Azurerm_template_deployment) (*Azurerm_template_deployment, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_template_deployment", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_template_deployment", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_template_deploymentHandler) Update(externalID string, desired *Azurerm_template_deployment) (*Azurerm_template_deployment, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_template_deployment", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_template_deployment", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_template_deployment{Azurerm_template_deployment_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_template_deployment", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_template_deploymentHandler) Read(externalID string) (*Azurerm_template_deployment, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_template_deployment", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_template_deployment", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_template_deployment{Azurerm_template_deployment_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_template_deployment", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_template_deploymentHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_template_deployment", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_template_deployment", externalID)
}

type Azurerm_traffic_manager_endpoint struct {
	Azurerm_traffic_manager_endpoint_id *string `lyra:"ignore"`

	Endpoint_location *string

	Endpoint_monitor_status *string

	Endpoint_status *string

	Geo_mappings *[]string

	Min_child_endpoints *int

	Name string

	Priority *int

	Profile_name string

	Resource_group_name string

	Target *string

	Target_resource_id *string

	Type string

	Weight *int
}

var Azurerm_traffic_manager_endpoint_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_traffic_manager_endpoint_id",

		"endpoint_location",

		"endpoint_monitor_status",

		"endpoint_status",

		"geo_mappings",

		"min_child_endpoints",

		"priority",

		"target",

		"target_resource_id",

		"weight",
	)
	rtb.ImmutableAttributes(

		"name",

		"profile_name",

		"resource_group_name",

		"type",
	)
}

// Azurerm_traffic_manager_endpointHandler ...
type Azurerm_traffic_manager_endpointHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_traffic_manager_endpointHandler) Create(desired *Azurerm_traffic_manager_endpoint) (*Azurerm_traffic_manager_endpoint, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_traffic_manager_endpoint", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_traffic_manager_endpoint", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_traffic_manager_endpointHandler) Update(externalID string, desired *Azurerm_traffic_manager_endpoint) (*Azurerm_traffic_manager_endpoint, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_traffic_manager_endpoint", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_traffic_manager_endpoint", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_traffic_manager_endpoint{Azurerm_traffic_manager_endpoint_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_traffic_manager_endpoint", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_traffic_manager_endpointHandler) Read(externalID string) (*Azurerm_traffic_manager_endpoint, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_traffic_manager_endpoint", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_traffic_manager_endpoint", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_traffic_manager_endpoint{Azurerm_traffic_manager_endpoint_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_traffic_manager_endpoint", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_traffic_manager_endpointHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_traffic_manager_endpoint", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_traffic_manager_endpoint", externalID)
}

type Azurerm_traffic_manager_profile_dns_config_220 struct {
	Relative_name string

	Ttl int
}

type Azurerm_traffic_manager_profile_monitor_config_221 struct {
	Path *string

	Port int

	Protocol string
}

type Azurerm_traffic_manager_profile struct {
	Azurerm_traffic_manager_profile_id *string `lyra:"ignore"`

	Dns_config []Azurerm_traffic_manager_profile_dns_config_220

	Fqdn *string

	Monitor_config []Azurerm_traffic_manager_profile_monitor_config_221

	Name string

	Profile_status *string

	Resource_group_name string

	Tags *map[string]string

	Traffic_routing_method string
}

var Azurerm_traffic_manager_profile_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_traffic_manager_profile_id",

		"fqdn",

		"profile_status",

		"tags",
	)
	rtb.ImmutableAttributes(

		"name",

		"resource_group_name",
	)
}

// Azurerm_traffic_manager_profileHandler ...
type Azurerm_traffic_manager_profileHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_traffic_manager_profileHandler) Create(desired *Azurerm_traffic_manager_profile) (*Azurerm_traffic_manager_profile, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_traffic_manager_profile", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_traffic_manager_profile", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_traffic_manager_profileHandler) Update(externalID string, desired *Azurerm_traffic_manager_profile) (*Azurerm_traffic_manager_profile, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_traffic_manager_profile", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_traffic_manager_profile", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_traffic_manager_profile{Azurerm_traffic_manager_profile_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_traffic_manager_profile", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_traffic_manager_profileHandler) Read(externalID string) (*Azurerm_traffic_manager_profile, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_traffic_manager_profile", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_traffic_manager_profile", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_traffic_manager_profile{Azurerm_traffic_manager_profile_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_traffic_manager_profile", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_traffic_manager_profileHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_traffic_manager_profile", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_traffic_manager_profile", externalID)
}

type Azurerm_user_assigned_identity struct {
	Azurerm_user_assigned_identity_id *string `lyra:"ignore"`

	Client_id *string

	Location string

	Name string

	Principal_id *string

	Resource_group_name string

	Tags *map[string]string
}

var Azurerm_user_assigned_identity_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_user_assigned_identity_id",

		"client_id",

		"principal_id",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_user_assigned_identityHandler ...
type Azurerm_user_assigned_identityHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_user_assigned_identityHandler) Create(desired *Azurerm_user_assigned_identity) (*Azurerm_user_assigned_identity, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_user_assigned_identity", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_user_assigned_identity", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_user_assigned_identityHandler) Update(externalID string, desired *Azurerm_user_assigned_identity) (*Azurerm_user_assigned_identity, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_user_assigned_identity", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_user_assigned_identity", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_user_assigned_identity{Azurerm_user_assigned_identity_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_user_assigned_identity", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_user_assigned_identityHandler) Read(externalID string) (*Azurerm_user_assigned_identity, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_user_assigned_identity", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_user_assigned_identity", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_user_assigned_identity{Azurerm_user_assigned_identity_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_user_assigned_identity", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_user_assigned_identityHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_user_assigned_identity", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_user_assigned_identity", externalID)
}

type Azurerm_virtual_machine_boot_diagnostics_222 struct {
	Enabled bool

	Storage_uri string
}

type Azurerm_virtual_machine_identity_223 struct {
	Identity_ids *[]string

	Principal_id *string

	Type string
}

type Azurerm_virtual_machine_os_profile_224 struct {
	Admin_password *string

	Admin_username string

	Computer_name string

	Custom_data *string
}

type Azurerm_virtual_machine_os_profile_linux_config_225_ssh_keys_226 struct {
	Key_data string

	Path string
}

type Azurerm_virtual_machine_os_profile_linux_config_225 struct {
	Disable_password_authentication bool

	Ssh_keys *[]Azurerm_virtual_machine_os_profile_linux_config_225_ssh_keys_226
}

type Azurerm_virtual_machine_os_profile_secrets_227_vault_certificates_228 struct {
	Certificate_store *string

	Certificate_url string
}

type Azurerm_virtual_machine_os_profile_secrets_227 struct {
	Source_vault_id string

	Vault_certificates *[]Azurerm_virtual_machine_os_profile_secrets_227_vault_certificates_228
}

type Azurerm_virtual_machine_os_profile_windows_config_229_additional_unattend_config_230 struct {
	Component string

	Content string

	Pass string

	Setting_name string
}

type Azurerm_virtual_machine_os_profile_windows_config_229_winrm_231 struct {
	Certificate_url *string

	Protocol string
}

type Azurerm_virtual_machine_os_profile_windows_config_229 struct {
	Additional_unattend_config *[]Azurerm_virtual_machine_os_profile_windows_config_229_additional_unattend_config_230

	Enable_automatic_upgrades *bool

	Provision_vm_agent *bool

	Timezone *string

	Winrm *[]Azurerm_virtual_machine_os_profile_windows_config_229_winrm_231
}

type Azurerm_virtual_machine_plan_232 struct {
	Name string

	Product string

	Publisher string
}

type Azurerm_virtual_machine_storage_data_disk_233 struct {
	Caching *string

	Create_option string

	Disk_size_gb *int

	Lun int

	Managed_disk_id *string

	Managed_disk_type *string

	Name string

	Vhd_uri *string

	Write_accelerator_enabled *bool
}

type Azurerm_virtual_machine_storage_image_reference_234 struct {
	Id *string

	Offer *string

	Publisher *string

	Sku *string

	Version *string
}

type Azurerm_virtual_machine_storage_os_disk_235 struct {
	Caching *string

	Create_option string

	Disk_size_gb *int

	Image_uri *string

	Managed_disk_id *string

	Managed_disk_type *string

	Name string

	Os_type *string

	Vhd_uri *string

	Write_accelerator_enabled *bool
}

type Azurerm_virtual_machine struct {
	Azurerm_virtual_machine_id *string `lyra:"ignore"`

	Availability_set_id *string

	Boot_diagnostics *[]Azurerm_virtual_machine_boot_diagnostics_222

	Delete_data_disks_on_termination *bool

	Delete_os_disk_on_termination *bool

	Identity *[]Azurerm_virtual_machine_identity_223

	License_type *string

	Location string

	Name string

	Network_interface_ids []string

	Os_profile *[]Azurerm_virtual_machine_os_profile_224

	Os_profile_linux_config *[]Azurerm_virtual_machine_os_profile_linux_config_225

	Os_profile_secrets *[]Azurerm_virtual_machine_os_profile_secrets_227

	Os_profile_windows_config *[]Azurerm_virtual_machine_os_profile_windows_config_229

	Plan *[]Azurerm_virtual_machine_plan_232

	Primary_network_interface_id *string

	Resource_group_name string

	Storage_data_disk *[]Azurerm_virtual_machine_storage_data_disk_233

	Storage_image_reference *[]Azurerm_virtual_machine_storage_image_reference_234

	Storage_os_disk []Azurerm_virtual_machine_storage_os_disk_235

	Tags *map[string]string

	Vm_size string

	Zones *[]string
}

var Azurerm_virtual_machine_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_virtual_machine_id",

		"availability_set_id",

		"boot_diagnostics",

		"delete_data_disks_on_termination",

		"delete_os_disk_on_termination",

		"identity",

		"license_type",

		"os_profile",

		"os_profile_linux_config",

		"os_profile_secrets",

		"os_profile_windows_config",

		"plan",

		"primary_network_interface_id",

		"storage_data_disk",

		"storage_image_reference",

		"tags",

		"zones",
	)
	rtb.ImmutableAttributes(

		"availability_set_id",

		"location",

		"name",

		"resource_group_name",

		"storage_image_reference",

		"zones",
	)
}

// Azurerm_virtual_machineHandler ...
type Azurerm_virtual_machineHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_virtual_machineHandler) Create(desired *Azurerm_virtual_machine) (*Azurerm_virtual_machine, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_virtual_machine", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_virtual_machine", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_virtual_machineHandler) Update(externalID string, desired *Azurerm_virtual_machine) (*Azurerm_virtual_machine, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_virtual_machine", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_virtual_machine", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_machine{Azurerm_virtual_machine_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_virtual_machine", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_virtual_machineHandler) Read(externalID string) (*Azurerm_virtual_machine, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_virtual_machine", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_virtual_machine", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_machine{Azurerm_virtual_machine_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_virtual_machine", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_virtual_machineHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_virtual_machine", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_virtual_machine", externalID)
}

type Azurerm_virtual_machine_data_disk_attachment struct {
	Azurerm_virtual_machine_data_disk_attachment_id *string `lyra:"ignore"`

	Caching string

	Create_option *string

	Lun int

	Managed_disk_id string

	Virtual_machine_id string

	Write_accelerator_enabled *bool
}

var Azurerm_virtual_machine_data_disk_attachment_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_virtual_machine_data_disk_attachment_id",

		"create_option",

		"write_accelerator_enabled",
	)
	rtb.ImmutableAttributes(

		"create_option",

		"lun",

		"managed_disk_id",

		"virtual_machine_id",
	)
}

// Azurerm_virtual_machine_data_disk_attachmentHandler ...
type Azurerm_virtual_machine_data_disk_attachmentHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_virtual_machine_data_disk_attachmentHandler) Create(desired *Azurerm_virtual_machine_data_disk_attachment) (*Azurerm_virtual_machine_data_disk_attachment, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_virtual_machine_data_disk_attachment", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_virtual_machine_data_disk_attachment", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_virtual_machine_data_disk_attachmentHandler) Update(externalID string, desired *Azurerm_virtual_machine_data_disk_attachment) (*Azurerm_virtual_machine_data_disk_attachment, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_virtual_machine_data_disk_attachment", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_virtual_machine_data_disk_attachment", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_machine_data_disk_attachment{Azurerm_virtual_machine_data_disk_attachment_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_virtual_machine_data_disk_attachment", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_virtual_machine_data_disk_attachmentHandler) Read(externalID string) (*Azurerm_virtual_machine_data_disk_attachment, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_virtual_machine_data_disk_attachment", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_virtual_machine_data_disk_attachment", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_machine_data_disk_attachment{Azurerm_virtual_machine_data_disk_attachment_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_virtual_machine_data_disk_attachment", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_virtual_machine_data_disk_attachmentHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_virtual_machine_data_disk_attachment", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_virtual_machine_data_disk_attachment", externalID)
}

type Azurerm_virtual_machine_extension struct {
	Azurerm_virtual_machine_extension_id *string `lyra:"ignore"`

	Auto_upgrade_minor_version *bool

	Location string

	Name string

	Protected_settings *string

	Publisher string

	Resource_group_name string

	Settings *string

	Tags *map[string]string

	Type string

	Type_handler_version string

	Virtual_machine_name string
}

var Azurerm_virtual_machine_extension_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_virtual_machine_extension_id",

		"auto_upgrade_minor_version",

		"protected_settings",

		"settings",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"virtual_machine_name",
	)
}

// Azurerm_virtual_machine_extensionHandler ...
type Azurerm_virtual_machine_extensionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_virtual_machine_extensionHandler) Create(desired *Azurerm_virtual_machine_extension) (*Azurerm_virtual_machine_extension, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_virtual_machine_extension", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_virtual_machine_extension", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_virtual_machine_extensionHandler) Update(externalID string, desired *Azurerm_virtual_machine_extension) (*Azurerm_virtual_machine_extension, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_virtual_machine_extension", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_virtual_machine_extension", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_machine_extension{Azurerm_virtual_machine_extension_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_virtual_machine_extension", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_virtual_machine_extensionHandler) Read(externalID string) (*Azurerm_virtual_machine_extension, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_virtual_machine_extension", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_virtual_machine_extension", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_machine_extension{Azurerm_virtual_machine_extension_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_virtual_machine_extension", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_virtual_machine_extensionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_virtual_machine_extension", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_virtual_machine_extension", externalID)
}

type Azurerm_virtual_machine_scale_set_boot_diagnostics_236 struct {
	Enabled *bool

	Storage_uri string
}

type Azurerm_virtual_machine_scale_set_extension_237 struct {
	Auto_upgrade_minor_version *bool

	Name string

	Protected_settings *string

	Publisher string

	Settings *string

	Type string

	Type_handler_version string
}

type Azurerm_virtual_machine_scale_set_identity_238 struct {
	Identity_ids *[]string

	Principal_id *string

	Type string
}

type Azurerm_virtual_machine_scale_set_network_profile_239_dns_settings_240 struct {
	Dns_servers []string
}

type Azurerm_virtual_machine_scale_set_network_profile_239_ip_configuration_241_public_ip_address_configuration_242 struct {
	Domain_name_label string

	Idle_timeout int

	Name string
}

type Azurerm_virtual_machine_scale_set_network_profile_239_ip_configuration_241 struct {
	Application_gateway_backend_address_pool_ids *[]string

	Application_security_group_ids *[]string

	Load_balancer_backend_address_pool_ids *[]string

	Load_balancer_inbound_nat_rules_ids *[]string

	Name string

	Primary bool

	Public_ip_address_configuration *[]Azurerm_virtual_machine_scale_set_network_profile_239_ip_configuration_241_public_ip_address_configuration_242

	Subnet_id string
}

type Azurerm_virtual_machine_scale_set_network_profile_239 struct {
	Accelerated_networking *bool

	Dns_settings *[]Azurerm_virtual_machine_scale_set_network_profile_239_dns_settings_240

	Ip_configuration []Azurerm_virtual_machine_scale_set_network_profile_239_ip_configuration_241

	Ip_forwarding *bool

	Name string

	Network_security_group_id *string

	Primary bool
}

type Azurerm_virtual_machine_scale_set_os_profile_243 struct {
	Admin_password *string

	Admin_username string

	Computer_name_prefix string

	Custom_data *string
}

type Azurerm_virtual_machine_scale_set_os_profile_linux_config_244_ssh_keys_245 struct {
	Key_data *string

	Path string
}

type Azurerm_virtual_machine_scale_set_os_profile_linux_config_244 struct {
	Disable_password_authentication *bool

	Ssh_keys *[]Azurerm_virtual_machine_scale_set_os_profile_linux_config_244_ssh_keys_245
}

type Azurerm_virtual_machine_scale_set_os_profile_secrets_246_vault_certificates_247 struct {
	Certificate_store *string

	Certificate_url string
}

type Azurerm_virtual_machine_scale_set_os_profile_secrets_246 struct {
	Source_vault_id string

	Vault_certificates *[]Azurerm_virtual_machine_scale_set_os_profile_secrets_246_vault_certificates_247
}

type Azurerm_virtual_machine_scale_set_os_profile_windows_config_248_additional_unattend_config_249 struct {
	Component string

	Content string

	Pass string

	Setting_name string
}

type Azurerm_virtual_machine_scale_set_os_profile_windows_config_248_winrm_250 struct {
	Certificate_url *string

	Protocol string
}

type Azurerm_virtual_machine_scale_set_os_profile_windows_config_248 struct {
	Additional_unattend_config *[]Azurerm_virtual_machine_scale_set_os_profile_windows_config_248_additional_unattend_config_249

	Enable_automatic_upgrades *bool

	Provision_vm_agent *bool

	Winrm *[]Azurerm_virtual_machine_scale_set_os_profile_windows_config_248_winrm_250
}

type Azurerm_virtual_machine_scale_set_plan_251 struct {
	Name string

	Product string

	Publisher string
}

type Azurerm_virtual_machine_scale_set_rolling_upgrade_policy_252 struct {
	Max_batch_instance_percent *int

	Max_unhealthy_instance_percent *int

	Max_unhealthy_upgraded_instance_percent *int

	Pause_time_between_batches *string
}

type Azurerm_virtual_machine_scale_set_sku_253 struct {
	Capacity int

	Name string

	Tier *string
}

type Azurerm_virtual_machine_scale_set_storage_profile_data_disk_254 struct {
	Caching *string

	Create_option string

	Disk_size_gb *int

	Lun int

	Managed_disk_type *string
}

type Azurerm_virtual_machine_scale_set_storage_profile_image_reference_255 struct {
	Id *string

	Offer *string

	Publisher *string

	Sku *string

	Version *string
}

type Azurerm_virtual_machine_scale_set_storage_profile_os_disk_256 struct {
	Caching *string

	Create_option string

	Image *string

	Managed_disk_type *string

	Name *string

	Os_type *string

	Vhd_containers *[]string
}

type Azurerm_virtual_machine_scale_set struct {
	Azurerm_virtual_machine_scale_set_id *string `lyra:"ignore"`

	Automatic_os_upgrade *bool

	Boot_diagnostics *[]Azurerm_virtual_machine_scale_set_boot_diagnostics_236

	Eviction_policy *string

	Extension *[]Azurerm_virtual_machine_scale_set_extension_237

	Health_probe_id *string

	Identity *[]Azurerm_virtual_machine_scale_set_identity_238

	License_type *string

	Location string

	Name string

	Network_profile []Azurerm_virtual_machine_scale_set_network_profile_239

	Os_profile []Azurerm_virtual_machine_scale_set_os_profile_243

	Os_profile_linux_config *[]Azurerm_virtual_machine_scale_set_os_profile_linux_config_244

	Os_profile_secrets *[]Azurerm_virtual_machine_scale_set_os_profile_secrets_246

	Os_profile_windows_config *[]Azurerm_virtual_machine_scale_set_os_profile_windows_config_248

	Overprovision *bool

	Plan *[]Azurerm_virtual_machine_scale_set_plan_251

	Priority *string

	Resource_group_name string

	Rolling_upgrade_policy *[]Azurerm_virtual_machine_scale_set_rolling_upgrade_policy_252

	Single_placement_group *bool

	Sku []Azurerm_virtual_machine_scale_set_sku_253

	Storage_profile_data_disk *[]Azurerm_virtual_machine_scale_set_storage_profile_data_disk_254

	Storage_profile_image_reference *[]Azurerm_virtual_machine_scale_set_storage_profile_image_reference_255

	Storage_profile_os_disk []Azurerm_virtual_machine_scale_set_storage_profile_os_disk_256

	Tags *map[string]string

	Upgrade_policy_mode string

	Zones *[]string
}

var Azurerm_virtual_machine_scale_set_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_virtual_machine_scale_set_id",

		"automatic_os_upgrade",

		"boot_diagnostics",

		"eviction_policy",

		"extension",

		"health_probe_id",

		"identity",

		"license_type",

		"os_profile_linux_config",

		"os_profile_secrets",

		"os_profile_windows_config",

		"overprovision",

		"plan",

		"priority",

		"rolling_upgrade_policy",

		"single_placement_group",

		"storage_profile_data_disk",

		"storage_profile_image_reference",

		"tags",

		"zones",
	)
	rtb.ImmutableAttributes(

		"eviction_policy",

		"location",

		"name",

		"priority",

		"resource_group_name",

		"single_placement_group",

		"zones",
	)
}

// Azurerm_virtual_machine_scale_setHandler ...
type Azurerm_virtual_machine_scale_setHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_virtual_machine_scale_setHandler) Create(desired *Azurerm_virtual_machine_scale_set) (*Azurerm_virtual_machine_scale_set, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_virtual_machine_scale_set", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_virtual_machine_scale_set", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_virtual_machine_scale_setHandler) Update(externalID string, desired *Azurerm_virtual_machine_scale_set) (*Azurerm_virtual_machine_scale_set, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_virtual_machine_scale_set", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_virtual_machine_scale_set", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_machine_scale_set{Azurerm_virtual_machine_scale_set_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_virtual_machine_scale_set", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_virtual_machine_scale_setHandler) Read(externalID string) (*Azurerm_virtual_machine_scale_set, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_virtual_machine_scale_set", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_virtual_machine_scale_set", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_machine_scale_set{Azurerm_virtual_machine_scale_set_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_virtual_machine_scale_set", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_virtual_machine_scale_setHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_virtual_machine_scale_set", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_virtual_machine_scale_set", externalID)
}

type Azurerm_virtual_network_subnet_257 struct {
	Address_prefix string

	Id *string

	Name string

	Security_group *string
}

type Azurerm_virtual_network struct {
	Azurerm_virtual_network_id *string `lyra:"ignore"`

	Address_space []string

	Dns_servers *[]string

	Location string

	Name string

	Resource_group_name string

	Subnet *[]Azurerm_virtual_network_subnet_257

	Tags *map[string]string
}

var Azurerm_virtual_network_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_virtual_network_id",

		"dns_servers",

		"subnet",

		"tags",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",
	)
}

// Azurerm_virtual_networkHandler ...
type Azurerm_virtual_networkHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_virtual_networkHandler) Create(desired *Azurerm_virtual_network) (*Azurerm_virtual_network, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_virtual_network", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_virtual_network", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_virtual_networkHandler) Update(externalID string, desired *Azurerm_virtual_network) (*Azurerm_virtual_network, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_virtual_network", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_virtual_network", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_network{Azurerm_virtual_network_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_virtual_network", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_virtual_networkHandler) Read(externalID string) (*Azurerm_virtual_network, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_virtual_network", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_virtual_network", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_network{Azurerm_virtual_network_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_virtual_network", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_virtual_networkHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_virtual_network", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_virtual_network", externalID)
}

type Azurerm_virtual_network_gateway_bgp_settings_258 struct {
	Asn *int

	Peer_weight *int

	Peering_address *string
}

type Azurerm_virtual_network_gateway_ip_configuration_259 struct {
	Name *string

	Private_ip_address_allocation *string

	Public_ip_address_id *string

	Subnet_id string
}

type Azurerm_virtual_network_gateway_vpn_client_configuration_260_revoked_certificate_261 struct {
	Name string

	Thumbprint string
}

type Azurerm_virtual_network_gateway_vpn_client_configuration_260_root_certificate_262 struct {
	Name string

	Public_cert_data string
}

type Azurerm_virtual_network_gateway_vpn_client_configuration_260 struct {
	Address_space []string

	Radius_server_address *string

	Radius_server_secret *string

	Revoked_certificate *[]Azurerm_virtual_network_gateway_vpn_client_configuration_260_revoked_certificate_261

	Root_certificate *[]Azurerm_virtual_network_gateway_vpn_client_configuration_260_root_certificate_262

	Vpn_client_protocols *[]string
}

type Azurerm_virtual_network_gateway struct {
	Azurerm_virtual_network_gateway_id *string `lyra:"ignore"`

	Active_active *bool

	Bgp_settings *[]Azurerm_virtual_network_gateway_bgp_settings_258

	Default_local_network_gateway_id *string

	Enable_bgp *bool

	Ip_configuration []Azurerm_virtual_network_gateway_ip_configuration_259

	Location string

	Name string

	Resource_group_name string

	Sku string

	Tags *map[string]string

	Type string

	Vpn_client_configuration *[]Azurerm_virtual_network_gateway_vpn_client_configuration_260

	Vpn_type *string
}

var Azurerm_virtual_network_gateway_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_virtual_network_gateway_id",

		"active_active",

		"bgp_settings",

		"default_local_network_gateway_id",

		"enable_bgp",

		"tags",

		"vpn_client_configuration",

		"vpn_type",
	)
	rtb.ImmutableAttributes(

		"location",

		"name",

		"resource_group_name",

		"type",

		"vpn_type",
	)
}

// Azurerm_virtual_network_gatewayHandler ...
type Azurerm_virtual_network_gatewayHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_virtual_network_gatewayHandler) Create(desired *Azurerm_virtual_network_gateway) (*Azurerm_virtual_network_gateway, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_virtual_network_gateway", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_virtual_network_gateway", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_virtual_network_gatewayHandler) Update(externalID string, desired *Azurerm_virtual_network_gateway) (*Azurerm_virtual_network_gateway, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_virtual_network_gateway", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_virtual_network_gateway", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_network_gateway{Azurerm_virtual_network_gateway_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_virtual_network_gateway", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_virtual_network_gatewayHandler) Read(externalID string) (*Azurerm_virtual_network_gateway, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_virtual_network_gateway", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_virtual_network_gateway", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_network_gateway{Azurerm_virtual_network_gateway_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_virtual_network_gateway", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_virtual_network_gatewayHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_virtual_network_gateway", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_virtual_network_gateway", externalID)
}

type Azurerm_virtual_network_gateway_connection_ipsec_policy_263 struct {
	Dh_group string

	Ike_encryption string

	Ike_integrity string

	Ipsec_encryption string

	Ipsec_integrity string

	Pfs_group string

	Sa_datasize *int

	Sa_lifetime *int
}

type Azurerm_virtual_network_gateway_connection struct {
	Azurerm_virtual_network_gateway_connection_id *string `lyra:"ignore"`

	Authorization_key *string

	Enable_bgp *bool

	Express_route_circuit_id *string

	Ipsec_policy *[]Azurerm_virtual_network_gateway_connection_ipsec_policy_263

	Local_network_gateway_id *string

	Location string

	Name string

	Peer_virtual_network_gateway_id *string

	Resource_group_name string

	Routing_weight *int

	Shared_key *string

	Tags *map[string]string

	Type string

	Use_policy_based_traffic_selectors *bool

	Virtual_network_gateway_id string
}

var Azurerm_virtual_network_gateway_connection_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_virtual_network_gateway_connection_id",

		"authorization_key",

		"enable_bgp",

		"express_route_circuit_id",

		"ipsec_policy",

		"local_network_gateway_id",

		"peer_virtual_network_gateway_id",

		"routing_weight",

		"shared_key",

		"tags",

		"use_policy_based_traffic_selectors",
	)
	rtb.ImmutableAttributes(

		"express_route_circuit_id",

		"location",

		"name",

		"peer_virtual_network_gateway_id",

		"resource_group_name",

		"type",

		"virtual_network_gateway_id",
	)
}

// Azurerm_virtual_network_gateway_connectionHandler ...
type Azurerm_virtual_network_gateway_connectionHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_virtual_network_gateway_connectionHandler) Create(desired *Azurerm_virtual_network_gateway_connection) (*Azurerm_virtual_network_gateway_connection, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_virtual_network_gateway_connection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_virtual_network_gateway_connection", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_virtual_network_gateway_connectionHandler) Update(externalID string, desired *Azurerm_virtual_network_gateway_connection) (*Azurerm_virtual_network_gateway_connection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_virtual_network_gateway_connection", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_virtual_network_gateway_connection", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_network_gateway_connection{Azurerm_virtual_network_gateway_connection_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_virtual_network_gateway_connection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_virtual_network_gateway_connectionHandler) Read(externalID string) (*Azurerm_virtual_network_gateway_connection, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_virtual_network_gateway_connection", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_virtual_network_gateway_connection", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_network_gateway_connection{Azurerm_virtual_network_gateway_connection_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_virtual_network_gateway_connection", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_virtual_network_gateway_connectionHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_virtual_network_gateway_connection", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_virtual_network_gateway_connection", externalID)
}

type Azurerm_virtual_network_peering struct {
	Azurerm_virtual_network_peering_id *string `lyra:"ignore"`

	Allow_forwarded_traffic *bool

	Allow_gateway_transit *bool

	Allow_virtual_network_access *bool

	Name string

	Remote_virtual_network_id string

	Resource_group_name string

	Use_remote_gateways *bool

	Virtual_network_name string
}

var Azurerm_virtual_network_peering_rtb = func(rtb service.ResourceTypeBuilder) {
	rtb.ProvidedAttributes(
		"azurerm_virtual_network_peering_id",

		"allow_forwarded_traffic",

		"allow_gateway_transit",

		"allow_virtual_network_access",

		"use_remote_gateways",
	)
	rtb.ImmutableAttributes(

		"name",

		"remote_virtual_network_id",

		"resource_group_name",

		"virtual_network_name",
	)
}

// Azurerm_virtual_network_peeringHandler ...
type Azurerm_virtual_network_peeringHandler struct {
	provider *schema.Provider
}

// Create ...
func (h *Azurerm_virtual_network_peeringHandler) Create(desired *Azurerm_virtual_network_peering) (*Azurerm_virtual_network_peering, string, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Create Azurerm_virtual_network_peering", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	id, err := bridge.Create(h.provider, "azurerm_virtual_network_peering", rc)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Update ...
func (h *Azurerm_virtual_network_peeringHandler) Update(externalID string, desired *Azurerm_virtual_network_peering) (*Azurerm_virtual_network_peering, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Update Azurerm_virtual_network_peering", "desired", spew.Sdump(desired))
	}
	configureProvider(h.provider)
	rc := &terraform.ResourceConfig{
		Config: bridge.TerraformMarshal(desired),
	}
	actual, err := bridge.Update(h.provider, "azurerm_virtual_network_peering", externalID, rc)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_network_peering{Azurerm_virtual_network_peering_id: &externalID}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Update Actual State Azurerm_virtual_network_peering", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Read ...
func (h *Azurerm_virtual_network_peeringHandler) Read(externalID string) (*Azurerm_virtual_network_peering, error) {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Read Azurerm_virtual_network_peering", "externalID", externalID)
	}
	configureProvider(h.provider)
	id, actual, err := bridge.Read(h.provider, "azurerm_virtual_network_peering", externalID)
	if err != nil {
		return nil, err
	}
	x := &Azurerm_virtual_network_peering{Azurerm_virtual_network_peering_id: &id}
	bridge.TerraformUnmarshal(actual, x)
	if log.IsInfo() {
		log.Info("Read Actual State Azurerm_virtual_network_peering", "actual", spew.Sdump(x))
	}
	return x, nil
}

// Delete ...
func (h *Azurerm_virtual_network_peeringHandler) Delete(externalID string) error {
	log := hclog.Default()
	if log.IsInfo() {
		log.Info("Delete Azurerm_virtual_network_peering", "externalID", externalID)
	}
	configureProvider(h.provider)
	return bridge.Delete(h.provider, "azurerm_virtual_network_peering", externalID)
}
